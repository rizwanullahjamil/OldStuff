#include <stdio.h>
#include <time.h>

char q,                      // Number of empty Cell positions
     r[81],                  // Used for sorting and eliminating empty Cell positions
     s[81];                  // Sudoku (0 to 80) Cell positions Board wise

static char w[81][20] = {    // 20 affected Cell positions individual Cell wise
  { 3, 4, 5, 6, 7, 8, 1, 2,10,11,19,20, 9,18,27,36,45,54,63,72},
  { 3, 4, 5, 6, 7, 8, 0, 2, 9,11,18,20,10,19,28,37,46,55,64,73},
  { 3, 4, 5, 6, 7, 8, 0, 1, 9,10,18,19,11,20,29,38,47,56,65,74},
  { 0, 1, 2, 6, 7, 8, 4, 5,13,14,22,23,12,21,30,39,48,57,66,75},
  { 0, 1, 2, 6, 7, 8, 3, 5,12,14,21,23,13,22,31,40,49,58,67,76},
  { 0, 1, 2, 6, 7, 8, 3, 4,12,13,21,22,14,23,32,41,50,59,68,77},
  { 0, 1, 2, 3, 4, 5, 7, 8,16,17,25,26,15,24,33,42,51,60,69,78},
  { 0, 1, 2, 3, 4, 5, 6, 8,15,17,24,26,16,25,34,43,52,61,70,79},
  { 0, 1, 2, 3, 4, 5, 6, 7,15,16,24,25,17,26,35,44,53,62,71,80},
  {12,13,14,15,16,17,10,11, 1, 2,19,20, 0,18,27,36,45,54,63,72},
  {12,13,14,15,16,17, 9,11, 0, 2,18,20, 1,19,28,37,46,55,64,73},
  {12,13,14,15,16,17, 9,10, 0, 1,18,19, 2,20,29,38,47,56,65,74},
  { 9,10,11,15,16,17,13,14, 4, 5,22,23, 3,21,30,39,48,57,66,75},
  { 9,10,11,15,16,17,12,14, 3, 5,21,23, 4,22,31,40,49,58,67,76},
  { 9,10,11,15,16,17,12,13, 3, 4,21,22, 5,23,32,41,50,59,68,77},
  { 9,10,11,12,13,14,16,17, 7, 8,25,26, 6,24,33,42,51,60,69,78},
  { 9,10,11,12,13,14,15,17, 6, 8,24,26, 7,25,34,43,52,61,70,79},
  { 9,10,11,12,13,14,15,16, 6, 7,24,25, 8,26,35,44,53,62,71,80},
  {21,22,23,24,25,26,19,20, 1, 2,10,11, 0, 9,27,36,45,54,63,72},
  {21,22,23,24,25,26,18,20, 0, 2, 9,11, 1,10,28,37,46,55,64,73},
  {21,22,23,24,25,26,18,19, 0, 1, 9,10, 2,11,29,38,47,56,65,74},
  {18,19,20,24,25,26,22,23, 4, 5,13,14, 3,12,30,39,48,57,66,75},
  {18,19,20,24,25,26,21,23, 3, 5,12,14, 4,13,31,40,49,58,67,76},
  {18,19,20,24,25,26,21,22, 3, 4,12,13, 5,14,32,41,50,59,68,77},
  {18,19,20,21,22,23,25,26, 7, 8,16,17, 6,15,33,42,51,60,69,78},
  {18,19,20,21,22,23,24,26, 6, 8,15,17, 7,16,34,43,52,61,70,79},
  {18,19,20,21,22,23,24,25, 6, 7,15,16, 8,17,35,44,53,62,71,80},
  {30,31,32,33,34,35,28,29,37,38,46,47,36,45, 0, 9,18,54,63,72},
  {30,31,32,33,34,35,27,29,36,38,45,47,37,46, 1,10,19,55,64,73},
  {30,31,32,33,34,35,27,28,36,37,45,46,38,47, 2,11,20,56,65,74},
  {27,28,29,33,34,35,31,32,40,41,49,50,39,48, 3,12,21,57,66,75},
  {27,28,29,33,34,35,30,32,39,41,48,50,40,49, 4,13,22,58,67,76},
  {27,28,29,33,34,35,30,31,39,40,48,49,41,50, 5,14,23,59,68,77},
  {27,28,29,30,31,32,34,35,43,44,52,53,42,51, 6,15,24,60,69,78},
  {27,28,29,30,31,32,33,35,42,44,51,53,43,52, 7,16,25,61,70,79},
  {27,28,29,30,31,32,33,34,42,43,51,52,44,53, 8,17,26,62,71,80},
  {39,40,41,42,43,44,37,38,28,29,46,47,27,45, 0, 9,18,54,63,72},
  {39,40,41,42,43,44,36,38,27,29,45,47,28,46, 1,10,19,55,64,73},
  {39,40,41,42,43,44,36,37,27,28,45,46,29,47, 2,11,20,56,65,74},
  {36,37,38,42,43,44,40,41,31,32,49,50,30,48, 3,12,21,57,66,75},
  {36,37,38,42,43,44,30,32,39,41,48,50,31,49, 4,13,22,58,67,76},
  {36,37,38,42,43,44,30,31,39,40,48,49,32,50, 5,14,23,59,68,77},
  {36,37,38,39,40,41,43,44,34,35,52,53,33,51, 6,15,24,60,69,78},
  {36,37,38,39,40,41,42,44,33,35,51,53,34,52, 7,16,25,61,70,79},
  {36,37,38,39,40,41,42,43,33,34,51,52,35,53, 8,17,26,62,71,80},
  {48,49,50,51,52,53,46,47,28,29,37,38,27,36, 0, 9,18,54,63,72},
  {48,49,50,51,52,53,27,29,36,38,45,47,28,37, 1,10,19,55,64,73},
  {48,49,50,51,52,53,45,46,27,28,36,37,29,38, 2,11,20,56,65,74},
  {45,46,47,51,52,53,49,50,31,32,40,41,30,39, 3,12,21,57,66,75},
  {45,46,47,51,52,53,30,32,39,41,48,50,31,40, 4,13,22,58,67,76},
  {45,46,47,51,52,53,30,31,39,40,48,49,32,41, 5,14,23,59,68,77},
  {45,46,47,48,49,50,52,53,34,35,43,44,33,42, 6,15,24,60,69,78},
  {45,46,47,48,49,50,51,53,33,35,42,44,34,43, 7,16,25,61,70,79},
  {45,46,47,48,49,50,51,52,33,34,42,43,35,44, 8,17,26,62,71,80},
  {57,58,59,60,61,62,55,56,64,65,73,74,63,72, 0, 9,18,27,36,45},
  {57,58,59,60,61,62,54,56,63,65,72,74,64,73, 1,10,19,28,37,46},
  {57,58,59,60,61,62,54,55,63,64,72,73,65,74, 2,11,20,29,38,47},
  {54,55,56,60,61,62,58,59,67,68,76,77,66,75, 3,12,21,30,39,48},
  {54,55,56,60,61,62,57,59,66,68,75,77,67,76, 4,13,22,31,40,49},
  {54,55,56,60,61,62,57,58,66,67,75,76,68,77, 5,14,23,32,41,50},
  {54,55,56,57,58,59,61,62,70,71,79,80,69,78, 6,15,24,33,42,51},
  {54,55,56,57,58,59,60,62,69,71,78,80,70,79, 7,16,25,34,43,52},
  {54,55,56,57,58,59,60,61,69,70,78,79,71,80, 8,17,26,35,44,53},
  {66,67,68,69,70,71,64,65,55,56,73,74,54,72, 0, 9,18,27,36,45},
  {66,67,68,69,70,71,54,56,63,65,72,74,55,73, 1,10,19,28,37,46},
  {66,67,68,69,70,71,63,64,54,55,72,73,56,74, 2,11,20,29,38,47},
  {63,64,65,69,70,71,67,68,58,59,76,77,57,75, 3,12,21,30,39,48},
  {63,64,65,69,70,71,66,68,57,59,75,77,58,76, 4,13,22,31,40,49},
  {63,64,65,69,70,71,66,67,57,58,75,76,59,77, 5,14,23,32,41,50},
  {63,64,65,66,67,68,70,71,61,62,79,80,60,78, 6,15,24,33,42,51},
  {63,64,65,66,67,68,69,71,60,62,78,80,61,79, 7,16,25,34,43,52},
  {63,64,65,66,67,68,69,70,60,61,78,79,62,80, 8,17,26,35,44,53},
  {75,76,77,78,79,80,73,74,55,56,64,65,54,63, 0, 9,18,27,36,45},
  {75,76,77,78,79,80,72,74,54,56,63,65,55,64, 1,10,19,28,37,46},
  {75,76,77,78,79,80,72,73,54,55,63,64,56,65, 2,11,20,29,38,47},
  {72,73,74,78,79,80,76,77,58,59,67,68,57,66, 3,12,21,30,39,48},
  {72,73,74,78,79,80,75,77,57,59,66,68,58,67, 4,13,22,31,40,49},
  {72,73,74,78,79,80,75,76,57,58,66,67,59,68, 5,14,23,32,41,50},
  {72,73,74,75,76,77,79,80,61,62,70,71,60,69, 6,15,24,33,42,51},
  {72,73,74,75,76,77,78,80,60,62,69,71,61,70, 7,16,25,34,43,52},
  {72,73,74,75,76,77,78,79,60,61,69,70,62,71, 8,17,26,35,44,53}},
            l[9][9] = {      // Empty Cell positions for Hidden Single Box wise
  { 0, 1, 2, 9,10,11,18,19,20},
  { 3, 4, 5,12,13,14,21,22,23},
  { 6, 7, 8,15,16,17,24,25,26},
  {27,28,29,36,37,38,45,46,47},
  {30,31,32,39,40,41,48,49,50},
  {33,34,35,42,43,44,51,52,53},
  {54,55,56,63,64,65,72,73,74},
  {57,58,59,66,67,68,75,76,77},
  {60,61,62,69,70,71,78,79,80}};

long n,                      // Number of guesses Board wise
     h;                      // Number of Hidden Singles Board wise

bool g[81][9];               // Possible Cell digits empty Cell position wise

long b2d(char p)             // Convert possible Cell digits from boolean to digits
{
  long b = 1,
       z = 0;

  for(char a = 1; a < 10; a++)
    if(g[p][a - 1])
    {
      z += a * b;
      b *= 10;
    }
  return z;
}

bool solve(char p)
{
  char a,
       x = p;

  long z = b2d(r[x]);

  for(a = p + 1; z > 9 && a < q; a++)
    if(z > b2d(r[a]))        // Check empty Cell positions for least possible Cell digits
    {
      x = a;
      z = b2d(r[x]);
    }
  if(z > 9)                  // Check Naked Single Cell position not found
    for(char zr, zc, zb, zz = 0, b = 0; b < 9; b++)
    {
      for(a = 0; a < 9; a++)
      {
        char rr = 0,
             cc = 0,
             bb = 0;

        for(char y = 0; y < 9; y++)
        {
          if(g[b * 9 + y][a])// Check Hidden Cell digit row wise
          {
            rr++;
            zr = y;
          }
          if(g[b + y * 9][a])// Check Hidden Cell digit column wise
          {
            cc++;
            zc = y;
          }
          if(g[l[b][y]][a])  // Check Hidden Cell digit box wise
          {
            bb++;
            zb = y;
          }
        }
        if(rr == 1 || cc == 1 || bb == 1)
        {                    // Found Hidden Single Cell digit
          z = zz = a + 1;
          if(rr == 1)        // Found Hidden Single Cell digit Row wise
            a = b * 9 + zr;
          else
            if(cc == 1)      // Found Hidden Single Cell digit Column wise
              a = b + zc * 9;
            else             // Found Hidden Single Cell digit Box wise
              a = l[b][zb];
          for(h++, x = p; x < q; x++)
            if(r[x] == a)
              break;
          break;
        }
      }
      if(zz)                 // Found Hidden Single Cell digit
        break;
    }
/*
  if(z > 9)                  // Pointing pair and triplet elimination
  {
    bool k[6];

    for(char b = 0; b < 9; b += 3)
      for(a = 0; a < 9; a++)
      {
        if((g[b * 9][a] | g[b * 9 + 1][a] | g[b * 9 + 2][a]) &&
          !(g[b * 9 + 3][a] |(g[b * 9 + 4][a] | g[b * 9 + 5][a]
          | g[b * 9 + 6][a] | g[b * 9 + 7][a] | g[b * 9 + 8][a]))
        {
       	  k[0] = g[b * 9 + 9][a];
       	  g[b * 9+ 9][a] = 0;
       	  k[1] = g[b * 9 + 10][a];
       	  g[b * 9 + 10][a] = 0;
       	  k[2] = g[b * 9 + 11][a];
       	  g[b * 9 + 11][a] = 0;
       	  k[3] = g[b * 9 + 18][a];
       	  g[b * 9 + 18][a] = 0;
       	  k[4] = g[b * 9 + 19][a];
       	  g[b * 9 + 19][a] = 0;
       	  k[5] = g[b * 9 + 20][a];
       	  g[b * 9 + 20][a] = 0;
       	  if(solve(p))
       	    return 1;
          g[b * 9 + 9][a] = k[0];
          g[b * 9 + 10][a] = k[1];
          g[b * 9 + 11][a] = k[2];
          g[b * 9 + 18][a] = k[3];
          g[b * 9 + 19][a] = k[4];
          g[b * 9 + 20][a] = k[5];
        }
        if((g[b * 9 + 3][a] |(g[b * 9 + 4][a] | g[b * 9 + 5][a]) &&
          !(g[b * 9][a] | g[b * 9 + 1][a] | g[b * 9 + 2][a]
          | g[b * 9 + 6][a] | g[b * 9 + 7][a] | g[b * 9 + 8][a]))
        {
       	  k[0] = g[b * 9 + 12][a];
       	  g[b * 9 + 12][a] = 0;
       	  k[1] = g[b * 9 + 13][a];
       	  g[b * 9 + 13][a] = 0;
       	  k[2] = g[b * 9 + 14][a];
       	  g[b * 9 + 14][a] = 0;
       	  k[1] = g[b * 9 + 21][a];
       	  g[b * 9 + 21][a] = 0;
       	  k[2] = g[b * 9 + 22][a];
       	  g[b * 9 + 22][a] = 0;
       	  k[3] = g[b * 9 + 23][a];
       	  g[b * 9 + 23][a] = 0;
       	  if(solve(p))
       	    return 1;
          g[b * 9 + 12][a] = k[0];
          g[b * 9 + 13][a] = k[1];
          g[b * 9 + 14][a] = k[2];
          g[b * 9 + 21][a] = k[3];
          g[b * 9 + 22][a] = k[4];
          g[b * 9 + 23][a] = k[5];
        }
        if((g[b * 9 + 6][a] | g[b * 9 + 7][a] | g[b * 9 + 8][a]) &&
          ! g[b * 9][a] | g[b * 9 + 1][a] | g[b * 9 + 2][a]
          | (g[b * 9 + 3][a] |(g[b * 9 + 4][a] | g[b * 9 + 5][a])
        {
       	  k[0] = g[b * 9 + 15][a];
       	  g[b * 9 + 15][a] = 0;
       	  k[1] = g[b * 9 + 16][a];
       	  g[b * 9 + 16][a] = 0;
       	  k[2] = g[b * 9 + 17][a];
       	  g[b * 9 + 17][a] = 0;
       	  k[3] = g[b * 9 + 24][a];
       	  g[b * 9 + 24][a] = 0;
       	  k[4] = g[b * 9 + 25][a];
       	  g[b * 9 + 25][a] = 0;
       	  k[5] = g[b * 9 + 26[a];
       	  g[b * 9 + 26][a] = 0;
       	  if(solve(p))
       	    return 1;
          g[b * 9 + 15][a] = k[0];
          g[b * 9 + 16][a] = k[1];
          g[b * 9 + 17][a] = k[2];
          g[b * 9 + 24][a] = k[3];
          g[b * 9 + 25][a] = k[4];
          g[b * 9 + 26][a] = k[5];
        }
        if((g[b * 9][a] | g[b * 9 + 9][a] | g[b * 9 + 18][a]) &&
          !(g[b * 9 + 27][a] |(g[b * 9 + 36][a] | g[b * 9 + 45][a]
          | g[b * 9 + 54][a] | g[b * 9 + 63][a] | g[b * 9 + 72][a]))
        {
       	  k[0] = g[b * 9 + 1][a];
       	  g[b * 9 + 27][a] = 0;
       	  k[1] = g[b * 9 + 10][a];
       	  g[b * 9 + 36][a] = 0;
       	  k[2] = g[b * 9 + 19][a];
       	  g[b * 9 + 45][a] = 0;
       	  k[3] = g[b * 9 + 54][a];
       	  g[b * 9 + 54][a] = 0;
       	  k[4] = g[b * 9 + 10][a];
       	  g[b * 9 + 10][a] = 0;
       	  k[5] = g[b * 9 + 11][a];
       	  g[b * 9 + 11][a] = 0;
       	  if(solve(p))
       	    return 1;
          g[b * 9][a] = k[0];
          g[b * 9 + 1][a] = k[1];
          g[b * 9 + 2][a] = k[2];
          g[b * 9 + 9][a] = k[3];
          g[b * 9 + 10][a] = k[4];
          g[b * 9 + 11][a] = k[5];
        }
      }
  }
*/
  if(x > p)
  {
    a = r[p];
    r[p] = r[x];
    r[x] = a;
  }
  for(; (s[r[p]] = z % 10) > 0; n++, z /= 10)
  {
    bool k[29] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0};

    for(a = 0; a < 9; a++)   // Backup Cell position possible Cell digits
      if(g[r[p]][a])
        {
          k[a + 20] = 1;
          g[r[p]][a] = 0;
        }
    for(a = 0; a < 20; a++)  // Backup affected Cell positions digit wise
      if(g[w[r[p]][a]][s[r[p]] - 1])
      {
        if(b2d(w[r[p]][a]) < 10)
          break;             // Break on one possible Cell digit
        k[a] = 1;
        g[w[r[p]][a]][s[r[p]] - 1] = 0;
      }
    if(a > 19 && (p + 1 >= q || solve(p + 1)))
      return 1;              // If either all Cell positions filled or recursive solve for next empty Cell position
    for(a = 0; a < 9; a++)   // Restore Cell position possible Cell digits
      if(k[a + 20])
        g[r[p]][a] = 1;
    for(a = 0; a < 20; a++)  // Restore affected Cell positions digit wise
      if(k[a])
        g[w[r[p]][a]][s[r[p]] - 1] = 1;
  }
  return 0;
}

bool check(char p, char q)
{
  for(char a = 0; a < 20; a++)
    if(s[w[p][a]] == q)      // Check duplicate Cell position affected Cell position wise
      return 0;
  return 1;
}

bool invalid(void)
{
  for(char p = 0; p < 81; p++)
    if(!s[p])                // Found empty Cell position
    {
      for(char a = 0; a < 9; a++)
                             // Assign empty Cell position digit wise
        g[p][a] = check(p, a + 1);
                             // Assign possible Cell digit in to empty Cell position
      if(!b2d(p))            // Check no possible Cell digit assigned
        return 1;
      r[q++] = p;            // Assign list empty Cell position wise
    }
    else
      if(!check(p, s[p]))    // Check all Cell constraint for pre define Cell position
        return 1;
  return 0;
}

void main(void)
{
  char a = 0,
       m;

  float c,
        d = 0,
        e = 0,
        f = 0;

  long t = 0,
       i = 0,
       u = 0,
       v = 0;

  FILE *o = fopen("sudoku.txt", "r");

  if(o == NULL)
    printf("Unable to open sudoku.txt file for read !!");
  else
    do
      if((m = fgetc(o)) != 10 && m != EOF && a < 81)
        s[a++] = m >= '1' && m <= '9' ? m - '0' : 0;
      else                   // Assign Cell digit to pre define Cell position
        if(m == 10 || m == EOF)
        {
          while(a < 81)
            s[a++] = 0;      // Clear empty Cell positions
          n = h = q = 0;
          c = clock();
          if(invalid())
          {
            c = (clock() - c) / CLOCKS_PER_SEC * 1000;
            d += c;
            printf("%ld) Error: Invalid Sudoku! # I%ld", ++t, ++i);
          }
          else
            if(solve(0))
            {
              c = (clock() - c) / CLOCKS_PER_SEC * 1000;
              e += c;
              printf("%ld) ", ++t);
              for(a = 0; a < 81; a++)
                printf("%c", s[a] ? s[a] + '0' : '.');
              printf(" # S%ld", ++v);
            }
            else
            {
              c = (clock() - c) / CLOCKS_PER_SEC * 1000;
              f += c;
              printf("%ld) Error: Unsolvable Sudoku! # U%ld", ++t, ++u);
            }
          printf(" # N%ld # H%ld # %f\n", n, h, c);
          a = 0;
        }
    while(m != EOF);
  printf("=======================================\n");
  printf("Total Sudoku puzzle read   : %ld\n", t);
  printf("Total time for all puzzles : %f\n", d + e + f);
  if(t)
    printf("Average time per puzzle    : %f\n", (d + e + f) / t);
  printf("Number of invalid puzzles  : %ld\n", i);
  printf("Time for invalid puzzles   : %f\n", d);
  if(i)
    printf("Average time per invalid   : %f\n", d / i);
  printf("Number of solved puzzles   : %ld\n", v);
  printf("Time for solved puzzles    : %f\n", e);
  if(v)
    printf("Average time per solved    : %f\n", e / v);
  printf("Number of unsolved puzzle  : %ld\n", u);
  printf("Time for unsolved puzzles  : %f\n", f);
  if(u)
    printf("Average time per unsolved  : %f\n", f / u);
  if(fclose(o) == EOF)
    printf("Unable to close sudoku.txt file !!");
}
