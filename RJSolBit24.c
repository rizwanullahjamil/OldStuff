#include <stdio.h>
#include <time.h>

#define RJ 0                 // 0 no debugging, 1 print solutions, 2 print puzzles, 3 print steps, 4 print possibilities

#define ERI(A) (g[w[A][6]] | g[w[A][7]]) & (g[w[A][12]] | g[w[A][13]]) & \
               ~(g[w[A][8]] | g[w[A][9]] | g[w[A][10]] | g[w[A][11]])
#define LN1(A, B, C, D) g[X = A] & g[Z = B] & \
                        ~(g[w[X][W[3][D]]] | g[w[X][W[4][D]]] | \
                        g[w[Z][W[3][D]]] | g[w[Z][W[4][D]]] | \
                        g[C] | g[w[C][W[3][D]]] | g[w[C][W[4][D]]])
#define LN3(A, B, C, D) g[X = A] & (g[Z = B] | \
                        g[w[Z][W[3][D]]] | g[w[Z][W[4][D]]]) & \
                        ~(g[w[X][W[3][D]]] | g[w[X][W[4][D]]] | \
                        g[C] | g[w[C][W[3][D]]] | g[w[C][W[4][D]]])
#define LB3(A, B, C, D) (g[X = A] | g[w[X][W[3][D]]] | g[w[X][W[4][D]]]) & \
                        (g[Z = B] | g[w[Z][W[3][D]]] | g[w[Z][W[4][D]]]) & \
                        ~(g[C] | g[w[C][W[3][D]]] | g[w[C][W[4][D]]])
#if RJ > 2
#define RCB y < 9 ? "Row" : y < 18 ? "Column" : "Box"
#define LBN(A) b[(y < 9 ? w[A][20] >> 18 : y < 18 ? w[A][20] : w[A][20] >> 9) & 511]
#define R_C y ? "Column" : "Row"
#define RCN(A) b[(y ? w[A][20] : w[A][20] >> 18) & 511]
#define BOX(A) b[(w[A][20] >> 9) & 511]

static const char *S[81] = {
  "r1c1", "r1c2", "r1c3", "r1c4", "r1c5", "r1c6", "r1c7", "r1c8", "r1c9",
  "r2c1", "r2c2", "r2c3", "r2c4", "r2c5", "r2c6", "r2c7", "r2c8", "r2c9",
  "r3c1", "r3c2", "r3c3", "r3c4", "r3c5", "r3c6", "r3c7", "r3c8", "r3c9",
  "r4c1", "r4c2", "r4c3", "r4c4", "r4c5", "r4c6", "r4c7", "r4c8", "r4c9",
  "r5c1", "r5c2", "r5c3", "r5c4", "r5c5", "r5c6", "r5c7", "r5c8", "r5c9",
  "r6c1", "r6c2", "r6c3", "r6c4", "r6c5", "r6c6", "r6c7", "r6c8", "r6c9",
  "r7c1", "r7c2", "r7c3", "r7c4", "r7c5", "r7c6", "r7c7", "r7c8", "r7c9",
  "r8c1", "r8c2", "r8c3", "r8c4", "r8c5", "r8c6", "r8c7", "r8c8", "r8c9",
  "r9c1", "r9c2", "r9c3", "r9c4", "r9c5", "r9c6", "r9c7", "r9c8", "r9c9"};
#endif

int q,                       // Number of unsolved Cell positions Grid wise
    r[81],                   // Used for sorting and excluding each unsolved Cell positions Grid wise
    s[81],                   // Sudoku Grid 81 Cell positions for clues and solved
    g[81],                   // Bitwise Cell Values unsolved Cell positions Grid wise
    n[9];                    // Number of Naked singles, Hidden singles, Guesses and Depth Grid wise, solved without guess, maximum guess and depth, number of possibilities

static const int b[512] = {  // Bitwise to digit Cell Values
          0,        1,        2,       12,        3,       13,       23,      123,
          4,       14,       24,      124,       34,      134,      234,     1234,
          5,       15,       25,      125,       35,      135,      235,     1235,
         45,      145,      245,     1245,      345,     1345,     2345,    12345,
          6,       16,       26,      126,       36,      136,      236,     1236,
         46,      146,      246,     1246,      346,     1346,     2346,    12346,
         56,      156,      256,     1256,      356,     1356,     2356,    12356,
        456,     1456,     2456,    12456,     3456,    13456,    23456,   123456,
          7,       17,       27,      127,       37,      137,      237,     1237,
         47,      147,      247,     1247,      347,     1347,     2347,    12347,
         57,      157,      257,     1257,      357,     1357,     2357,    12357,
        457,     1457,     2457,    12457,     3457,    13457,    23457,   123457,
         67,      167,      267,     1267,      367,     1367,     2367,    12367,
        467,     1467,     2467,    12467,     3467,    13467,    23467,   123467,
        567,     1567,     2567,    12567,     3567,    13567,    23567,   123567,
       4567,    14567,    24567,   124567,    34567,   134567,   234567,  1234567,
          8,       18,       28,      128,       38,      138,      238,     1238,
         48,      148,      248,     1248,      348,     1348,     2348,    12348,
         58,      158,      258,     1258,      358,     1358,     2358,    12358,
        458,     1458,     2458,    12458,     3458,    13458,    23458,   123458,
         68,      168,      268,     1268,      368,     1368,     2368,    12368,
        468,     1468,     2468,    12468,     3468,    13468,    23468,   123468,
        568,     1568,     2568,    12568,     3568,    13568,    23568,   123568,
       4568,    14568,    24568,   124568,    34568,   134568,   234568,  1234568,
         78,      178,      278,     1278,      378,     1378,     2378,    12378,
        478,     1478,     2478,    12478,     3478,    13478,    23478,   123478,
        578,     1578,     2578,    12578,     3578,    13578,    23578,   123578,
       4578,    14578,    24578,   124578,    34578,   134578,   234578,  1234578,
        678,     1678,     2678,    12678,     3678,    13678,    23678,   123678,
       4678,    14678,    24678,   124678,    34678,   134678,   234678,  1234678,
       5678,    15678,    25678,   125678,    35678,   135678,   235678,  1235678,
      45678,   145678,   245678,  1245678,   345678,  1345678,  2345678, 12345678,
          9,       19,       29,      129,       39,      139,      239,     1239,
         49,      149,      249,     1249,      349,     1349,     2349,    12349,
         59,      159,      259,     1259,      359,     1359,     2359,    12359,
        459,     1459,     2459,    12459,     3459,    13459,    23459,   123459,
         69,      169,      269,     1269,      369,     1369,     2369,    12369,
        469,     1469,     2469,    12469,     3469,    13469,    23469,   123469,
        569,     1569,     2569,    12569,     3569,    13569,    23569,   123569,
       4569,    14569,    24569,   124569,    34569,   134569,   234569,  1234569,
         79,      179,      279,     1279,      379,     1379,     2379,    12379,
        479,     1479,     2479,    12479,     3479,    13479,    23479,   123479,
        579,     1579,     2579,    12579,     3579,    13579,    23579,   123579,
       4579,    14579,    24579,   124579,    34579,   134579,   234579,  1234579,
        679,     1679,     2679,    12679,     3679,    13679,    23679,   123679,
       4679,    14679,    24679,   124679,    34679,   134679,   234679,  1234679,
       5679,    15679,    25679,   125679,    35679,   135679,   235679,  1235679,
      45679,   145679,   245679,  1245679,   345679,  1345679,  2345679, 12345679,
         89,      189,      289,     1289,      389,     1389,     2389,    12389,
        489,     1489,     2489,    12489,     3489,    13489,    23489,   123489,
        589,     1589,     2589,    12589,     3589,    13589,    23589,   123589,
       4589,    14589,    24589,   124589,    34589,   134589,   234589,  1234589,
        689,     1689,     2689,    12689,     3689,    13689,    23689,   123689,
       4689,    14689,    24689,   124689,    34689,   134689,   234689,  1234689,
       5689,    15689,    25689,   125689,    35689,   135689,   235689,  1235689,
      45689,   145689,   245689,  1245689,   345689,  1345689,  2345689, 12345689,
        789,     1789,     2789,    12789,     3789,    13789,    23789,   123789,
       4789,    14789,    24789,   124789,    34789,   134789,   234789,  1234789,
       5789,    15789,    25789,   125789,    35789,   135789,   235789,  1235789,
      45789,   145789,   245789,  1245789,   345789,  1345789,  2345789, 12345789,
       6789,    16789,    26789,   126789,    36789,   136789,   236789,  1236789,
      46789,   146789,   246789,  1246789,   346789,  1346789,  2346789, 12346789,
      56789,   156789,   256789,  1256789,   356789,  1356789,  2356789, 12356789,
     456789,  1456789,  2456789, 12456789,  3456789, 13456789, 23456789,123456789},
           B[513] = {        // Count bitwise Cell Values
   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9,10},
           w[81][21] = {     // 20 peer Cell positions; and Band, Stack, Row, Box and Column for 81 Cell positions
  { 3, 4, 5, 6, 7, 8, 1, 2,10,11,19,20, 9,18,27,36,45,54,63,72,    262657},
  { 3, 4, 5, 6, 7, 8, 0, 2, 9,11,18,20,10,19,28,37,46,55,64,73,    262658},
  { 3, 4, 5, 6, 7, 8, 0, 1, 9,10,18,19,11,20,29,38,47,56,65,74,    262660},
  { 0, 1, 2, 6, 7, 8, 4, 5,13,14,22,23,12,21,30,39,48,57,66,75, 134480904},
  { 0, 1, 2, 6, 7, 8, 3, 5,12,14,21,23,13,22,31,40,49,58,67,76, 134480912},
  { 0, 1, 2, 6, 7, 8, 3, 4,12,13,21,22,14,23,32,41,50,59,68,77, 134480928},
  { 0, 1, 2, 3, 4, 5, 7, 8,16,17,25,26,15,24,33,42,51,60,69,78, 268699712},
  { 0, 1, 2, 3, 4, 5, 6, 8,15,17,24,26,16,25,34,43,52,61,70,79, 268699776},
  { 0, 1, 2, 3, 4, 5, 6, 7,15,16,24,25,17,26,35,44,53,62,71,80, 268699904},
  {12,13,14,15,16,17,10,11, 1, 2,19,20, 0,18,27,36,45,54,63,72,    524801},
  {12,13,14,15,16,17, 9,11, 0, 2,18,20, 1,19,28,37,46,55,64,73,    524802},
  {12,13,14,15,16,17, 9,10, 0, 1,18,19, 2,20,29,38,47,56,65,74,    524804},
  { 9,10,11,15,16,17,13,14, 4, 5,22,23, 3,21,30,39,48,57,66,75, 134743048},
  { 9,10,11,15,16,17,12,14, 3, 5,21,23, 4,22,31,40,49,58,67,76, 134743056},
  { 9,10,11,15,16,17,12,13, 3, 4,21,22, 5,23,32,41,50,59,68,77, 134743072},
  { 9,10,11,12,13,14,16,17, 7, 8,25,26, 6,24,33,42,51,60,69,78, 268961856},
  { 9,10,11,12,13,14,15,17, 6, 8,24,26, 7,25,34,43,52,61,70,79, 268961920},
  { 9,10,11,12,13,14,15,16, 6, 7,24,25, 8,26,35,44,53,62,71,80, 268962048},
  {21,22,23,24,25,26,19,20, 1, 2,10,11, 0, 9,27,36,45,54,63,72,   1049089},
  {21,22,23,24,25,26,18,20, 0, 2, 9,11, 1,10,28,37,46,55,64,73,   1049090},
  {21,22,23,24,25,26,18,19, 0, 1, 9,10, 2,11,29,38,47,56,65,74,   1049092},
  {18,19,20,24,25,26,22,23, 4, 5,13,14, 3,12,30,39,48,57,66,75, 135267336},
  {18,19,20,24,25,26,21,23, 3, 5,12,14, 4,13,31,40,49,58,67,76, 135267344},
  {18,19,20,24,25,26,21,22, 3, 4,12,13, 5,14,32,41,50,59,68,77, 135267360},
  {18,19,20,21,22,23,25,26, 7, 8,16,17, 6,15,33,42,51,60,69,78, 269486144},
  {18,19,20,21,22,23,24,26, 6, 8,15,17, 7,16,34,43,52,61,70,79, 269486208},
  {18,19,20,21,22,23,24,25, 6, 7,15,16, 8,17,35,44,53,62,71,80, 269486336},
  {30,31,32,33,34,35,28,29,37,38,46,47,36,45, 0, 9,18,54,63,72, 538972161},
  {30,31,32,33,34,35,27,29,36,38,45,47,37,46, 1,10,19,55,64,73, 538972162},
  {30,31,32,33,34,35,27,28,36,37,45,46,38,47, 2,11,20,56,65,74, 538972164},
  {27,28,29,33,34,35,31,32,40,41,49,50,39,48, 3,12,21,57,66,75, 673193992},
  {27,28,29,33,34,35,30,32,39,41,48,50,40,49, 4,13,22,58,67,76, 673194000},
  {27,28,29,33,34,35,30,31,39,40,48,49,41,50, 5,14,23,59,68,77, 673194016},
  {27,28,29,30,31,32,34,35,43,44,52,53,42,51, 6,15,24,60,69,78, 807419968},
  {27,28,29,30,31,32,33,35,42,44,51,53,43,52, 7,16,25,61,70,79, 807420032},
  {27,28,29,30,31,32,33,34,42,43,51,52,44,53, 8,17,26,62,71,80, 807420160},
  {39,40,41,42,43,44,37,38,28,29,46,47,27,45, 0, 9,18,54,63,72, 541069313},
  {39,40,41,42,43,44,36,38,27,29,45,47,28,46, 1,10,19,55,64,73, 541069314},
  {39,40,41,42,43,44,36,37,27,28,45,46,29,47, 2,11,20,56,65,74, 541069316},
  {36,37,38,42,43,44,40,41,31,32,49,50,30,48, 3,12,21,57,66,75, 675291144},
  {36,37,38,42,43,44,39,41,30,32,48,50,31,49, 4,13,22,58,67,76, 675291152},
  {36,37,38,42,43,44,39,40,30,31,48,49,32,50, 5,14,23,59,68,77, 675291168},
  {36,37,38,39,40,41,43,44,34,35,52,53,33,51, 6,15,24,60,69,78, 809517120},
  {36,37,38,39,40,41,42,44,33,35,51,53,34,52, 7,16,25,61,70,79, 809517184},
  {36,37,38,39,40,41,42,43,33,34,51,52,35,53, 8,17,26,62,71,80, 809517312},
  {48,49,50,51,52,53,46,47,28,29,37,38,27,36, 0, 9,18,54,63,72, 545263617},
  {48,49,50,51,52,53,45,47,27,29,36,38,28,37, 1,10,19,55,64,73, 545263618},
  {48,49,50,51,52,53,45,46,27,28,36,37,29,38, 2,11,20,56,65,74, 545263620},
  {45,46,47,51,52,53,49,50,31,32,40,41,30,39, 3,12,21,57,66,75, 679485448},
  {45,46,47,51,52,53,48,50,30,32,39,41,31,40, 4,13,22,58,67,76, 679485456},
  {45,46,47,51,52,53,48,49,30,31,39,40,32,41, 5,14,23,59,68,77, 679485472},
  {45,46,47,48,49,50,52,53,34,35,43,44,33,42, 6,15,24,60,69,78, 813711424},
  {45,46,47,48,49,50,51,53,33,35,42,44,34,43, 7,16,25,61,70,79, 813711488},
  {45,46,47,48,49,50,51,52,33,34,42,43,35,44, 8,17,26,62,71,80, 813711616},
  {57,58,59,60,61,62,55,56,64,65,73,74,63,72, 0, 9,18,27,36,45,1090551809},
  {57,58,59,60,61,62,54,56,63,65,72,74,64,73, 1,10,19,28,37,46,1090551810},
  {57,58,59,60,61,62,54,55,63,64,72,73,65,74, 2,11,20,29,38,47,1090551812},
  {54,55,56,60,61,62,58,59,67,68,76,77,66,75, 3,12,21,30,39,48,1224802312},
  {54,55,56,60,61,62,57,59,66,68,75,77,67,76, 4,13,22,31,40,49,1224802320},
  {54,55,56,60,61,62,57,58,66,67,75,76,68,77, 5,14,23,32,41,50,1224802336},
  {54,55,56,57,58,59,61,62,70,71,79,80,69,78, 6,15,24,33,42,51,1359085632},
  {54,55,56,57,58,59,60,62,69,71,78,80,70,79, 7,16,25,34,43,52,1359085696},
  {54,55,56,57,58,59,60,61,69,70,78,79,71,80, 8,17,26,35,44,53,1359085824},
  {66,67,68,69,70,71,64,65,55,56,73,74,54,72, 0, 9,18,27,36,45,1107329025},
  {66,67,68,69,70,71,63,65,54,56,72,74,55,73, 1,10,19,28,37,46,1107329026},
  {66,67,68,69,70,71,63,64,54,55,72,73,56,74, 2,11,20,29,38,47,1107329028},
  {63,64,65,69,70,71,67,68,58,59,76,77,57,75, 3,12,21,30,39,48,1241579528},
  {63,64,65,69,70,71,66,68,57,59,75,77,58,76, 4,13,22,31,40,49,1241579536},
  {63,64,65,69,70,71,66,67,57,58,75,76,59,77, 5,14,23,32,41,50,1241579552},
  {63,64,65,66,67,68,70,71,61,62,79,80,60,78, 6,15,24,33,42,51,1375862848},
  {63,64,65,66,67,68,69,71,60,62,78,80,61,79, 7,16,25,34,43,52,1375862912},
  {63,64,65,66,67,68,69,70,60,61,78,79,62,80, 8,17,26,35,44,53,1375863040},
  {75,76,77,78,79,80,73,74,55,56,64,65,54,63, 0, 9,18,27,36,45,1140883457},
  {75,76,77,78,79,80,72,74,54,56,63,65,55,64, 1,10,19,28,37,46,1140883458},
  {75,76,77,78,79,80,72,73,54,55,63,64,56,65, 2,11,20,29,38,47,1140883460},
  {72,73,74,78,79,80,76,77,58,59,67,68,57,66, 3,12,21,30,39,48,1275133960},
  {72,73,74,78,79,80,75,77,57,59,66,68,58,67, 4,13,22,31,40,49,1275133968},
  {72,73,74,78,79,80,75,76,57,58,66,67,59,68, 5,14,23,32,41,50,1275133984},
  {72,73,74,75,76,77,79,80,61,62,70,71,60,69, 6,15,24,33,42,51,1409417280},
  {72,73,74,75,76,77,78,80,60,62,69,71,61,70, 7,16,25,34,43,52,1409417344},
  {72,73,74,75,76,77,78,79,60,61,69,70,62,71, 8,17,26,35,44,53,1409417472}},
           l[27][9] = {      // 9 Cell positions for 27 Units
  { 0, 1, 2, 3, 4, 5, 6, 7, 8}, { 9,10,11,12,13,14,15,16,17}, {18,19,20,21,22,23,24,25,26},
  {27,28,29,30,31,32,33,34,35}, {36,37,38,39,40,41,42,43,44}, {45,46,47,48,49,50,51,52,53},
  {54,55,56,57,58,59,60,61,62}, {63,64,65,66,67,68,69,70,71}, {72,73,74,75,76,77,78,79,80},
  { 0, 9,18,27,36,45,54,63,72}, { 1,10,19,28,37,46,55,64,73}, { 2,11,20,29,38,47,56,65,74},
  { 3,12,21,30,39,48,57,66,75}, { 4,13,22,31,40,49,58,67,76}, { 5,14,23,32,41,50,59,68,77},
  { 6,15,24,33,42,51,60,69,78}, { 7,16,25,34,43,52,61,70,79}, { 8,17,26,35,44,53,62,71,80},
  { 0, 1, 2, 9,10,11,18,19,20}, { 3, 4, 5,12,13,14,21,22,23}, { 6, 7, 8,15,16,17,24,25,26},
  {27,28,29,36,37,38,45,46,47}, {30,31,32,39,40,41,48,49,50}, {33,34,35,42,43,44,51,52,53},
  {54,55,56,63,64,65,72,73,74}, {57,58,59,66,67,68,75,76,77}, {60,61,62,69,70,71,78,79,80}},
           h[246][9] = {     // 36 pairs/84 triplets/126 quads and other Cell positions Unit wise
  { 0, 1, 2, 3, 4, 5, 6, 7, 8}, { 0, 2, 1, 3, 4, 5, 6, 7, 8}, { 0, 3, 1, 2, 4, 5, 6, 7, 8},
  { 0, 4, 1, 2, 3, 5, 6, 7, 8}, { 0, 5, 1, 2, 3, 4, 6, 7, 8}, { 0, 6, 1, 2, 3, 4, 5, 7, 8},
  { 0, 7, 1, 2, 3, 4, 5, 6, 8}, { 0, 8, 1, 2, 3, 4, 5, 6, 7}, { 1, 2, 0, 3, 4, 5, 6, 7, 8},
  { 1, 3, 0, 2, 4, 5, 6, 7, 8}, { 1, 4, 0, 2, 3, 5, 6, 7, 8}, { 1, 5, 0, 2, 3, 4, 6, 7, 8},
  { 1, 6, 0, 2, 3, 4, 5, 7, 8}, { 1, 7, 0, 2, 3, 4, 5, 6, 8}, { 1, 8, 0, 2, 3, 4, 5, 6, 7},
  { 2, 3, 0, 1, 4, 5, 6, 7, 8}, { 2, 4, 0, 1, 3, 5, 6, 7, 8}, { 2, 5, 0, 1, 3, 4, 6, 7, 8},
  { 2, 6, 0, 1, 3, 4, 5, 7, 8}, { 2, 7, 0, 1, 3, 4, 5, 6, 8}, { 2, 8, 0, 1, 3, 4, 5, 6, 7},
  { 3, 4, 0, 1, 2, 5, 6, 7, 8}, { 3, 5, 0, 1, 2, 4, 6, 7, 8}, { 3, 6, 0, 1, 2, 4, 5, 7, 8},
  { 3, 7, 0, 1, 2, 4, 5, 6, 8}, { 3, 8, 0, 1, 2, 4, 5, 6, 7}, { 4, 5, 0, 1, 2, 3, 6, 7, 8},
  { 4, 6, 0, 1, 2, 3, 5, 7, 8}, { 4, 7, 0, 1, 2, 3, 5, 6, 8}, { 4, 8, 0, 1, 2, 3, 5, 6, 7},
  { 5, 6, 0, 1, 2, 3, 4, 7, 8}, { 5, 7, 0, 1, 2, 3, 4, 6, 8}, { 5, 8, 0, 1, 2, 3, 4, 6, 7},
  { 6, 7, 0, 1, 2, 3, 4, 5, 8}, { 6, 8, 0, 1, 2, 3, 4, 5, 7}, { 7, 8, 0, 1, 2, 3, 4, 5, 6},
  { 0, 1, 2, 3, 4, 5, 6, 7, 8}, { 0, 1, 3, 2, 4, 5, 6, 7, 8}, { 0, 1, 4, 2, 3, 5, 6, 7, 8},
  { 0, 1, 5, 2, 3, 4, 6, 7, 8}, { 0, 1, 6, 2, 3, 4, 5, 7, 8}, { 0, 1, 7, 2, 3, 4, 5, 6, 8},
  { 0, 1, 8, 2, 3, 4, 5, 6, 7}, { 0, 2, 3, 1, 4, 5, 6, 7, 8}, { 0, 2, 4, 1, 3, 5, 6, 7, 8},
  { 0, 2, 5, 1, 3, 4, 6, 7, 8}, { 0, 2, 6, 1, 3, 4, 5, 7, 8}, { 0, 2, 7, 1, 3, 4, 5, 6, 8},
  { 0, 2, 8, 1, 3, 4, 5, 6, 7}, { 0, 3, 4, 1, 2, 5, 6, 7, 8}, { 0, 3, 5, 1, 2, 4, 6, 7, 8},
  { 0, 3, 6, 1, 2, 4, 5, 7, 8}, { 0, 3, 7, 1, 2, 4, 5, 6, 8}, { 0, 3, 8, 1, 2, 4, 5, 6, 7},
  { 0, 4, 5, 1, 2, 3, 6, 7, 8}, { 0, 4, 6, 1, 2, 3, 5, 7, 8}, { 0, 4, 7, 1, 2, 3, 5, 6, 8},
  { 0, 4, 8, 1, 2, 3, 5, 6, 7}, { 0, 5, 6, 1, 2, 3, 4, 7, 8}, { 0, 5, 7, 1, 2, 3, 4, 6, 8},
  { 0, 5, 8, 1, 2, 3, 4, 6, 7}, { 0, 6, 7, 1, 2, 3, 4, 5, 8}, { 0, 6, 8, 1, 2, 3, 4, 5, 7},
  { 0, 7, 8, 1, 2, 3, 4, 5, 6}, { 1, 2, 3, 0, 4, 5, 6, 7, 8}, { 1, 2, 4, 0, 3, 5, 6, 7, 8},
  { 1, 2, 5, 0, 3, 4, 6, 7, 8}, { 1, 2, 6, 0, 3, 4, 5, 7, 8}, { 1, 2, 7, 0, 3, 4, 5, 6, 8},
  { 1, 2, 8, 0, 3, 4, 5, 6, 7}, { 1, 3, 4, 0, 2, 5, 6, 7, 8}, { 1, 3, 5, 0, 2, 4, 6, 7, 8},
  { 1, 3, 6, 0, 2, 4, 5, 7, 8}, { 1, 3, 7, 0, 2, 4, 5, 6, 8}, { 1, 3, 8, 0, 2, 4, 5, 6, 7},
  { 1, 4, 5, 0, 2, 3, 6, 7, 8}, { 1, 4, 6, 0, 2, 3, 5, 7, 8}, { 1, 4, 7, 0, 2, 3, 5, 6, 8},
  { 1, 4, 8, 0, 2, 3, 5, 6, 7}, { 1, 5, 6, 0, 2, 3, 4, 7, 8}, { 1, 5, 7, 0, 2, 3, 4, 6, 8},
  { 1, 5, 8, 0, 2, 3, 4, 6, 7}, { 1, 6, 7, 0, 2, 3, 4, 5, 8}, { 1, 6, 8, 0, 2, 3, 4, 5, 7},
  { 1, 7, 8, 0, 2, 3, 4, 5, 6}, { 2, 3, 4, 0, 1, 5, 6, 7, 8}, { 2, 3, 5, 0, 1, 4, 6, 7, 8},
  { 2, 3, 6, 0, 1, 4, 5, 7, 8}, { 2, 3, 7, 0, 1, 4, 5, 6, 8}, { 2, 3, 8, 0, 1, 4, 5, 6, 7},
  { 2, 4, 5, 0, 1, 3, 6, 7, 8}, { 2, 4, 6, 0, 1, 3, 5, 7, 8}, { 2, 4, 7, 0, 1, 3, 5, 6, 8},
  { 2, 4, 8, 0, 1, 3, 5, 6, 7}, { 2, 5, 6, 0, 1, 3, 4, 7, 8}, { 2, 5, 7, 0, 1, 3, 4, 6, 8},
  { 2, 5, 8, 0, 1, 3, 4, 6, 7}, { 2, 6, 7, 0, 1, 3, 4, 5, 8}, { 2, 6, 8, 0, 1, 3, 4, 5, 7},
  { 2, 7, 8, 0, 1, 3, 4, 5, 6}, { 3, 4, 5, 0, 1, 2, 6, 7, 8}, { 3, 4, 6, 0, 1, 2, 5, 7, 8},
  { 3, 4, 7, 0, 1, 2, 5, 6, 8}, { 3, 4, 8, 0, 1, 2, 5, 6, 7}, { 3, 5, 6, 0, 1, 2, 4, 7, 8},
  { 3, 5, 7, 0, 1, 2, 4, 6, 8}, { 3, 5, 8, 0, 1, 2, 4, 6, 7}, { 3, 6, 7, 0, 1, 2, 4, 5, 8},
  { 3, 6, 8, 0, 1, 2, 4, 5, 7}, { 3, 7, 8, 0, 1, 2, 4, 5, 6}, { 4, 5, 6, 0, 1, 2, 3, 7, 8},
  { 4, 5, 7, 0, 1, 2, 3, 6, 8}, { 4, 5, 8, 0, 1, 2, 3, 6, 7}, { 4, 6, 7, 0, 1, 2, 3, 5, 8},
  { 4, 6, 8, 0, 1, 2, 3, 5, 7}, { 4, 7, 8, 0, 1, 2, 3, 5, 6}, { 5, 6, 7, 0, 1, 2, 3, 4, 8},
  { 5, 6, 8, 0, 1, 2, 3, 4, 7}, { 5, 7, 8, 0, 1, 2, 3, 4, 6}, { 6, 7, 8, 0, 1, 2, 3, 4, 5},
  { 0, 1, 2, 3, 4, 5, 6, 7, 8}, { 0, 1, 2, 4, 3, 5, 6, 7, 8}, { 0, 1, 2, 5, 3, 4, 6, 7, 8},
  { 0, 1, 2, 6, 3, 4, 5, 7, 8}, { 0, 1, 2, 7, 3, 4, 5, 6, 8}, { 0, 1, 2, 8, 3, 4, 5, 6, 7},
  { 0, 1, 3, 4, 2, 5, 6, 7, 8}, { 0, 1, 3, 5, 2, 4, 6, 7, 8}, { 0, 1, 3, 6, 2, 4, 5, 7, 8},
  { 0, 1, 3, 7, 2, 4, 5, 6, 8}, { 0, 1, 3, 8, 2, 4, 5, 6, 7}, { 0, 1, 4, 5, 2, 3, 6, 7, 8},
  { 0, 1, 4, 6, 2, 3, 5, 7, 8}, { 0, 1, 4, 7, 2, 3, 5, 6, 8}, { 0, 1, 4, 8, 2, 3, 5, 6, 7},
  { 0, 1, 5, 6, 2, 3, 4, 7, 8}, { 0, 1, 5, 7, 2, 3, 4, 6, 8}, { 0, 1, 5, 8, 2, 3, 4, 6, 7},
  { 0, 1, 6, 7, 2, 3, 4, 5, 8}, { 0, 1, 6, 8, 2, 3, 4, 5, 7}, { 0, 1, 7, 8, 2, 3, 4, 5, 6},
  { 0, 2, 3, 4, 1, 5, 6, 7, 8}, { 0, 2, 3, 5, 1, 4, 6, 7, 8}, { 0, 2, 3, 6, 1, 4, 5, 7, 8},
  { 0, 2, 3, 7, 1, 4, 5, 6, 8}, { 0, 2, 3, 8, 1, 4, 5, 6, 7}, { 0, 2, 4, 5, 1, 3, 6, 7, 8},
  { 0, 2, 4, 6, 1, 3, 5, 7, 8}, { 0, 2, 4, 7, 1, 3, 5, 6, 8}, { 0, 2, 4, 8, 1, 3, 5, 6, 7},
  { 0, 2, 5, 6, 1, 3, 4, 7, 8}, { 0, 2, 5, 7, 1, 3, 4, 6, 8}, { 0, 2, 5, 8, 1, 3, 4, 6, 7},
  { 0, 2, 6, 7, 1, 3, 4, 5, 8}, { 0, 2, 6, 8, 1, 3, 4, 5, 7}, { 0, 2, 7, 8, 1, 3, 4, 5, 6},
  { 0, 3, 4, 5, 1, 2, 6, 7, 8}, { 0, 3, 4, 6, 1, 2, 5, 7, 8}, { 0, 3, 4, 7, 1, 2, 5, 6, 8},
  { 0, 3, 4, 8, 1, 2, 5, 6, 7}, { 0, 3, 5, 6, 1, 2, 4, 7, 8}, { 0, 3, 5, 7, 1, 2, 4, 6, 8},
  { 0, 3, 5, 8, 1, 2, 4, 6, 7}, { 0, 3, 6, 7, 1, 2, 4, 5, 8}, { 0, 3, 6, 8, 1, 2, 4, 5, 7},
  { 0, 3, 7, 8, 1, 2, 4, 5, 6}, { 0, 4, 5, 6, 1, 2, 3, 7, 8}, { 0, 4, 5, 7, 1, 2, 3, 6, 8},
  { 0, 4, 5, 8, 1, 2, 3, 6, 7}, { 0, 4, 6, 7, 1, 2, 3, 5, 8}, { 0, 4, 6, 8, 1, 2, 3, 5, 7},
  { 0, 4, 7, 8, 1, 2, 3, 5, 6}, { 0, 5, 6, 7, 1, 2, 3, 4, 8}, { 0, 5, 6, 8, 1, 2, 3, 4, 7},
  { 0, 5, 7, 8, 1, 2, 3, 4, 6}, { 0, 6, 7, 8, 1, 2, 3, 4, 5}, { 1, 2, 3, 4, 0, 5, 6, 7, 8},
  { 1, 2, 3, 5, 0, 4, 6, 7, 8}, { 1, 2, 3, 6, 0, 4, 5, 7, 8}, { 1, 2, 3, 7, 0, 4, 5, 6, 8},
  { 1, 2, 3, 8, 0, 4, 5, 6, 7}, { 1, 2, 4, 5, 0, 3, 6, 7, 8}, { 1, 2, 4, 6, 0, 3, 5, 7, 8},
  { 1, 2, 4, 7, 0, 3, 5, 6, 8}, { 1, 2, 4, 8, 0, 3, 5, 6, 7}, { 1, 2, 5, 6, 0, 3, 4, 7, 8},
  { 1, 2, 5, 7, 0, 3, 4, 6, 8}, { 1, 2, 5, 8, 0, 3, 4, 6, 7}, { 1, 2, 6, 7, 0, 3, 4, 5, 8},
  { 1, 2, 6, 8, 0, 3, 4, 5, 7}, { 1, 2, 7, 8, 0, 3, 4, 5, 6}, { 1, 3, 4, 5, 0, 2, 6, 7, 8},
  { 1, 3, 4, 6, 0, 2, 5, 7, 8}, { 1, 3, 4, 7, 0, 2, 5, 6, 8}, { 1, 3, 4, 8, 0, 2, 5, 6, 7},
  { 1, 3, 5, 6, 0, 2, 4, 7, 8}, { 1, 3, 5, 7, 0, 2, 4, 6, 8}, { 1, 3, 5, 8, 0, 2, 4, 6, 7},
  { 1, 3, 6, 7, 0, 2, 4, 5, 8}, { 1, 3, 6, 8, 0, 2, 4, 5, 7}, { 1, 3, 7, 8, 0, 2, 4, 5, 6},
  { 1, 4, 5, 6, 0, 2, 3, 7, 8}, { 1, 4, 5, 7, 0, 2, 3, 6, 8}, { 1, 4, 5, 8, 0, 2, 3, 6, 7},
  { 1, 4, 6, 7, 0, 2, 3, 5, 8}, { 1, 4, 6, 8, 0, 2, 3, 5, 7}, { 1, 4, 7, 8, 0, 2, 3, 5, 6},
  { 1, 5, 6, 7, 0, 2, 3, 4, 8}, { 1, 5, 6, 8, 0, 2, 3, 4, 7}, { 1, 5, 7, 8, 0, 2, 3, 4, 6},
  { 1, 6, 7, 8, 0, 2, 3, 4, 5}, { 2, 3, 4, 5, 0, 1, 6, 7, 8}, { 2, 3, 4, 6, 0, 1, 5, 7, 8},
  { 2, 3, 4, 7, 0, 1, 5, 6, 8}, { 2, 3, 4, 8, 0, 1, 5, 6, 7}, { 2, 3, 5, 6, 0, 1, 4, 7, 8},
  { 2, 3, 5, 7, 0, 1, 4, 6, 8}, { 2, 3, 5, 8, 0, 1, 4, 6, 7}, { 2, 3, 6, 7, 0, 1, 4, 5, 8},
  { 2, 3, 6, 8, 0, 1, 4, 5, 7}, { 2, 3, 7, 8, 0, 1, 4, 5, 6}, { 2, 4, 5, 6, 0, 1, 3, 7, 8},
  { 2, 4, 5, 7, 0, 1, 3, 6, 8}, { 2, 4, 5, 8, 0, 1, 3, 6, 7}, { 2, 4, 6, 7, 0, 1, 3, 5, 8},
  { 2, 4, 6, 8, 0, 1, 3, 5, 7}, { 2, 4, 7, 8, 0, 1, 3, 5, 6}, { 2, 5, 6, 7, 0, 1, 3, 4, 8},
  { 2, 5, 6, 8, 0, 1, 3, 4, 7}, { 2, 5, 7, 8, 0, 1, 3, 4, 6}, { 2, 6, 7, 8, 0, 1, 3, 4, 5},
  { 3, 4, 5, 6, 0, 1, 2, 7, 8}, { 3, 4, 5, 7, 0, 1, 2, 6, 8}, { 3, 4, 5, 8, 0, 1, 2, 6, 7},
  { 3, 4, 6, 7, 0, 1, 2, 5, 8}, { 3, 4, 6, 8, 0, 1, 2, 5, 7}, { 3, 4, 7, 8, 0, 1, 2, 5, 6},
  { 3, 5, 6, 7, 0, 1, 2, 4, 8}, { 3, 5, 6, 8, 0, 1, 2, 4, 7}, { 3, 5, 7, 8, 0, 1, 2, 4, 6},
  { 3, 6, 7, 8, 0, 1, 2, 4, 5}, { 4, 5, 6, 7, 0, 1, 2, 3, 8}, { 4, 5, 6, 8, 0, 1, 2, 3, 7},
  { 4, 5, 7, 8, 0, 1, 2, 3, 6}, { 4, 6, 7, 8, 0, 1, 2, 3, 5}, { 5, 6, 7, 8, 0, 1, 2, 3, 4}},
           j[54][15] = {     // 3 Box-Line Intersection Cell positions and peer 6 Line + 6 Box Cell positions for 54 Box-Line
  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,18,19,20},
  { 3, 4, 5, 0, 1, 2, 6, 7, 8,12,13,14,21,22,23},
  { 6, 7, 8, 0, 1, 2, 3, 4, 5,15,16,17,24,25,26},
  { 9,10,11,12,13,14,15,16,17, 0, 1, 2,18,19,20},
  {12,13,14, 9,10,11,15,16,17, 3, 4, 5,21,22,23},
  {15,16,17, 9,10,11,12,13,14, 6, 7, 8,24,25,26},
  {18,19,20,21,22,23,24,25,26, 0, 1, 2, 9,10,11},
  {21,22,23,18,19,20,24,25,26, 3, 4, 5,12,13,14},
  {24,25,26,18,19,20,21,22,23, 6, 7, 8,15,16,17},
  {27,28,29,30,31,32,33,34,35,36,37,38,45,46,47},
  {30,31,32,27,28,29,33,34,35,39,40,41,48,49,50},
  {33,34,35,27,28,29,30,31,32,42,43,44,51,52,53},
  {36,37,38,39,40,41,42,43,44,27,28,29,45,46,47},
  {39,40,41,36,37,38,42,43,44,30,31,32,48,49,50},
  {42,43,44,36,37,38,39,40,41,33,34,35,51,52,53},
  {45,46,47,48,49,50,51,52,53,27,28,29,36,37,38},
  {48,49,50,45,46,47,51,52,53,30,31,32,39,40,41},
  {51,52,53,45,46,47,48,49,50,33,34,35,42,43,44},
  {54,55,56,57,58,59,60,61,62,63,64,65,72,73,74},
  {57,58,59,54,55,56,60,61,62,66,67,68,75,76,77},
  {60,61,62,54,55,56,57,58,59,69,70,71,78,79,80},
  {63,64,65,66,67,68,69,70,71,54,55,56,72,73,74},
  {66,67,68,63,64,65,69,70,71,57,58,59,75,76,77},
  {69,70,71,63,64,65,66,67,68,60,61,62,78,79,80},
  {72,73,74,75,76,77,78,79,80,54,55,56,63,64,65},
  {75,76,77,72,73,74,78,79,80,57,58,59,66,67,68},
  {78,79,80,72,73,74,75,76,77,60,61,62,69,70,71},
  { 0, 9,18,27,36,45,54,63,72, 1, 2,10,11,19,20},
  {27,36,45, 0, 9,18,54,63,72,28,29,37,38,46,47},
  {54,63,72, 0, 9,18,27,36,45,55,56,64,65,73,74},
  { 1,10,19,28,37,46,55,64,73, 0, 2, 9,11,18,20},
  {28,37,46, 1,10,19,55,64,73,27,29,36,38,45,47},
  {55,64,73, 1,10,19,28,37,46,54,56,63,65,72,74},
  { 2,11,20,29,38,47,56,65,74, 0, 1, 9,10,18,19},
  {29,38,47, 2,11,20,56,65,74,27,28,36,37,45,46},
  {56,65,74, 2,11,20,29,38,47,54,55,63,64,72,73},
  { 3,12,21,30,39,48,57,66,75, 4, 5,13,14,22,23},
  {30,39,48, 3,12,21,57,66,75,31,32,40,41,49,50},
  {57,66,75, 3,12,21,30,39,48,58,59,67,68,76,77},
  { 4,13,22,31,40,49,58,67,76, 3, 5,12,14,21,23},
  {31,40,49, 4,13,22,58,67,76,30,32,39,41,48,50},
  {58,67,76, 4,13,22,31,40,49,57,59,66,68,75,77},
  { 5,14,23,32,41,50,59,68,77, 3, 4,12,13,21,22},
  {32,41,50, 5,14,23,59,68,77,30,31,39,40,48,49},
  {59,68,77, 5,14,23,32,41,50,57,58,66,67,75,76},
  { 6,15,24,33,42,51,60,69,78, 7, 8,16,17,25,26},
  {33,42,51, 6,15,24,60,69,78,34,35,43,44,52,53},
  {60,69,78, 6,15,24,33,42,51,61,62,70,71,79,80},
  { 7,16,25,34,43,52,61,70,79, 6, 8,15,17,24,26},
  {34,43,52, 7,16,25,61,70,79,33,35,42,44,51,53},
  {61,70,79, 7,16,25,34,43,52,60,62,69,71,78,80},
  { 8,17,26,35,44,53,62,71,80, 6, 7,15,16,24,25},
  {35,44,53, 8,17,26,62,71,80,33,34,42,43,51,52},
  {62,71,80, 8,17,26,35,44,53,60,61,69,70,78,79}},
           W[17][2] = {      // References used for Basic, Hybrid and Transport Wings
  {14,12}, { 0,14}, { 6,20}, { 6,12}, { 7,13}, { 3,17},
  { 8, 6}, { 9, 8}, {12,10}, {10, 7}, {11, 9}, {13,11},
  { 8, 9}, {10,11}, { 1, 3}, {511,133955584}, { 0, 4}};

#if RJ > 3
void prn (void)
{
  int a = 0,
      k[9] = {1, 1, 1, 1, 1, 1, 1, 1, 1};

  for (; a < 81; ++a)
    if (k[a % 9] < B[g[a]])
      k[a % 9] = B[g[a]];
  printf (" +%.*s+%.*s+%.*s+\n",
    k[0] + k[1] + k[2] + 6, "---------------------------------",
    k[3] + k[4] + k[5] + 6, "---------------------------------",
    k[6] + k[7] + k[8] + 6, "---------------------------------");
  for (a = 0; a < 81; ++a)
  {
    printf ("%s%-*d", a % 3 ? "  " : " | ", k[a % 9], b[g[a] | s[a]]);
    if ((a % 9) & 8)
    {
      printf (" |\n");
      if (a % 27 == 26)
        printf (" +%.*s+%.*s+%.*s+\n",
          k[0] + k[1] + k[2] + 6, "---------------------------------",
          k[3] + k[4] + k[5] + 6, "---------------------------------",
          k[6] + k[7] + k[8] + 6, "---------------------------------");
    }
  }
}
#endif

int solve (int p)
{
  int a,
      Y,
      Z,
      x,                     // Unsolved Cell position for least Cell Values checking
      y = 0,                 // 0 Represent Naked single Cell position
      z = 512;               // 512 Represent greatest Cell Value for 1st time least Cell Values checking

#if RJ > 3
  prn ();
#endif
  for (; y < 27; ++y)        // Check zero state Unit wise
    if (!s[l[y][0]] + !s[l[y][1]] + !s[l[y][2]] + !s[l[y][3]] +
      !s[l[y][4]] + !s[l[y][5]] + !s[l[y][6]] + !s[l[y][7]] + !s[l[y][8]] !=
      B[g[l[y][0]] | g[l[y][1]] | g[l[y][2]] | g[l[y][3]] | g[l[y][4]] |
      g[l[y][5]] | g[l[y][6]] | g[l[y][7]] | g[l[y][8]]])
    {
#if RJ > 2
      printf ("%d) Zero state: %d @ %s %d\n",
        p, b[511 - (s[l[y][0]] | s[l[y][1]] | s[l[y][2]] | s[l[y][3]] | s[l[y][4]] |
        s[l[y][5]] | s[l[y][6]] | s[l[y][7]] | s[l[y][8]] |
        g[l[y][0]] | g[l[y][1]] | g[l[y][2]] | g[l[y][3]] | g[l[y][4]] |
        g[l[y][5]] | g[l[y][6]] | g[l[y][7]] | g[l[y][8]])], RCB, y % 9 + 1);
#endif
      return 0;              // Return for number of unsolved Cell positions not equal to number of unsolved Cell Values
    }
  for (a = p; a < q; ++a)    // Search Hidden single Cell Value unsolved Cell positions wise
  {
    Y = (((g[w[r[a]][0]] | g[w[r[a]][1]] | g[w[r[a]][2]] | g[w[r[a]][3]] |
      g[w[r[a]][4]] | g[w[r[a]][5]] | g[w[r[a]][6]] | g[w[r[a]][7]]) ^ g[r[a]]) |
      ((g[w[r[a]][6]] | g[w[r[a]][7]] | g[w[r[a]][8]] | g[w[r[a]][9]] |
      g[w[r[a]][10]] | g[w[r[a]][11]] | g[w[r[a]][12]] | g[w[r[a]][13]]) ^ g[r[a]]) |
      ((g[w[r[a]][12]] | g[w[r[a]][13]] | g[w[r[a]][14]] | g[w[r[a]][15]] |
      g[w[r[a]][16]] | g[w[r[a]][17]] | g[w[r[a]][18]] | g[w[r[a]][19]]) ^ g[r[a]])) & g[r[a]];
                             // Assign Hidden single Cell Value
    if (!Y)
      continue;              // Skip for no Hidden single Cell Value in unsolved Cell position
    x = a;                   // Assign Hidden single Cell position
    z = Y;                   // Assign Hidden single Cell Value
    y = B[g[r[a]]] > 1;      // 1 Represent Hidden single Cell position
    goto NHSCF;
  }
  for (y = 0, a = p; a < q; ++a)
                             // Search Naked single Cell Value or Guess minimum Cell Values unsolved Cell positions wise
    if (B[z] > B[g[r[a]]])   // Check least Cell Values in current unsolved Cell position
      if (B[z = g[r[x = a]]] < 2)
        goto NHSCF;          // Naked single Cell Value in current unsolved Cell position
  for (; y < 27; ++y)        // Search Naked/Hidden Tuples Cell Values Unit wise
  {
    Y = !g[l[y][0]] + !g[l[y][1]] + !g[l[y][2]] + !g[l[y][3]] +
      !g[l[y][4]] + !g[l[y][5]] + !g[l[y][6]] + !g[l[y][7]] + !g[l[y][8]];
                             // Count Unit solved Cell positions
    if (Y > 6)
      continue;              // Skip Unit for > 6 solved Cell positions
    for (a = 0; a < 36; ++a) // Search Naked/Hidden pair Cell Values Unit 36 pair Cell positions wise
    {
      if (!g[l[y][h[a][0]]] || !g[l[y][h[a][1]]])
      {                      // Skip for no unsolved Cell positions
        if (!g[l[y][h[a][0]]])
          a += 7 - h[a][0];
        continue;
      }
      int K[2] = {g[l[y][h[a][0]]] | g[l[y][h[a][1]]], g[l[y][h[a][2]]] |
                 g[l[y][h[a][3]]] | g[l[y][h[a][4]]] | g[l[y][h[a][5]]] |
                 g[l[y][h[a][6]]] | g[l[y][h[a][7]]] | g[l[y][h[a][8]]]};
                             // Assign Cell Values in Unit pair Cell positions and Unit other Cell positions
      if (B[K[0]] == 2)      // Check Naked pair Cell Values in Unit pair Cell positions
      {
        if (!(K[0] & K[1]))
          continue;          // Skip for no Naked pair Cell Values in Unit other Cell positions
        int k[7] = {g[l[y][h[a][2]]], g[l[y][h[a][3]]], g[l[y][h[a][4]]],
                   g[l[y][h[a][5]]], g[l[y][h[a][6]]], g[l[y][h[a][7]]], g[l[y][h[a][8]]]};
                             // Backup and drop Naked pair Cell Values from Unit other Cell positions
        g[l[y][h[a][2]]] &= ~K[0];
        g[l[y][h[a][3]]] &= ~K[0];
        g[l[y][h[a][4]]] &= ~K[0];
        g[l[y][h[a][5]]] &= ~K[0];
        g[l[y][h[a][6]]] &= ~K[0];
        g[l[y][h[a][7]]] &= ~K[0];
        g[l[y][h[a][8]]] &= ~K[0];
#if RJ > 2
        printf ("%d) Naked pair: %s %d %d @ %s %s => -%d @ %s %s %s %s %s %s %s\n",
          p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], b[K[0]], S[l[y][h[a][2]]],
          S[l[y][h[a][3]]], S[l[y][h[a][4]]], S[l[y][h[a][5]]], S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
        if (solve (p))
          return 1;
#if RJ > 2
        printf ("%d) Undo Naked pair: %s %d %d @ %s %s <= +%d @ %s %s %s %s %s %s %s\n",
          p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], b[K[0]], S[l[y][h[a][2]]],
          S[l[y][h[a][3]]], S[l[y][h[a][4]]], S[l[y][h[a][5]]], S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
        g[l[y][h[a][2]]] = k[0];
        g[l[y][h[a][3]]] = k[1];
        g[l[y][h[a][4]]] = k[2];
        g[l[y][h[a][5]]] = k[3];
        g[l[y][h[a][6]]] = k[4];
        g[l[y][h[a][7]]] = k[5];
        g[l[y][h[a][8]]] = k[6];
#if RJ > 3
        prn ();
#endif
        return 0;            // Undo Naked pair Cell Values to Unit other Cell positions
      }
      if (B[K[0] &= K[0] ^ K[1]] != 2)
        continue;            // Skip for no Hidden pair Cell Values in Unit pair Cell positions
      int k[2] = {g[l[y][h[a][0]]], g[l[y][h[a][1]]]};
                             // Backup and drop other than Hidden pair Cell Values from Unit pair Cell positions
      g[l[y][h[a][0]]] &= K[0];
      g[l[y][h[a][1]]] &= K[0];
#if RJ > 2
      printf ("%d) Hidden pair: %s %d %d @ %s %s\n",
        p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]]);
#endif
      if (solve (p))
        return 1;
#if RJ > 2
      printf ("%d) Undo Hidden pair: %s %d %d @ %s %s\n",
        p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]]);
#endif
      g[l[y][h[a][0]]] = k[0];
      g[l[y][h[a][1]]] = k[1];
#if RJ > 3
      prn ();
#endif
      return 0;              // Undo other than Hidden pair Cell Values to Unit pair Cell positions
    }
    if (Y > 4)
      continue;              // Skip triplets and quads for > 4 solved Cell positions
    for (; a < 120; ++a)     // Search Naked/Hidden triplet Cell Values Unit 84 triplet Cell positions wise
    {
      if (!g[l[y][h[a][0]]] || !g[l[y][h[a][1]]] || !g[l[y][h[a][2]]])
      {                      // Skip for no unsolved Cell positions
        if (!g[l[y][h[a][0]]])
        {
          int A[7] = {27,20,14, 9, 5, 2, 0};

          a += A[h[a][0]];
        }
        else if (!g[l[y][h[a][1]]])
          a += 7 - h[a][1];
        continue;
      }
      int K[2] = {g[l[y][h[a][0]]] | g[l[y][h[a][1]]] | g[l[y][h[a][2]]],
                 g[l[y][h[a][3]]] | g[l[y][h[a][4]]] | g[l[y][h[a][5]]] |
                 g[l[y][h[a][6]]] | g[l[y][h[a][7]]] | g[l[y][h[a][8]]]};
                             // Assign Cell Values in Unit triplet Cell positions and Unit other Cell positions
      if (B[K[0]] == 3)      // Check Naked triplet Cell Values in Unit triplet Cell positions
      {
        if (!(K[0] & K[1]))
          continue;          // Skip for no Naked triplet Cell Values in Unit other Cell positions
        int k[6] = {g[l[y][h[a][3]]], g[l[y][h[a][4]]], g[l[y][h[a][5]]],
                   g[l[y][h[a][6]]], g[l[y][h[a][7]]], g[l[y][h[a][8]]]};
                             // Backup and drop Naked triplet Cell Values from Unit other Cell positions
        g[l[y][h[a][3]]] &= ~K[0];
        g[l[y][h[a][4]]] &= ~K[0];
        g[l[y][h[a][5]]] &= ~K[0];
        g[l[y][h[a][6]]] &= ~K[0];
        g[l[y][h[a][7]]] &= ~K[0];
        g[l[y][h[a][8]]] &= ~K[0];
#if RJ > 2
        printf ("%d) Naked triplet: %s %d %d @ %s %s %s => -%d @ %s %s %s %s %s %s\n",
          p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]],
          S[l[y][h[a][2]]], b[K[0]], S[l[y][h[a][3]]], S[l[y][h[a][4]]],
          S[l[y][h[a][5]]], S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
        if (solve (p))
          return 1;
#if RJ > 2
        printf ("%d) Undo Naked triplet: %s %d %d @ %s %s %s <= +%d @ %s %s %s %s %s %s\n",
          p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]],
          S[l[y][h[a][2]]], b[K[0]], S[l[y][h[a][3]]], S[l[y][h[a][4]]],
          S[l[y][h[a][5]]], S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
        g[l[y][h[a][3]]] = k[0];
        g[l[y][h[a][4]]] = k[1];
        g[l[y][h[a][5]]] = k[2];
        g[l[y][h[a][6]]] = k[3];
        g[l[y][h[a][7]]] = k[4];
        g[l[y][h[a][8]]] = k[5];
#if RJ > 3
        prn ();
#endif
        return 0;            // Undo Naked triplet Cell Values to Unit other Cell positions
      }
      if (B[K[0] &= K[0] ^ K[1]] != 3)
        continue;            // Skip for no Hidden triplet Cell Values in Unit triplet Cell positions
      int k[3] = {g[l[y][h[a][0]]], g[l[y][h[a][1]]], g[l[y][h[a][2]]]};
                             // Backup and drop other than Hidden triplet Cell Values from Unit triplet Cell positions
      g[l[y][h[a][0]]] &= K[0];
      g[l[y][h[a][1]]] &= K[0];
      g[l[y][h[a][2]]] &= K[0];
#if RJ > 2
      printf ("%d) Hidden triplet: %s %d %d @ %s %s %s\n",
        p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], S[l[y][h[a][2]]]);
#endif
      if (solve (p))
        return 1;
#if RJ > 2
      printf ("%d) Undo Hidden triplet: %s %d %d @ %s %s %s\n",
        p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], S[l[y][h[a][2]]]);
#endif
      g[l[y][h[a][0]]] = k[0];
      g[l[y][h[a][1]]] = k[1];
      g[l[y][h[a][2]]] = k[2];
#if RJ > 3
      prn ();
#endif
      return 0;              // Undo other than Hidden triplet Cell Values to Unit triplet Cell positions
    }
    if (Y > 2)
      continue;              // Skip quads for > 2 solved Cell positions
    for (; a < 246; ++a)     // Search Naked/Hidden quad Cell Values Unit 126 quad Cell positions wise
    {
      if (!g[l[y][h[a][0]]] || !g[l[y][h[a][1]]] || !g[l[y][h[a][2]]] || !g[l[y][h[a][3]]])
      {                      // Skip for no unsolved Cell positions
        if (!g[l[y][h[a][0]]])
        {
          int A[6] = {55,34,19, 9, 3, 0};

          a += A[h[a][0]];
        }
        else if (!g[l[y][h[a][1]]])
        {
          int A[7] = {27,20,14, 9, 5, 2, 0};

          a += A[h[a][1]];
        }
        else if (!g[l[y][h[a][2]]])
          a += 7 - h[a][2];
        continue;
      }
      int K[2] = {g[l[y][h[a][0]]] | g[l[y][h[a][1]]] | g[l[y][h[a][2]]] |
                 g[l[y][h[a][3]]], g[l[y][h[a][4]]] | g[l[y][h[a][5]]] |
                 g[l[y][h[a][6]]] | g[l[y][h[a][7]]] | g[l[y][h[a][8]]]};
                             // Assign Cell Values in Unit quad Cell positions and Unit other Cell positions
      if (B[K[0]] == 4)      // Check Naked quad Cell Values in Unit quad Cell positions
      {
        if (!(K[0] & K[1]))
          continue;          // Skip for no Naked quad Cell Values in Unit other Cell positions
        int k[5] = {g[l[y][h[a][4]]], g[l[y][h[a][5]]], g[l[y][h[a][6]]],
                   g[l[y][h[a][7]]], g[l[y][h[a][8]]]};
                             // Backup and drop Naked quad Cell Values from Unit other Cell positions
        g[l[y][h[a][4]]] &= ~K[0];
        g[l[y][h[a][5]]] &= ~K[0];
        g[l[y][h[a][6]]] &= ~K[0];
        g[l[y][h[a][7]]] &= ~K[0];
        g[l[y][h[a][8]]] &= ~K[0];
#if RJ > 2
        printf ("%d) Naked quad: %s %d %d @ %s %s %s %s => -%d @ %s %s %s %s %s\n",
          p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], S[l[y][h[a][2]]], S[l[y][h[a][3]]],
          b[K[0]], S[l[y][h[a][4]]], S[l[y][h[a][5]]], S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
        if (solve (p))
          return 1;
#if RJ > 2
        printf ("%d) Undo Naked quad: %s %d %d @ %s %s %s %s <= +%d @ %s %s %s %s %s\n",
          p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], S[l[y][h[a][2]]], S[l[y][h[a][3]]],
          b[K[0]], S[l[y][h[a][4]]], S[l[y][h[a][5]]], S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
        g[l[y][h[a][4]]] = k[0];
        g[l[y][h[a][5]]] = k[1];
        g[l[y][h[a][6]]] = k[2];
        g[l[y][h[a][7]]] = k[3];
        g[l[y][h[a][8]]] = k[4];
#if RJ > 3
        prn ();
#endif
        return 0;            // Undo Naked quad Cell Values to Unit other Cell positions
      }
      if (B[K[0] &= K[0] ^ K[1]] != 4)
        continue;            // Skip for no Hidden quad Cell Values in Unit quad Cell positions
      int k[4] = {g[l[y][h[a][0]]], g[l[y][h[a][1]]], g[l[y][h[a][2]]], g[l[y][h[a][3]]]};
                             // Backup and drop other than Hidden quad Cell Values from Unit quad Cell positions
      g[l[y][h[a][0]]] &= K[0];
      g[l[y][h[a][1]]] &= K[0];
      g[l[y][h[a][2]]] &= K[0];
      g[l[y][h[a][3]]] &= K[0];
#if RJ > 2
      printf ("%d) Hidden quad: %s %d %d @ %s %s %s %s\n",
        p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], S[l[y][h[a][2]]], S[l[y][h[a][3]]]);
#endif
      if (solve (p))
        return 1;
#if RJ > 2
      printf ("%d) Undo Hidden quad: %s %d %d @ %s %s %s %s\n",
        p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], S[l[y][h[a][2]]], S[l[y][h[a][3]]]);
#endif
      g[l[y][h[a][0]]] = k[0];
      g[l[y][h[a][1]]] = k[1];
      g[l[y][h[a][2]]] = k[2];
      g[l[y][h[a][3]]] = k[3];
#if RJ > 3
      prn ();
#endif
      return 0;              // Undo other than Hidden quad Cell Values to Unit quad Cell positions
    }
  }
  for (a = 0; a < 54; ++a)   // Search Locked Value for 54 Box-Line 3 Cell positions
    for (Y = g[j[a][0]] | g[j[a][1]] | g[j[a][2]]; y = Y & -Y; Y -= y)
                             // Search Box-Line 3 Cell positions Locked Value wise
      if ((Z = (g[j[a][3]] | g[j[a][4]] | g[j[a][5]] | g[j[a][6]] | g[j[a][7]] | g[j[a][8]]) & y) !=
                             // Check Locked Value in either Line other Cell positions; or
        ((g[j[a][9]] | g[j[a][10]] | g[j[a][11]] | g[j[a][12]] | g[j[a][13]] | g[j[a][14]]) & y))
      {                      // Locked Value in Box other Cell positions
        int k[6] = {g[j[a][Z ? 3 : 9]], g[j[a][Z ? 4 : 10]], g[j[a][Z ? 5 : 11]],
                   g[j[a][Z ? 6 : 12]], g[j[a][Z ? 7 : 13]], g[j[a][Z ? 8 : 14]]};
                             // Backup and drop Locked Value from Line / Box other Cell positions
        g[j[a][Z ? 3 : 9]] &= ~y;
        g[j[a][Z ? 4 : 10]] &= ~y;
        g[j[a][Z ? 5 : 11]] &= ~y;
        g[j[a][Z ? 6 : 12]] &= ~y;
        g[j[a][Z ? 7 : 13]] &= ~y;
        g[j[a][Z ? 8 : 14]] &= ~y;
#if RJ > 2
        printf ("%d) Locked candidate Type %sing): %d @ r%dc%d => -%d @ r%dc%d\n",
          p, Z ? "1 (Point" : "2 (Claim", b[y],
          b[((w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]) >> 18) & 511],
          b[(w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]) & 511], b[y],
          b[((w[j[a][Z ? 3 : 9]][20] | w[j[a][Z ? 4 : 10]][20] | w[j[a][Z ? 5 : 11]][20] |
          w[j[a][Z ? 6 : 12]][20] | w[j[a][Z ? 7 : 13]][20] | w[j[a][Z ? 8 : 14]][20]) >> 18) & 511],
          b[(w[j[a][Z ? 3 : 9]][20] | w[j[a][Z ? 4 : 10]][20] | w[j[a][Z ? 5 : 11]][20] |
          w[j[a][Z ? 6 : 12]][20] | w[j[a][Z ? 7 : 13]][20] | w[j[a][Z ? 8 : 14]][20]) & 511]);
#endif
        if (solve (p))
          return 1;
#if RJ > 2
        printf ("%d) Undo Locked candidate Type %sing): %d @ r%dc%d => -%d @ r%dc%d\n",
          p, Z ? "1 (Point" : "2 (Claim", b[y],
          b[((w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]) >> 18) & 511],
          b[(w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]) & 511], b[y],
          b[((w[j[a][Z ? 3 : 9]][20] | w[j[a][Z ? 4 : 10]][20] | w[j[a][Z ? 5 : 11]][20] |
          w[j[a][Z ? 6 : 12]][20] | w[j[a][Z ? 7 : 13]][20] | w[j[a][Z ? 8 : 14]][20]) >> 18) & 511],
          b[(w[j[a][Z ? 3 : 9]][20] | w[j[a][Z ? 4 : 10]][20] | w[j[a][Z ? 5 : 11]][20] |
          w[j[a][Z ? 6 : 12]][20] | w[j[a][Z ? 7 : 13]][20] | w[j[a][Z ? 8 : 14]][20]) & 511]);
#endif
        g[j[a][Z ? 3 : 9]] = k[0];
        g[j[a][Z ? 4 : 10]] = k[1];
        g[j[a][Z ? 5 : 11]] = k[2];
        g[j[a][Z ? 6 : 12]] = k[3];
        g[j[a][Z ? 7 : 13]] = k[4];
        g[j[a][Z ? 8 : 14]] = k[5];
#if RJ > 3
        prn ();
#endif
        return 0;            // Undo Locked Value to Line other Cell positions
      }
  for (y = 0; y < 10; y += 9)// Search Basic Fishes Line wise
    for (Y = 1; Y < 257; Y <<= 1)
    {                        // Search Basic Fishes digit wise
      int k[9];              // Backup Basic Fish Value Line Cell positions wise

      for (a = y; a < y + 9; ++a)
        k[a - y] = (g[l[a][0]] & Y ? 1 : 0) | (g[l[a][1]] & Y ? 2 : 0) |
          (g[l[a][2]] & Y ? 4 : 0) | (g[l[a][3]] & Y ? 8 : 0) |
          (g[l[a][4]] & Y ? 16 : 0) | (g[l[a][5]] & Y ? 32 : 0) |
          (g[l[a][6]] & Y ? 64 : 0) | (g[l[a][7]] & Y ? 128 : 0) |
          (g[l[a][8]] & Y ? 256 : 0);
      for (a = 0; a < 36; ++a)
      {                      // Search X-Wing Value for Line 36 pair Cell positions
        int X = k[h[a][0]],
            K[2],
            A[2] = {-1,-1};

        if (B[X] != 2 || X != k[h[a][1]])
        {                    // Skip for no X-Wing Value in Lines pair Cell positions
          if (B[X] != 2)
            a += 7 - h[a][0];
          continue;
        }
        for (Z = -1; K[++Z] = X & -X; X -= K[Z])
        {                    // Search opposite Line other Cell positions for X-Wing Value
          if (~(k[h[a][2]] | k[h[a][3]] | k[h[a][4]] | k[h[a][5]] | k[h[a][6]] |
            k[h[a][7]] | k[h[a][8]]) & K[Z])
            continue;        // Skip for no X-Wing Value in opposite Line other Cell positions
          A[Z] = b[K[Z]] - y + 8;
          g[l[A[Z]][h[a][2]]] &= ~Y;
          g[l[A[Z]][h[a][3]]] &= ~Y;
          g[l[A[Z]][h[a][4]]] &= ~Y;
          g[l[A[Z]][h[a][5]]] &= ~Y;
          g[l[A[Z]][h[a][6]]] &= ~Y;
          g[l[A[Z]][h[a][7]]] &= ~Y;
          g[l[A[Z]][h[a][8]]] &= ~Y;
        }                    // Drop X-Wing Value from opposite Line other Cell positions
        if ((A[0] & A[1]) < 0)
          continue;          // Skip for no X-Wing Value in opposite Lines other Cell positions
#if RJ > 2
        printf ("%d) %s wise X-Wing: %d @ r%d%dc%d%d\n",
          p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
          y ? h[a][0] + 1 : b[K[0]], y ? h[a][1] + 1 : b[K[1]]);
#endif
        if (solve (p))
          return 1;
#if RJ > 2
        printf ("%d) Undo %s wise X-Wing: %d @ r%d%dc%d%d\n",
          p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
          y ? h[a][0] + 1 : b[K[0]], y ? h[a][1] + 1 : b[K[1]]);
#endif
        for (Z = 0; Z < 2; ++Z)
        {
          if (A[Z] < 0)
            continue;        // Skip for no X-Wing Value in opposite Line other Cell positions
          g[l[A[Z]][h[a][2]]] |= k[h[a][2]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][3]]] |= k[h[a][3]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][4]]] |= k[h[a][4]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][5]]] |= k[h[a][5]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][6]]] |= k[h[a][6]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][7]]] |= k[h[a][7]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][8]]] |= k[h[a][8]] & K[Z] ? Y : 0;
        }
#if RJ > 3
        prn ();
#endif
        return 0;            // Undo X-Wing Value to opposite Lines other Cell positions
      }
      for (; a < 120; ++a)   // Search Sword Fish Value in Line 84 triplet Cell positions
      {
        int X = k[h[a][0]] | k[h[a][1]] | k[h[a][2]],
            K[3],
            A[3] = {-1,-1,-1};

        if (!k[h[a][0]] || !k[h[a][1]] || !k[h[a][2]] || B[X] != 3)
        {                    // Skip for either no unsolved Cell positions; or no Sord Fish Value in Lines triplet Cell positions
          if (!k[h[a][0]] || B[k[h[a][0]]] > 3)
          {
            int A[7] = {27,20,14, 9, 5, 2, 0};

            a += A[h[a][0]];
          }
          else if (!k[h[a][1]] || B[k[h[a][1]]] > 3)
            a += 7 - h[a][1];
          continue;
        }
        for (Z = -1; K[++Z] = X & -X; X -= K[Z])
        {                    // Search opposite Line other Cell positions for Sword Fish Value
          if (~(k[h[a][3]] | k[h[a][4]] | k[h[a][5]] | k[h[a][6]] | k[h[a][7]] |
            k[h[a][8]]) & K[Z])
            continue;        // Skip for no Sword Fish Value in opposite Line other Cell positions
          A[Z] = b[K[Z]] - y + 8;
          g[l[A[Z]][h[a][3]]] &= ~Y;
          g[l[A[Z]][h[a][4]]] &= ~Y;
          g[l[A[Z]][h[a][5]]] &= ~Y;
          g[l[A[Z]][h[a][6]]] &= ~Y;
          g[l[A[Z]][h[a][7]]] &= ~Y;
          g[l[A[Z]][h[a][8]]] &= ~Y;
        }                    // Drop Sword Fish Value from opposite Line other Cell positions
        if ((A[0] & A[1] & A[2]) < 0)
          continue;          // Skip for no Sword Fish Value in opposite Lines other Cell positions
#if RJ > 2
        printf ("%d) %s wise Sword Fish: %d @ r%d%d%dc%d%d%d\n",
          p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
          y ? b[K[2]] : h[a][2] + 1, y ? h[a][0] + 1 : b[K[0]],
          y ? h[a][1] + 1 : b[K[1]], y ? h[a][2] + 1 : b[K[2]]);
#endif
        if (solve (p))
          return 1;
#if RJ > 2
        printf ("%d) Undo %s wise Sword Fish: %d @ r%d%d%dc%d%d%d\n",
          p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
          y ? b[K[2]] : h[a][2] + 1, y ? h[a][0] + 1 : b[K[0]],
          y ? h[a][1] + 1 : b[K[1]], y ? h[a][2] + 1 : b[K[2]]);
#endif
        for (Z = 0; Z < 3; ++Z)
        {
          if (A[Z] < 0)
            continue;        // Skip for no Sword Fish Value in opposite Line other Cell positions
          g[l[A[Z]][h[a][3]]] |= k[h[a][3]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][4]]] |= k[h[a][4]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][5]]] |= k[h[a][5]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][6]]] |= k[h[a][6]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][7]]] |= k[h[a][7]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][8]]] |= k[h[a][8]] & K[Z] ? Y : 0;
        }
#if RJ > 3
        prn ();
#endif
        return 0;            // Undo Sword Fish Value to opposite Lines other Cell positions
      }
      for (; a < 246; ++a)   // Search Jelly Fish Value in Line 126 quad Cell positions
      {
        int X = k[h[a][0]] | k[h[a][1]] | k[h[a][2]] | k[h[a][3]],
            K[4],
            A[4] = {-1,-1,-1,-1};

        if (!k[h[a][0]] || !k[h[a][1]] || !k[h[a][2]] || !k[h[a][3]] || B[X] != 4)
        {                    // Skip for either no unsolved Cell positions; or no Jelly Fish Value in Line quad Cell positions
          if (!k[h[a][0]] || B[k[h[a][0]]] > 4)
          {
            int A[6] = {55,34,19, 9, 3, 0};

            a += A[h[a][0]];
          }
          else if (!k[h[a][1]] || B[k[h[a][1]]] > 4)
          {
            int A[7] = {27,20,14, 9, 5, 2, 0};

            a += A[h[a][1]];
          }
          else if (!k[h[a][2]] || B[k[h[a][2]]] > 4)
            a += 7 - h[a][2];
          continue;
        }
        for (Z = -1; K[++Z] = X & -X; X -= K[Z])
        {                    // Search opposite Line other Cell positions for Jelly Fish Value
          if (~(k[h[a][4]] | k[h[a][5]] | k[h[a][6]] | k[h[a][7]] | k[h[a][8]]) & K[Z])
            continue;        // Skip for no Jelly Fish Value in opposite Line other Cell positions
          A[Z] = b[K[Z]] - y + 8;
          g[l[A[Z]][h[a][4]]] &= ~Y;
          g[l[A[Z]][h[a][5]]] &= ~Y;
          g[l[A[Z]][h[a][6]]] &= ~Y;
          g[l[A[Z]][h[a][7]]] &= ~Y;
          g[l[A[Z]][h[a][8]]] &= ~Y;
        }                    // Drop Jelly Fish Value from opposite Line other Cell positions
        if ((A[0] & A[1] & A[2] & A[3]) < 0)
          continue;          // Skip for no Jelly Fish Value in opposite Lines other Cell positions
#if RJ > 2
        printf ("%d) %s wise Jelly Fish: %d @ r%d%d%d%dc%d%d%d%d\n",
          p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
          y ? b[K[2]] : h[a][2] + 1, y ? b[K[3]] : h[a][3] + 1, y ? h[a][0] + 1 : b[K[0]],
          y ? h[a][1] + 1 : b[K[1]], y ? h[a][2] + 1 : b[K[2]], y ? h[a][3] + 1 : b[K[3]]);
#endif
        if (solve (p))
          return 1;
#if RJ > 2
        printf ("%d) Undo %s wise Jelly Fish: %d @ r%d%d%d%dc%d%d%d%d\n",
          p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
          y ? b[K[2]] : h[a][2] + 1, y ? b[K[3]] : h[a][3] + 1, y ? h[a][0] + 1 : b[K[0]],
          y ? h[a][1] + 1 : b[K[1]], y ? h[a][2] + 1 : b[K[2]], y ? h[a][3] + 1 : b[K[3]]);
#endif
        for (Z = 0; Z < 4; ++Z)
        {
          if (A[Z] < 0)
            continue;        // Skip for no Jelly Fish Value in opposite Line other Cell positions
          g[l[A[Z]][h[a][4]]] |= k[h[a][4]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][5]]] |= k[h[a][5]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][6]]] |= k[h[a][6]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][7]]] |= k[h[a][7]] & K[Z] ? Y : 0;
          g[l[A[Z]][h[a][8]]] |= k[h[a][8]] & K[Z] ? Y : 0;
        }
#if RJ > 3
        prn ();
#endif
        return 0;            // Undo Jelly Fish Value to opposite Lines other Cell positions
      }
    }
  for (y = 0; y < 10; y += 9)// Search Skyscraper and Grouped Skyscraper Line wise
    for (Y = 1; Y < 257; Y <<= 1)
                             // Search Skyscraper and Grouped Skyscraper digit wise
      for (a = y; a < y + 6; ++a)
      {                      // Search 1st SL within 1st and 2nd chutes
        int A[7] = {0};      // 1st and 2nd SL Base and Cover Cell positions; and check for Grouped Cover Cell positions

        if ((A[6] = !(g[l[a][0]] & Y) + !(g[l[a][1]] & Y) + !(g[l[a][2]] & Y)) == 2)
          A[0] = 1;          // Found 1st SL Base Cell position
        else if (A[6] < 2)
          A[0] = A[2] = 1;   // Found 1st SL Grouped Cover Cell positions
        if ((A[6] = !(g[l[a][3]] & Y) + !(g[l[a][4]] & Y) + !(g[l[a][5]] & Y)) == 2)
          A[A[0]] = 2;       // Found 1st SL either one Cover or Base Cell position
        else if (A[6] < 2)
        {                    // Found 1st SL Grouped Cover Cell positions
          if (A[2])
            continue;        // Skip for Grouped Cover Cell positions already found
          A[A[0]] = A[2] = 2;
        }
        if (!A[0])
          continue;          // Skip for no 1st SL Cell position
        if ((A[6] = !(g[l[a][6]] & Y) + !(g[l[a][7]] & Y) + !(g[l[a][8]] & Y)) == 2)
        {                    // Found 1st SL one Cover Cell position
          if (A[1])
            continue;        // Skip for 1st SL Base and Cover Cell positions already found
          A[1] = 4;
        }
        else if (A[6] < 2)
        {                    // Found 1st SL Grouped Cover Cell positions
          if (A[1] || A[2])
            continue;        // Skip for either 1st SL Base and Cover Cell positions already found; or Grouped Cover Cell positions already found
          A[1] = A[2] = 4;
        }
        if (!A[1])
          continue;          // Skip for no 1st SL Base and Cover Cell positions
        for (Z = y + (a < y + 3 ? 3 : 6); Z < y + 9; ++Z)
        {                    // Search 2nd SL within 2nd and 3rd chutes
          A[3] = A[4] = 0;
          A[5] = A[2];
          if ((A[6] = !(g[l[Z][0]] & Y) + !(g[l[Z][1]] & Y) + !(g[l[Z][2]] & Y)) == 2)
          {                  // Found 2nd SL Base Cell position
            if (~A[0] & 1)
              continue;      // Skip for 1st SL Cell positions not in 1st mini-Line
            A[3] = 1;
          }
          else if (A[6] < 2)
          {                  // Found 2nd SL Grouped Cover Cell positions
            if (A[5] || ~A[0] & 1)
              continue;      // Skip for either Grouped SL Cell positions already found; or 1st SL Cell position not in 1st mini-Line
            A[3] = A[5] = 1;
          }
          if ((A[6] = !(g[l[Z][3]] & Y) + !(g[l[Z][4]] & Y) + !(g[l[Z][5]] & Y)) == 2)
          {                  // Found 2nd SL either one Cover or Base Cell position
            if (~(A[0] | A[1]) & 2)
              continue;      // Skip for no 1st SL Cell positions in 2nd mini-Line
            A[3 + A[3]] = 2;
          }
          else if (A[6] < 2)
          {                  // Found 2nd SL Grouped Cover Cell positions
            if (A[5] || ~(A[0] | A[1]) & 2)
              continue;      // Skip for either Grouped Cover Cell positions already found; or 1st SL Cell positions not in 2nd mini-Line
            A[3 + A[3]] = A[5] = 2;
          }
          if (!A[3])
            continue;        // Skip for no 2nd SL Cell position
          if ((A[6] = !(g[l[Z][6]] & Y) + !(g[l[Z][7]] & Y) + !(g[l[Z][8]] & Y)) == 2)
          {                  // Found 2nd SL either one Cover or Base Cell position
            if (A[4] || ~A[1] & 4)
              continue;      // Skip for either 2nd SL Base and Cover Cell positions already found; or 1st SL Cover Cell positions not in 3rd mini-Line
            A[4] = 4;
          }
          else if (A[6] < 2)
          {                  // Found 2nd SL Grouped Cover Cell positions
            if (A[4] || A[5] || ~(A[0] | A[1]) & 4)
              continue;      // Skip for either 2nd SL Base and Cover Cell positions already found; or Grouped Cover Cell positions already found; or 1st SL Cover Cell positions not in 3rd mini-Line
            A[4] = A[5] = 4;
          }
          if (!A[4])
            continue;        // Skip for no 2nd SL Base and Cover Cell positions
          A[6] = 0;          // Base Cell positions
          if ((A[0] & 1) && (!(g[l[a][0]] & Y) | (!(g[l[a][1]] & Y) << 1) | (!(g[l[a][2]] & Y) << 2)) ==
            (!(g[l[Z][0]] & Y) | (!(g[l[Z][1]] & Y) << 1) | (!(g[l[Z][2]] & Y) << 2)))
            A[6] = 1;
          if (((A[0] | A[1]) & 2) && (!(g[l[a][3]] & Y) | (!(g[l[a][4]] & Y) << 1) | (!(g[l[a][5]] & Y) << 2)) ==
            (!(g[l[Z][3]] & Y) | (!(g[l[Z][4]] & Y) << 1) | (!(g[l[Z][5]] & Y) << 2)))
            A[6] |= 2;
          if ((A[1] & 4) && (!(g[l[a][6]] & Y) | (!(g[l[a][7]] & Y) << 1) | (!(g[l[a][8]] & Y) << 2)) ==
            (!(g[l[Z][6]] & Y) | (!(g[l[Z][7]] & Y) << 1) | (!(g[l[Z][8]] & Y) << 2)))
            A[6] |= 4;
          if (B[A[6]] != 1)
            continue;        // Skip for neither Skyscraper nor Grouped Skyscraper
          int K[12] = {-1,-1,-1,-1,
                      l[a][b[A[6]] * 3 - (g[l[a][b[A[6]] * 3 - 3]] & Y ? 3 : g[l[a][b[A[6]] * 3 - 2]] & Y ? 2 : 1)],
                      l[Z][b[A[6]] * 3 - (g[l[Z][b[A[6]] * 3 - 3]] & Y ? 3 : g[l[Z][b[A[6]] * 3 - 2]] & Y ? 2 : 1)]},
              k[4] = {0};    // Backup Skyscraper and Grouped Skyscraper exclusion Cell positions

          A[6] = b[A[A[0] == A[6]]] * 3;
                             // Cover Cell positions
          K[6] = g[l[a][A[6] - 3]] & Y ? l[a][A[6] - 3] : -1;
          K[7] = g[l[a][A[6] - 2]] & Y ? l[a][A[6] - 2] : -1;
          K[8] = g[l[a][A[6] - 1]] & Y ? l[a][A[6] - 1] : -1;
          K[9] = g[l[Z][A[6] - 3]] & Y ? l[Z][A[6] - 3] : -1;
          K[10] = g[l[Z][A[6] - 2]] & Y ? l[Z][A[6] - 2] : -1;
          K[11] = g[l[Z][A[6] - 1]] & Y ? l[Z][A[6] - 1] : -1;
          if (!A[2])
          {                  // Found 1st SL one Cover Cell position
            A[6] = K[K[6] + 1 ? 6 : K[7] + 1 ? 7 : 8] - K[4] + K[5];
            k[0] = g[K[0] = w[A[6]][W[3][!y]]];
            k[1] = g[K[1] = w[A[6]][W[4][!y]]];
          }
          if (A[2] || !A[5])
          {                  // Found 2nd SL one Cover Cell position
            A[6] = K[K[9] + 1 ? 9 : K[10] + 1 ? 10 : 11] - K[5] + K[4];
            k[2] = g[K[2] = w[A[6]][W[3][!y]]];
            k[3] = g[K[3] = w[A[6]][W[4][!y]]];
          }
          if (~(k[0] | k[1] | k[2] | k[3]) & Y)
            continue;        // Skip for no Skyscraper and Grouped Skyscraper digit in exclusion Cell positions
          if (!A[2])
          {
            g[K[0]] &= ~Y;
            g[K[1]] &= ~Y;
          }
          if (A[2] || !A[5])
          {
            g[K[2]] &= ~Y;
            g[K[3]] &= ~Y;
          }
#if RJ > 2
          printf ("%d)%sSkyscraper: %ss %d %d Base Cells %s %s Cover Cells",
            p, A[5] ? " Grouped " : " ", RCB, a - y + 1, Z - y + 1, S[K[4]], S[K[5]]);
          if (K[6] + 1)
            printf (" %s", S[K[6]]);
          if (K[7] + 1)
            printf (" %s", S[K[7]]);
          if (K[8] + 1)
            printf (" %s", S[K[8]]);
          if (K[9] + 1)
            printf (" %s", S[K[9]]);
          if (K[10] + 1)
            printf (" %s", S[K[10]]);
          if (K[11] + 1)
            printf (" %s", S[K[11]]);
          printf (" => -%d @", b[Y]);
          if (!A[2])
            printf (" %s %s", S[K[0]], S[K[1]]);
          if (A[2] || !A[5])
            printf (" %s %s", S[K[2]], S[K[3]]);
          printf ("\n");
#endif
          if (solve (p))
            return 1;
#if RJ > 2
          printf ("%d) Undo%sSkyscraper: %ss %d %d Base Cells %s %s Cover Cells",
            p, A[5] ? " Grouped " : " ", RCB, a - y + 1, Z - y + 1, S[K[4]], S[K[5]]);
          if (K[6] + 1)
            printf (" %s", S[K[6]]);
          if (K[7] + 1)
            printf (" %s", S[K[7]]);
          if (K[8] + 1)
            printf (" %s", S[K[8]]);
          if (K[9] + 1)
            printf (" %s", S[K[9]]);
          if (K[10] + 1)
            printf (" %s", S[K[10]]);
          if (K[11] + 1)
            printf (" %s", S[K[11]]);
          printf (" <= +%d @", b[Y]);
          if (!A[2])
            printf (" %s %s", S[K[0]], S[K[1]]);
          if (A[2] || !A[5])
            printf (" %s %s", S[K[2]], S[K[3]]);
          printf ("\n");
#endif
          if (!A[2])
          {
            g[K[0]] = k[0];
            g[K[1]] = k[1];
          }
          if (A[2] || !A[5])
          {
            g[K[2]] = k[2];
            g[K[3]] = k[3];
          }
#if RJ > 3
          prn ();
#endif
          return 0;          // Undo Skyscraper and Grouped Skyscraper digit to excluding Cell positions
        }
      }
  for (a = 0; a < 81; ++a)   // Search 2-String Kite and Grouped 2-String Kite Grid wise
  {
    if (!(y = ~g[a] & (g[w[a][6]] | g[w[a][7]]) & (g[w[a][12]] | g[w[a][13]])))
      continue;              // Skip for either digit in ERI Cell Values; or in mini-Row or mini-Column Cell Values
    int K[3];

    for (; Y = y & -y; y -= Y)
    {                        // Search 2-String Kite and Grouped 2-String Kite digit wise
      if (B[K[0] = !(g[w[a][0]] & Y) | (!(g[w[a][1]] & Y) << 1) | (!(g[w[a][2]] & Y) << 2) |
        (!(g[w[a][3]] & Y) << 3) | (!(g[w[a][4]] & Y) << 4) | (!(g[w[a][5]] & Y) << 5)] != 5 ||
        B[K[1] = !(g[w[a][14]] & Y) | (!(g[w[a][15]] & Y) << 1) | (!(g[w[a][16]] & Y) << 2) |
        (!(g[w[a][17]] & Y) << 3) | (!(g[w[a][18]] & Y) << 4) | (!(g[w[a][19]] & Y) << 5)] != 5 ||
        !(g[K[2] = w[a][b[~K[0] & 63] - 1] - a + w[a][13 + b[~K[1] & 63]]] & Y))
        continue;            // Skip for digit not in either five Row Cells; or five Column Cells; or no exclusion
      g[K[2]] -= Y;          // Drop digit from exclusion Cell
#if RJ > 2
      printf ("%d)%s2-String Kite: SL Value %d Row %d between Cell",
        p, ((g[w[a][6]] & g[w[a][7]]) | (g[w[a][12]] & g[w[a][13]])) & Y ? " Grouped " : " ",
        b[Y], b[(w[a][20] >> 18) & 511]);
      if (g[w[a][6]] & g[w[a][7]] & Y)
        printf ("s %s %s", S[w[a][6]], S[w[a][7]]);
      else
        printf (" %s", S[w[a][g[w[a][6]] & Y ? 6 : 7]]);
      printf (" and Cell %s Column %d between Cell",
        S[w[a][b[~K[0] & 63] - 1]], b[w[a][20] & 511]);
      if (g[w[a][12]] & g[w[a][13]] & Y)
        printf ("s %s %s", S[w[a][12]], S[w[a][13]]);
      else
        printf (" %s", S[w[a][g[w[a][12]] & Y ? 12 : 13]]);
      printf (" and Cell %s\n=> -%d @ %s\n",
        S[w[a][13 + b[~K[1] & 63]]], b[Y], S[K[2]]);
#endif
      if (solve (p))
        return 1;
#if RJ > 2
      printf ("%d) Undo%s2-String Kite: SL Value %d Row %d between Cell",
        p, ((g[w[a][6]] & g[w[a][7]]) | (g[w[a][12]] & g[w[a][13]])) & Y ? " Grouped " : " ",
        b[Y], b[(w[a][20] >> 18) & 511]);
      if (g[w[a][6]] & g[w[a][7]] & Y)
        printf ("s %s %s", S[w[a][6]], S[w[a][7]]);
      else
        printf (" %s", S[w[a][g[w[a][6]] & Y ? 6 : 7]]);
      printf (" and Cell %s Column %d between Cell",
        S[w[a][b[~K[0] & 63] - 1]], b[w[a][20] & 511]);
      if (g[w[a][12]] & g[w[a][13]] & Y)
        printf ("s %s %s", S[w[a][12]], S[w[a][13]]);
      else
        printf (" %s", S[w[a][g[w[a][12]] & Y ? 12 : 13]]);
      printf (" and Cell %s\n<= +%d @ %s\n",
        S[w[a][13 + b[~K[1] & 63]]], b[Y], S[K[2]]);
#endif
      g[K[2]] |= Y;
#if RJ > 3
      prn ();
#endif
      return 0;              // Undo 2-String Kite and Grouped 2-String Kite digit to excluding Cell position
    }
  }
  for (a = 0; a < 81; ++a)   // Search Empty Rectangle Intersection Cell position grid wise
  {
    int K[8] = {ERI (a)};    // Assign ERI Cell Values

    for (; K[1] = K[0] & -K[0]; K[0] -= K[1])
                             // Search SL ERI digit wise
      for (y = 0; y < 2; ++y)// Search SL Line wise
        for (Y = W[1][!y]; Y < W[2][!y]; ++Y)
        {                    // Search SL 1st Cell position Line wise
          if ((g[K[2] = w[a][Y]] & ~(g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]]) & K[1]) &&
                             // Check ERI digit either in SL 1st Cell Values; and not in mini-Line Cells Values; and
            B[K[3] = !(g[w[K[2]][W[1][y]]] & K[1]) | (!(g[w[K[2]][W[1][y] + 1]] & K[1]) << 1) |
            (!(g[w[K[2]][W[1][y] + 2]] & K[1]) << 2) | (!(g[w[K[2]][W[1][y] + 3]] & K[1]) << 3) |
            (!(g[w[K[2]][W[1][y] + 4]] & K[1]) << 4) | (!(g[w[K[2]][W[1][y] + 5]] & K[1]) << 5)] == 5)
          {                  // No ERI digit in five Line Cell positions
            K[4] = W[b[~K[3] & 63] < 4 ? 5 : 1][y];
            K[5] = W[Y < W[5][!y] ? 5 : 1][!y];
            K[6] = w[K[2]][W[1][y] + b[~K[3] & 63] - 1];
            K[7] = w[a][W[1][y] + b[~K[3] & 63] - 1];
            if (ERI (K[7]) & // Check Dual Linked Empty Rectangle Intersection Cell Values; and
              (g[K[7]] | g[w[K[7]][K[5]]] | g[w[K[7]][K[5] + 1]] | g[w[K[7]][K[5] + 2]] |
              g[a] | g[w[a][K[4]]] | g[w[a][K[4] + 1]] | g[w[a][K[4] + 2]] |
              g[w[a][K[5]]] | g[w[a][K[5] + 1]] | g[w[a][K[5] + 2]] |
              g[w[K[2]][W[3][!y]]] | g[w[K[2]][W[4][!y]]] |
              g[w[K[6]][W[3][!y]]] | g[w[K[6]][W[4][!y]]]) & K[1])
            {                // Dual Linked Empty Rectangle exclusions
              int k[16] = {g[K[7]], g[w[K[7]][K[5]]], g[w[K[7]][K[5] + 1]], g[w[K[7]][K[5] + 2]],
                          g[a], g[w[a][K[4]]], g[w[a][K[4] + 1]], g[w[a][K[4] + 2]],
                          g[w[a][K[5]]], g[w[a][K[5] + 1]], g[w[a][K[5] + 2]],
                          g[w[K[2]][W[3][!y]]], g[w[K[2]][W[4][!y]]],
                          g[w[K[6]][W[3][!y]]], g[w[K[6]][W[4][!y]]]};
                             // Backup Dual Linked Empty Rectangle exclusion Cells Values and drop ERI digit
              g[K[7]] &= ~K[1];
              g[w[K[7]][K[5]]] &= ~K[1];
              g[w[K[7]][K[5] + 1]] &= ~K[1];
              g[w[K[7]][K[5] + 2]] &= ~K[1];
              g[a] &= ~K[1];
              g[w[a][K[4]]] &= ~K[1];
              g[w[a][K[4] + 1]] &= ~K[1];
              g[w[a][K[4] + 2]] &= ~K[1];
              g[w[a][K[5]]] &= ~K[1];
              g[w[a][K[5] + 1]] &= ~K[1];
              g[w[a][K[5] + 2]] &= ~K[1];
              g[w[K[2]][W[3][!y]]] &= ~K[1];
              g[w[K[2]][W[4][!y]]] &= ~K[1];
              g[w[K[6]][W[3][!y]]] &= ~K[1];
              g[w[K[6]][W[4][!y]]] &= ~K[1];
#if RJ > 2
              printf ("%d) Dual Linked Empty Rectangle: ERI b%d%s and ERI b%d%s SL Value %d %s %d between Cell %s and Cell %s\n=> -%d @ %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s\n",
                p, BOX (a), S[a], BOX (K[7]), S[K[7]], b[K[1]], R_C, RCN (K[2]),
                S[K[2]], S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]],
                b[K[1]], S[K[7]], S[w[K[7]][K[5]]], S[w[K[7]][K[5] + 1]], S[w[K[7]][K[5] + 2]],
                S[a], S[w[a][K[4]]], S[w[a][K[4] + 1]], S[w[a][K[4] + 2]],
                S[w[a][K[5]]], S[w[a][K[5] + 1]], S[w[a][K[5] + 2]], S[w[K[2]][W[3][!y]]],
                S[w[K[2]][W[4][!y]]], S[w[K[6]][W[3][!y]]], S[w[K[6]][W[4][!y]]]);
#endif
              if (solve (p))
                return 1;
#if RJ > 2
              printf ("%d) Undo Dual Linked Empty Rectangle: ERI b%d%s and ERI b%d%s SL Value %d %s %d between Cell %s and Cell %s\n<= +%d @ %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s\n",
                p, BOX (a), S[a], BOX (K[7]), S[K[7]], b[K[1]], R_C, RCN (K[2]),
                S[K[2]], S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]],
                b[K[1]], S[K[7]], S[w[K[7]][K[5]]], S[w[K[7]][K[5] + 1]], S[w[K[7]][K[5] + 2]],
                S[a], S[w[a][K[4]]], S[w[a][K[4] + 1]], S[w[a][K[4] + 2]],
                S[w[a][K[5]]], S[w[a][K[5] + 1]], S[w[a][K[5] + 2]], S[w[K[2]][W[3][!y]]],
                S[w[K[2]][W[4][!y]]], S[w[K[6]][W[3][!y]]], S[w[K[6]][W[4][!y]]]);
#endif
              g[K[7]] = k[0];
              g[w[K[7]][K[5]]] = k[1];
              g[w[K[7]][K[5] + 1]] = k[2];
              g[w[K[7]][K[5] + 2]] = k[3];
              g[a] = k[4];
              g[w[a][K[4]]] = k[5];
              g[w[a][K[4] + 1]] = k[6];
              g[w[a][K[4] + 2]] = k[7];
              g[w[a][K[5]]] = k[8];
              g[w[a][K[5] + 1]] = k[9];
              g[w[a][K[5] + 2]] = k[10];
              g[w[K[2]][W[3][!y]]] = k[11];
              g[w[K[2]][W[4][!y]]] = k[12];
              g[w[K[6]][W[3][!y]]] = k[13];
              g[w[K[6]][W[4][!y]]] = k[14];
#if RJ > 3
              prn ();
#endif
              return 0;      // Undo Dual Linked Empty Rectangle exclusion Cell Values
            }
            if (!(g[K[7]] & K[1]))
              continue;      // Skip for no Empty Rectangle exclusion
            g[K[7]] -= K[1]; // Drop ERI SL digit from Line Cell position
#if RJ > 2
            printf ("%d) Empty Rectangle: ERI b%d%s SL Value %d %s %d between Cell %s and Cell %s => -%d @ %s\n",
              p, BOX (a), S[a], b[K[1]], R_C, RCN (K[2]), S[K[2]],
              S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]], b[K[1]], S[K[7]]);
            if (!(g[w[K[7]][W[3][!y]]] & K[1]) + !(g[w[K[7]][W[4][!y]]] & K[1]) +
              !(g[w[K[7]][W[1][!y]]] & K[1]) + !(g[w[K[7]][W[1][!y] + 1]] & K[1]) +
              !(g[w[K[7]][W[1][!y] + 2]] & K[1]) + !(g[w[K[7]][W[1][!y] + 3]] & K[1]) +
              !(g[w[K[7]][W[1][!y] + 4]] & K[1]) + !(g[w[K[7]][W[1][!y] + 5]] & K[1]) == 7)
            {                // Check one ERI digit in 2nd Line Cell positions
              g[K[2]] -= K[1];
              printf ("%d) Empty Rectangle: ERI b%d%s SL Value %d %s %d between Cell %s and Cell %s => -%d @ %s\n",
                p, BOX (a), S[a], b[K[1]], y ? "Row" : "Column",
                b[(y ? w[K[7]][20] >> 18 : w[K[7]][20]) & 511], S[K[7]],
                S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]], b[K[1]], S[K[2]]);
            }                // Drop ERI SL digit from Line Cell position
#endif
            if (solve (p))
              return 1;
#if RJ > 2
            printf ("%d) Undo Empty Rectangle: ERI b%d%s SL Value %d %s %d between Cell %s and Cell %s <= +%d @ %s\n",
              p, BOX (a), S[a], b[K[1]], R_C, RCN (K[2]), S[K[2]],
              S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]], b[K[1]], S[K[7]]);
            if (!(g[w[K[7]][W[3][!y]]] & K[1]) + !(g[w[K[7]][W[4][!y]]] & K[1]) +
              !(g[w[K[7]][W[1][!y]]] & K[1]) + !(g[w[K[7]][W[1][!y] + 1]] & K[1]) +
              !(g[w[K[7]][W[1][!y] + 2]] & K[1]) + !(g[w[K[7]][W[1][!y] + 3]] & K[1]) +
              !(g[w[K[7]][W[1][!y] + 4]] & K[1]) + !(g[w[K[7]][W[1][!y] + 5]] & K[1]) == 7)
            {                // Check one ERI digit in 2nd Line Cell positions
              printf ("%d) Undo Empty Rectangle: ERI b%d%s SL Value %d %s %d between Cell %s and Cell %s <= +%d @ %s\n",
                p, BOX (a), S[a], b[K[1]], y ? "Row" : "Column",
                b[(y ? w[K[7]][20] >> 18 : w[K[7]][20]) & 511], S[K[7]],
                S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]], b[K[1]], S[K[2]]);
              g[K[2]] |= K[1];
            }                // Undo ERI SL digit to Line Cell position
#endif
            g[K[7]] |= K[1];
#if RJ > 3
            prn ();
#endif
            return 0;        // Undo ERI SL digit to Line Cell position
          }
          if (!(ERI (K[2]) & K[1]))
            continue;        // Skip for ERI digit not in SL 1st ERI Cells
          for (K[3] = W[1][y]; K[3] < W[2][y]; ++K[3])
            if (ERI (w[K[2]][K[3]]) & K[1])
              break;         // Check ERI digit in SL 2nd ERI Cells
          if (K[3] == W[2][y])
            continue;        // Skip for ERI digit not in SL 2nd ERI Cells
          K[4] = w[K[2]][K[3]];
          K[5] = W[Y < W[5][!y] ? 5 : 1][!y];
          K[6] = W[K[3] < W[5][y] ? 5 : 1][y];
          K[7] = a - K[2] + K[4];
          if (ERI (K[7]) &   // Check Grouped Linked Empty Rectangle Intersection Cell Values; and
            (g[a] | g[w[a][K[5]]] | g[w[a][K[5] + 1]] | g[w[a][K[5] + 2]] |
            g[K[2]] | g[w[K[2]][K[6]]] | g[w[K[2]][K[6] + 1]] | g[w[K[2]][K[6] + 2]] |
            g[K[4]] | g[w[K[7]][K[5]]] | g[w[K[7]][K[5] + 1]] | g[w[K[7]][K[5] + 2]] |
            g[K[7]] | g[w[a][K[6]]] | g[w[a][K[6] + 1]] | g[w[a][K[6] + 2]]) & K[1])
          {                  // Grouped Linked Empty Rectangle Intersection exclusions
            int k[17] = {g[a], g[w[a][K[5]]], g[w[a][K[5] + 1]], g[w[a][K[5] + 2]],
                        g[K[2]], g[w[K[2]][K[6]]], g[w[K[2]][K[6] + 1]], g[w[K[2]][K[6] + 2]],
                        g[K[4]], g[w[K[7]][K[5]]], g[w[K[7]][K[5] + 1]], g[w[K[7]][K[5] + 2]],
                        g[K[7]], g[w[a][K[6]]], g[w[a][K[6] + 1]], g[w[a][K[6] + 2]]};
                             // Backup Grouped Linked Empty Rectangle exclusion Cells Values and drop ERI digit
            g[a] &= ~K[1];
            g[w[a][K[5]]] &= ~K[1];
            g[w[a][K[5] + 1]] &= ~K[1];
            g[w[a][K[5] + 2]] &= ~K[1];
            g[K[2]] &= ~K[1];
            g[w[K[2]][K[6]]] &= ~K[1];
            g[w[K[2]][K[6] + 1]] &= ~K[1];
            g[w[K[2]][K[6] + 2]] &= ~K[1];
            g[K[4]] &= ~K[1];
            g[w[K[7]][K[5]]] &= ~K[1];
            g[w[K[7]][K[5] + 1]] &= ~K[1];
            g[w[K[7]][K[5] + 2]] &= ~K[1];
            g[K[7]] &= ~K[1];
            g[w[a][K[6]]] &= ~K[1];
            g[w[a][K[6] + 1]] &= ~K[1];
            g[w[a][K[6] + 2]] &= ~K[1];
#if RJ > 2
            printf ("%d) Grouped Linked Empty Rectangle: ERI b%d%s and ERI b%d%s SL Value %d %s %d between ERI b%d%s and ERI b%d%s\n=> -%d @ %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s\n",
              p, BOX (a), S[a], BOX (K[7]), S[K[7]], b[K[1]], R_C, RCN (K[2]), BOX (K[2]), S[K[2]], BOX (K[4]), S[K[4]],
              b[K[1]], S[a], S[w[a][K[5]]], S[w[a][K[5] + 1]], S[w[a][K[5] + 2]],
              S[K[2]], S[w[K[2]][K[6]]], S[w[K[2]][K[6] + 1]], S[w[K[2]][K[6] + 2]],
              S[K[4]], S[w[K[7]][K[5]]], S[w[K[7]][K[5] + 1]], S[w[K[7]][K[5] + 2]],
              S[K[7]], S[w[a][K[6]]], S[w[a][K[6] + 1]], S[w[a][K[6] + 2]]);
#endif
            if (solve (p))
              return 1;
#if RJ > 2
            printf ("%d) Undo Grouped Linked Empty Rectangle: ERI b%d%s and ERI b%d%s SL Value %d %s %d between ERI b%d%s and ERI b%d%s\n<= +%d @ %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s\n",
              p, BOX (a), S[a], BOX (K[7]), S[K[7]], b[K[1]], R_C, RCN (K[2]), BOX (K[2]), S[K[2]], BOX (K[4]), S[K[4]],
              b[K[1]], S[a], S[w[a][K[5]]], S[w[a][K[5] + 1]], S[w[a][K[5] + 2]],
              S[K[2]], S[w[K[2]][K[6]]], S[w[K[2]][K[6] + 1]], S[w[K[2]][K[6] + 2]],
              S[K[4]], S[w[K[7]][K[5]]], S[w[K[7]][K[5] + 1]], S[w[K[7]][K[5] + 2]],
              S[K[7]], S[w[a][K[6]]], S[w[a][K[6] + 1]], S[w[a][K[6] + 2]]);
#endif
            g[a] = k[0];
            g[w[a][K[5]]] = k[1];
            g[w[a][K[5] + 1]] = k[2];
            g[w[a][K[5] + 2]] = k[3];
            g[K[2]] = k[4];
            g[w[K[2]][K[6]]] = k[5];
            g[w[K[2]][K[6] + 1]] = k[6];
            g[w[K[2]][K[6] + 2]] = k[7];
            g[K[4]] = k[8];
            g[w[K[7]][K[5]]] = k[9];
            g[w[K[7]][K[5] + 1]] = k[10];
            g[w[K[7]][K[5] + 2]] = k[11];
            g[K[7]] = k[12];
            g[w[a][K[6]]] = k[13];
            g[w[a][K[6] + 1]] = k[14];
            g[w[a][K[6] + 2]] = k[15];
#if RJ > 3
            prn ();
#endif
            return 0;        // Undo Grouped Linked Empty Rectangle eliminaton Cell positions
          }
          if (!(g[K[7]] & K[1]))
            continue;        // Skip for no Grouped Empty Rectangle exclusion
          g[K[7]] -= K[1];   // Drop ERI SL digit from Line Cell position
#if RJ > 2
          printf ("%d) Grouped Empty Rectangle: ERI b%d%s SL Value %d %s %d between ERI b%d%s and ERI b%d%s => -%d @ %s\n",
            p, BOX (a), S[a], b[K[1]], R_C, RCN (K[2]), BOX (K[2]), S[K[2]], BOX (K[4]), S[K[4]], b[K[1]], S[K[7]]);
#endif
          if (solve (p))
            return 1;
#if RJ > 2
          printf ("%d) Undo Grouped Empty Rectangle: ERI b%d%s SL Value %d %s %d between ERI b%d%s and ERI b%d%s <= +%d @ %s\n",
            p, BOX (a), S[a], b[K[1]], R_C, RCN (K[2]), BOX (K[2]), S[K[2]], BOX (K[4]), S[K[4]], b[K[1]], S[K[7]]);
#endif
          g[K[7]] |= K[1];
#if RJ > 3
          prn ();
#endif
          return 0;          // Undo ERI SL digit to Line Cell position
        }
  }
  for (y = p; y < q - 1; ++y)// Search W-Wing Type 1, Type 2 and W-Ring 1st Cell position unsolved Cell positions wise
  {
    if (B[g[r[y]]] > 2)
      continue;              // Skip for 1st Cell Values > two digits
    for (Y = y + 1; Y < q; ++Y)
    {                        // Search W-Wing Type 1, Type 2 and W-Ring 2nd Cell position unsolved Cell positions wise
      if (g[r[y]] != g[r[Y]] || (w[r[y]][20] & w[r[Y]][20] & 134217727))
        continue;            // Skip for either 1st and 2nd Cells Values not same; or Cell positions in Unit
      int K[10] = {r[y], r[Y], g[r[y]], r[y] - b[w[r[y]][20] & 511] + b[w[r[Y]][20] & 511],
                  r[Y] - b[w[r[Y]][20] & 511] + b[w[r[y]][20] & 511],-1},
          k[6] = {g[K[3]], g[K[4]]},
          A[3][2] = {{K[4] == w[K[0]][14] || K[4] == w[K[0]][15] || K[4] == w[K[0]][16] ? 17 : 14,
                    K[3] == w[K[0]][0] || K[3] == w[K[0]][1] || K[3] == w[K[0]][2] ? 3 : 0},
                    { 3, 3}, { 0, 1}},
          L,
          N,
          X;

      A[1][0] += A[0][0];
      A[1][1] += A[0][1];
      if ((w[K[0]][20] & 1610612736) == (w[K[1]][20] & 1610612736) ||
        (w[K[0]][20] & 402653184) == (w[K[1]][20] & 402653184))
      {                      // Check 1st and 2nd Cell positions either Band or Stack wise
        if ((w[K[0]][20] & 1610612736) == (w[K[1]][20] & 1610612736))
        {                    // Check 1st and 2nd Cell positions Band wise
          A[1][0] = 20;
          A[2][1] = 0;
          L = w[w[K[0]][K[4] == w[K[0]][12] ? 13 : 12]][A[0][1]];
          K[5] = w[K[3]][6];
          K[6] = w[K[3]][7];
          K[7] = w[K[4]][6];
          K[8] = w[K[4]][7];
        }
        else
        {                    // 1st and 2nd Cell positions Stack wise
          A[1][1] = 6;
          A[2][0] = 1;
          L = w[w[K[0]][K[3] == w[K[0]][6] ? 7 : 6]][A[0][0]];
          K[5] = w[K[3]][12];
          K[6] = w[K[3]][13];
          K[7] = w[K[4]][12];
          K[8] = w[K[4]][13];
        }
        k[2] = g[K[5]];
        k[3] = g[K[6]];
        k[4] = g[K[7]];
        k[5] = g[K[8]];
        if (((N = K[9] = LB3 (w[L][W[1][A[2][0]]], w[L][W[5][A[2][0]]], L, A[2][0]) & K[2]) ||
          (K[9] = LB3 (w[L][W[3][A[2][0]]], w[L][W[4][A[2][0]]], L, A[2][0]) & K[2])) &&
          ((k[0] | k[1] | k[2] | k[3] | k[4] | k[5]) & (K[2] - K[9])))
        {                    // (Type 2 01, 02) Check SL either Line or Box wise
          K[2] -= K[9];
          g[K[3]] &= ~K[2];
          g[K[4]] &= ~K[2];
          g[K[5]] &= ~K[2];
          g[K[6]] &= ~K[2];
          g[K[7]] &= ~K[2];
          g[K[8]] &= ~K[2];
#if RJ > 2
          printf ("%d) Grouped W-Wing Type 2 %s: %d @ %s %s SL Value %d %s %d between Cells %s %s %s and Cells %s %s %s\n=> -%d @ %s %s %s %s %s %s\n",
            p, A[2][0] ? "Stack" : "Band", b[g[K[0]]], S[K[0]], S[K[1]], b[K[9]], K[9] ? (A[2][0] ? "Column" : "Row") : "Box",
            N ? b[(A[2][0] ? w[L][20] : w[L][20] >> 18) & 511] : BOX (L),
            S[X], S[w[X][W[3][A[2][0]]]], S[w[X][W[4][A[2][0]]]], S[Z], S[w[Z][W[3][A[2][0]]]],
            S[w[Z][W[4][A[2][0]]]], b[K[2]], S[K[3]], S[K[5]], S[K[6]], S[K[4]], S[K[7]], S[K[8]]);
#endif
          if (solve (p))
            return 1;
#if RJ > 2
          printf ("%d) Undo Grouped W-Wing Type 2 %s: %d @ %s %s SL Value %d %s %d between Cells %s %s %s and Cells %s %s %s\n<= +%d @ %s %s %s %s %s %s\n",
            p, A[2][0] ? "Stack" : "Band", b[g[K[0]]], S[K[0]], S[K[1]], b[K[9]], K[9] ? (A[2][0] ? "Column" : "Row") : "Box",
            N ? b[(A[2][0] ? w[L][20] : w[L][20] >> 18) & 511] : BOX (L),
            S[X], S[w[X][W[3][A[2][0]]]], S[w[X][W[4][A[2][0]]]], S[Z], S[w[Z][W[3][A[2][0]]]],
            S[w[Z][W[4][A[2][0]]]], b[K[2]], S[K[3]], S[K[5]], S[K[6]], S[K[4]], S[K[7]], S[K[8]]);
#endif
          g[K[3]] = k[0];
          g[K[4]] = k[1];
          g[K[5]] = k[2];
          g[K[6]] = k[3];
          g[K[7]] = k[4];
          g[K[8]] = k[5];
#if RJ > 3
          prn ();
#endif
          return 0;          // Undo W-Wing Type 2 exclusion Cells Values
        }
      }
      else                   // 1st and 2nd Cell positions Grid wise
        for (a = 0; a < 2; ++a)
        {                    // Search W-Wing Type 1 SL Wings wise
          for (K[6] = 0; K[6] < 2; ++K[6])
            for (K[7] = 0; K[7] < 2; ++K[7])
              if ((N = (g[K[8] = w[K[a]][W[3 + K[7]][!K[6]]]] |
                g[w[K[8]][W[3][K[6]]]] | g[w[K[8]][W[4][K[6]]]]) &
                g[K[9] = w[K[K[6] ? 4 - a : 3 + a]][W[3 + K[7]][!K[6]]]] & K[2]) &&
                !(g[w[K[8]][L = W[1][K[6]]]] & N) + !(g[w[K[8]][L + 1]] & N) +
                !(g[w[K[8]][L + 2]] & N) + !(g[w[K[8]][L + 3]] & N) +
                !(g[w[K[8]][L + 4]] & N) + !(g[w[K[8]][L + 5]] & N) > 4 &&
                ((k[0] | k[1]) & (K[2] - N)))
              {              // (Type 1 01) Check SL Line wise
                K[2] -= N;
                g[K[3]] &= ~K[2];
                g[K[4]] &= ~K[2];
#if RJ > 2
                printf ("%d) Grouped W-Wing Type 1 Grid: %d @ %s %s SL Value %d %s %d between Cells %s %s %s and Cell %s\n=> -%d @ %s %s\n",
                  p, b[g[K[0]]], S[K[0]], S[K[1]], b[N], K[6] ? "Column" : "Row",
                  b[(K[6] ? w[K[8]][20] : w[K[8]][20] >> 18) & 511], S[K[8]], S[w[K[8]][W[3][K[6]]]],
                  S[w[K[8]][W[4][K[6]]]], S[K[9]], b[K[2]], S[K[3]], S[K[4]]);
#endif
                if (solve (p))
                  return 1;
#if RJ > 2
                printf ("%d) Undo Grouped W-Wing Type 1 Grid: %d @ %s %s SL Value %d %s %d between Cells %s %s %s and Cell %s\n<= +%d @ %s %s\n",
                  p, b[g[K[0]]], S[K[0]], S[K[1]], b[N], K[6] ? "Column" : "Row",
                  b[(K[6] ? w[K[8]][20] : w[K[8]][20] >> 18) & 511], S[K[8]], S[w[K[8]][W[3][K[6]]]],
                  S[w[K[8]][W[4][K[6]]]], S[K[9]], b[K[2]], S[K[3]], S[K[4]]);
#endif
                g[K[3]] = k[0];
                g[K[4]] = k[1];
#if RJ > 3
                prn ();
#endif
                return 0;    // Undo W-Wing Type 1 exclusion Cells Values
              }
          if ((N = ERI (K[3 + a]) & K[2]) && ((k[0] | k[1]) & (K[2] - N)))
          {                  // (Type 1 02) Check SL ERI wise
            K[2] -= N;
            g[K[3]] &= ~K[2];
            g[K[4]] &= ~K[2];
#if RJ > 2
            printf ("%d) W-Wing Type 1 Grid: %d @ %s %s ERI %d @ b%d%s => -%d @ %s %s\n",
              p, b[g[K[0]]], S[K[0]], S[K[1]], b[N], BOX (K[3 + a]), S[K[3 + a]], b[K[2]], S[K[3]], S[K[4]]);
#endif
            if (solve (p))
              return 1;
#if RJ > 2
            printf ("%d) Undo W-Wing Type 1 Grid: %d @ %s %s ERI %d @ b%d%s <= +%d @ %s %s\n",
              p, b[g[K[0]]], S[K[0]], S[K[1]], b[N], BOX (K[3 + a]), S[K[3 + a]], b[K[2]], S[K[3]], S[K[4]]);
#endif
            g[K[3]] = k[0];
            g[K[4]] = k[1];
#if RJ > 3
            prn ();
#endif
            return 0;        // Undo W-Wing Type 1 exclusion Cells Values
          }
        }
      for (a = A[2][0]; a <= A[2][1]; ++a)
        for (L = A[0][a]; L < A[1][a]; ++L)
        {                    // Search W-Wing Type 1 and Type 2 SL Line and ERI wise
          if (((N = K[9] = LN1 (w[K[0]][L], w[K[3 + a]][L], w[X][A[0][!a]], a) & K[2]) ||
            (K[9] = ERI (X) & ERI (Z) & K[2])) &&
            ((k[0] | k[1] | k[2] | k[3] | k[4] | k[5]) & (K[2] - K[9])))
          {                  // (Type 1 03, 04, Type 2 03, 04) Check SL either Line or ERI wise
            K[2] -= K[9];
            g[K[3]] &= ~K[2];
            g[K[4]] &= ~K[2];
            if (K[5] + 1)
            {
              g[K[5]] &= ~K[2];
              g[K[6]] &= ~K[2];
              g[K[7]] &= ~K[2];
              g[K[8]] &= ~K[2];
            }
#if RJ > 2
            printf ("%d) W-Wing Type %s: %d @ %s %s SL Value %d%s",
              p, A[2][0] != A[2][1] ? "1 Grid" : A[2][0] ? "2 Stack" : "2 Band", b[g[K[0]]],
              S[K[0]], S[K[1]], b[K[9]], N ? (A[2][0] ? " Column " : " Row ") : " ");
            if (N)
              printf ("%d between Cell ", b[(A[2][0] ? w[X][20] : w[X][20] >> 18) & 511]);
            else
              printf ("between ERI b%d", BOX (X));
            printf ("%s and %s ", S[X], N ? "Cell" : "ERI");
            if (!N)
              printf ("b%d", BOX (Z));
            printf ("%s\n=> -%d @ %s ", S[Z], b[K[2]], S[K[3]]);
            if (K[5] + 1)
              printf ("%s %s %s %s %s\n", S[K[5]], S[K[6]], S[K[4]], S[K[7]], S[K[8]]);
            else
              printf ("%s\n", S[K[4]]);
#endif
              if (solve (p))
                return 1;
#if RJ > 2
            printf ("%d) Undo W-Wing Type %s: %d @ %s %s SL Value %d%s",
              p, A[2][0] != A[2][1] ? "1 Grid" : A[2][0] ? "2 Stack" : "2 Band", b[g[K[0]]],
              S[K[0]], S[K[1]], b[K[9]], N ? (A[2][0] ? " Column " : " Row ") : " ");
            if (N)
              printf ("%d between Cell ", b[(A[2][0] ? w[X][20] : w[X][20] >> 18) & 511]);
            else
              printf ("between ERI b%d", BOX (X));
            printf ("%s and %s ", S[X], N ? "Cell" : "ERI");
            if (!N)
              printf ("b%d", BOX (Z));
            printf ("%s\n<= +%d @ %s ", S[Z], b[K[2]], S[K[3]]);
            if (K[5] + 1)
              printf ("%s %s %s %s %s\n", S[K[5]], S[K[6]], S[K[4]], S[K[7]], S[K[8]]);
            else
              printf ("%s\n", S[K[4]]);
#endif
            g[K[3]] = k[0];
            g[K[4]] = k[1];
            if (K[5] + 1)
            {
              g[K[5]] = k[2];
              g[K[6]] = k[3];
              g[K[7]] = k[4];
              g[K[8]] = k[5];
            }
#if RJ > 3
            prn ();
#endif
            return 0;        // Undo W-Wing Type 1 and Type 2 exclusion Cells Values
          }
        }
    }
  }
  for (a = p; a < q; ++a)    // Search XY-Ring Type 1, XY-Wing Type 1, XY-Wing Type 1 Transport and XYZ-Transport Apex Cell unsolved Cell positions wise
  {
    if (B[g[r[a]]] > 3 ||    // Skip for Apex Cell Values > three digits; or
      !(g[w[r[a]][0]] | g[w[r[a]][1]] | g[w[r[a]][2]] |
      g[w[r[a]][3]] | g[w[r[a]][4]] | g[w[r[a]][5]]) ||
      !(g[w[r[a]][14]] | g[w[r[a]][15]] | g[w[r[a]][16]] |
      g[w[r[a]][17]] | g[w[r[a]][18]] | g[w[r[a]][19]]))
      continue;              // No unsolved Cell position in either Apex Row or Column
    int K[9] = {r[a], 0};    // Assign Apex Cell position

    for (; K[1] < 6; ++K[1]) // Search 1st Wing Cell position Row wise
    {
      if (B[g[K[2] = w[K[0]][K[1]]]] != 2 || B[g[K[0]] | g[K[2]]] != 3)
        continue;            // Skip for either 1st Wing Cell Values not two digits; or Apex and 1st Wing Cells Values not three digits
      for (K[3] = 14; K[3] < 20; ++K[3])
      {                      // Search 2nd Wing Cell position Column wise
        if (B[g[K[4] = w[K[0]][K[3]]]] != 2 || B[g[K[0]] | g[K[4]]] != 3)
          continue;          // Skip for either 2nd Wing Cell Values not two digits; or Apex and 2nd Wing Cells Values not three digits
        if (B[g[K[6] = K[2] - K[0] + K[4]]] == 2 && K[2] > K[0] && K[4] > K[0] &&
                             // Check XY-Ring Type 1 3rd Wing Cell Values two digits; and 1st Wing Cell position > Apex Cell position; and 2nd Wing Cell position > Apex Cell position; and
          B[g[K[0]]] < 3 && !(g[K[2]] & g[K[4]]) && B[g[K[2]] | g[K[6]]] == 3 &&
                             // Apex Cell Values two digits; and 1st and 2nd Wing Cells Values four digits; and 1st and 3rd Wing Cells Values three digits; and
          B[g[K[4]] | g[K[6]]] == 3 && !(g[K[0]] & g[K[6]]) &&
                             // 2nd and 3rd Wing Cells Values three digits; and Apex and 3rd Wing Cells Values four digits; and
          (((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
          g[w[K[0]][K[5] = K[1] < 3 ? 3 : 0]] | g[w[K[0]][K[5] + 1]] |
          g[w[K[0]][K[5] + 2]]) & g[K[0]] & g[K[2]]) ||
          ((g[w[K[4]][6]] | g[w[K[4]][7]] | g[w[K[6]][6]] | g[w[K[6]][7]] |
          g[w[K[4]][K[5]]] | g[w[K[4]][K[5] + 1]] |
          g[w[K[4]][K[5] + 2]]) & g[K[4]] & g[K[6]]) ||
          ((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
          g[w[K[0]][K[7] = K[3] < 17 ? 17 : 14]] | g[w[K[0]][K[7] + 1]] |
          g[w[K[0]][K[7] + 2]]) & g[K[0]] & g[K[4]]) ||
          ((g[w[K[2]][12]] | g[w[K[2]][13]] | g[w[K[6]][12]] | g[w[K[6]][13]] |
          g[w[K[2]][K[7]]] | g[w[K[2]][K[7] + 1]] |
          g[w[K[2]][K[7] + 2]]) & g[K[2]] & g[K[6]])))
        {                    // XY-Ring Type 1 exclusion Cell Values
          int k[28] = {g[w[K[0]][6]], g[w[K[0]][7]], g[w[K[2]][6]], g[w[K[2]][7]],
                       g[w[K[0]][K[5]]], g[w[K[0]][K[5] + 1]], g[w[K[0]][K[5] + 2]],
                       g[w[K[4]][6]], g[w[K[4]][7]], g[w[K[6]][6]], g[w[K[6]][7]],
                       g[w[K[4]][K[5]]], g[w[K[4]][K[5] + 1]], g[w[K[4]][K[5] + 2]],
                       g[w[K[0]][12]], g[w[K[0]][13]], g[w[K[4]][12]], g[w[K[4]][13]],
                       g[w[K[0]][K[7] = K[3] < 17 ? 17 : 14]], g[w[K[0]][K[7] + 1]], g[w[K[0]][K[7] + 2]],
                       g[w[K[2]][12]], g[w[K[2]][13]], g[w[K[6]][12]], g[w[K[6]][13]],
                       g[w[K[2]][K[7]]], g[w[K[2]][K[7] + 1]], g[w[K[2]][K[7] + 2]]};
                             // Backup XY-Ring Type 1 exclusion Cell Values and drop Wing Cells common exclusion Values
          g[w[K[0]][6]] &= ~(g[K[0]] & g[K[2]]);
          g[w[K[0]][7]] &= ~(g[K[0]] & g[K[2]]);
          g[w[K[2]][6]] &= ~(g[K[0]] & g[K[2]]);
          g[w[K[2]][7]] &= ~(g[K[0]] & g[K[2]]);
          g[w[K[0]][K[5]]] &= ~(g[K[0]] & g[K[2]]);
          g[w[K[0]][K[5] + 1]] &= ~(g[K[0]] & g[K[2]]);
          g[w[K[0]][K[5] + 2]] &= ~(g[K[0]] & g[K[2]]);
          g[w[K[4]][6]] &= ~(g[K[4]] & g[K[6]]);
          g[w[K[4]][7]] &= ~(g[K[4]] & g[K[6]]);
          g[w[K[6]][6]] &= ~(g[K[4]] & g[K[6]]);
          g[w[K[6]][7]] &= ~(g[K[4]] & g[K[6]]);
          g[w[K[4]][K[5]]] &= ~(g[K[4]] & g[K[6]]);
          g[w[K[4]][K[5] + 1]] &= ~(g[K[4]] & g[K[6]]);
          g[w[K[4]][K[5] + 2]] &= ~(g[K[4]] & g[K[6]]);
          g[w[K[0]][12]] &= ~(g[K[0]] & g[K[4]]);
          g[w[K[0]][13]] &= ~(g[K[0]] & g[K[4]]);
          g[w[K[4]][12]] &= ~(g[K[0]] & g[K[4]]);
          g[w[K[4]][13]] &= ~(g[K[0]] & g[K[4]]);
          g[w[K[0]][K[7]]] &= ~(g[K[0]] & g[K[4]]);
          g[w[K[0]][K[7] + 1]] &= ~(g[K[0]] & g[K[4]]);
          g[w[K[0]][K[7] + 2]] &= ~(g[K[0]] & g[K[4]]);
          g[w[K[2]][12]] &= ~(g[K[2]] & g[K[6]]);
          g[w[K[2]][13]] &= ~(g[K[2]] & g[K[6]]);
          g[w[K[6]][12]] &= ~(g[K[2]] & g[K[6]]);
          g[w[K[6]][13]] &= ~(g[K[2]] & g[K[6]]);
          g[w[K[2]][K[7]]] &= ~(g[K[2]] & g[K[6]]);
          g[w[K[2]][K[7] + 1]] &= ~(g[K[2]] & g[K[6]]);
          g[w[K[2]][K[7] + 2]] &= ~(g[K[2]] & g[K[6]]);
#if RJ > 2
          printf ("%d) XY-Ring Type 1: %d @ %s %s %s %s\n=> -%d @ %s %s %s %s %s %s %s => -%d @ %s %s %s %s %s %s %s\n=> -%d @ %s %s %s %s %s %s %s => -%d @ %s %s %s %s %s %s %s\n",
            p, b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], S[K[6]],
            b[g[K[0]] & g[K[2]]], S[w[K[0]][6]], S[w[K[0]][7]], S[w[K[2]][6]], S[w[K[2]][7]],
            S[w[K[0]][K[5]]], S[w[K[0]][K[5] + 1]], S[w[K[0]][K[5] + 2]],
            b[g[K[4]] & g[K[6]]], S[w[K[4]][6]], S[w[K[4]][7]], S[w[K[6]][6]], S[w[K[6]][7]],
            S[w[K[4]][K[5]]], S[w[K[4]][K[5] + 1]], S[w[K[4]][K[5] + 2]],
            b[g[K[0]] & g[K[4]]], S[w[K[0]][12]], S[w[K[0]][13]], S[w[K[4]][12]], S[w[K[4]][13]],
            S[w[K[0]][K[7]]], S[w[K[0]][K[7] + 1]], S[w[K[0]][K[7] + 2]],
            b[g[K[2]] & g[K[6]]], S[w[K[2]][12]], S[w[K[2]][13]], S[w[K[6]][12]], S[w[K[6]][13]],
            S[w[K[2]][K[7]]], S[w[K[2]][K[7] + 1]], S[w[K[2]][K[7] + 2]]);
#endif
          if (solve (p))
            return 1;
#if RJ > 2
          printf ("%d) Undo XY-Ring Type 1: %d @ %s %s %s %s\n<= +%d @ %s %s %s %s %s %s %s <= +%d @ %s %s %s %s %s %s %s\n<= +%d @ %s %s %s %s %s %s %s <= +%d @ %s %s %s %s %s %s %s\n",
            p, b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], S[K[6]],
            b[g[K[0]] & g[K[2]]], S[w[K[0]][6]], S[w[K[0]][7]], S[w[K[2]][6]], S[w[K[2]][7]],
            S[w[K[0]][K[5]]], S[w[K[0]][K[5] + 1]], S[w[K[0]][K[5] + 2]],
            b[g[K[4]] & g[K[6]]], S[w[K[4]][6]], S[w[K[4]][7]], S[w[K[6]][6]], S[w[K[6]][7]],
            S[w[K[4]][K[5]]], S[w[K[4]][K[5] + 1]], S[w[K[4]][K[5] + 2]],
            b[g[K[0]] & g[K[4]]], S[w[K[0]][12]], S[w[K[0]][13]], S[w[K[4]][12]], S[w[K[4]][13]],
            S[w[K[0]][K[7]]], S[w[K[0]][K[7] + 1]], S[w[K[0]][K[7] + 2]],
            b[g[K[2]] & g[K[6]]], S[w[K[2]][12]], S[w[K[2]][13]], S[w[K[6]][12]], S[w[K[6]][13]],
            S[w[K[2]][K[7]]], S[w[K[2]][K[7] + 1]], S[w[K[2]][K[7] + 2]]);
#endif
          g[w[K[0]][6]] = k[0];
          g[w[K[0]][7]] = k[1];
          g[w[K[2]][6]] = k[2];
          g[w[K[2]][7]] = k[3];
          g[w[K[0]][K[5]]] = k[4];
          g[w[K[0]][K[5] + 1]] = k[5];
          g[w[K[0]][K[5] + 2]] = k[6];
          g[w[K[4]][6]] = k[7];
          g[w[K[4]][7]] = k[8];
          g[w[K[6]][6]] = k[9];
          g[w[K[6]][7]] = k[10];
          g[w[K[4]][K[5]]] = k[11];
          g[w[K[4]][K[5] + 1]] = k[12];
          g[w[K[4]][K[5] + 2]] = k[13];
          g[w[K[0]][12]] = k[14];
          g[w[K[0]][13]] = k[15];
          g[w[K[4]][12]] = k[16];
          g[w[K[4]][13]] = k[17];
          g[w[K[0]][K[7]]] = k[18];
          g[w[K[0]][K[7] + 1]] = k[19];
          g[w[K[0]][K[7] + 2]] = k[20];
          g[w[K[2]][12]] = k[21];
          g[w[K[2]][13]] = k[22];
          g[w[K[6]][12]] = k[23];
          g[w[K[6]][13]] = k[24];
          g[w[K[2]][K[7]]] = k[25];
          g[w[K[2]][K[7] + 1]] = k[26];
          g[w[K[2]][K[7] + 2]] = k[27];
#if RJ > 3
          prn ();
#endif
          return 0;          // Undo Wing Cells common Value to XY-Ring Type 1 exclusion Cell Values
        }
        if (B[g[K[0]] | g[K[2]] | g[K[4]]] != 3 ||
                             // Skip for either Apex and Wings Cells Values not three digits; or
          B[K[5] = g[K[2]] & g[K[4]]] != 1)
          continue;          // Wing Cells common Value not one digit
        if (~g[K[0]] & g[K[6]] & K[5])
        {                    // Check XY-Wing Type 1 exclusion Cell Values
          g[K[6]] -= K[5];   // Drop Wing Cells common Value from XY-Wing Type 1 exclusion Cell position
#if RJ > 2
          printf ("%d) XY-Wing Type 1: %d @ %s %s %s => -%d @ %s\n",
            p, b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]], S[K[6]]);
#endif
          if (solve (p))
            return 1;
#if RJ > 2
          printf ("%d) Undo XY-Wing Type 1: %d @ %s %s %s <= +%d @ %s\n",
            p, b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]], S[K[6]]);
#endif
          g[K[6]] |= K[5];
#if RJ > 3
          prn ();
#endif
          return 0;          // Undo Wing Cells common Value to XY-Wing Type 1 exclusion Cell Values
        }
        int L,               // XY-Wing Type 1 Transport and XYZ-Transport
            M,
            X,
            N,
            k[51] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
#if RJ > 2
        int A[2][3] = {{-1,-1,-1}, {-1,-1,-1}};
#endif
        K[7] = K[1] < 3 ? 3 : 0;
        K[8] = K[3] < 17 ? 17 : 14;
/*
        X = w[K[0]][K[7]];
        Y = w[K[4]][K[7]];
        y = 0;
        if ((ERI (X) & K[5]) || ((y = 1) && (ERI (X + y) & K[5])) ||
          ((y = 2) && (ERI (X + y) & K[5])))
        {                    // ERI 01, 09, 25, Reduced ERI 05, 13, 17, 21, 29
          if (g[Y + y] & K[5])
            k[0] = Y + y;
          if (~g[w[X + y][12]] & g[w[K[0]][13]] & K[5])
            k[1] = w[K[0]][13];
          else if (~g[w[X + y][13]] & g[w[K[0]][12]] & K[5])
            k[1] = w[K[0]][12];
#if RJ > 2
          k[50] = k[1] + 1 ? 6 : 2;
          A[0][0] = X + y;
#endif
          Z = w[X + y][K[8]];
          L = 0;
          if ((ERI (Z) & K[5]) || ((L = 9) && (ERI (Z + L) & K[5])) ||
            ((L = 18) && (ERI (Z + L) & K[5])))
          {
            if (g[w[K[0]][K[8]] + L] & K[5])
              k[2] = w[K[0]][K[8]] + L;
            if (~g[w[Z + L][6]] & g[w[Y + y][7]] & K[5])
              k[3] = w[Y + y][7];
            else if (~g[w[Z + L][7]] & g[w[Y + y][6]] & K[5])
              k[3] = w[Y + y][6];
#if RJ > 2
            if (k[3] + 1)
              k[50] = 6;
            A[1][0] = Z + L;
#endif
          }
          else if (((L = 12) && (ERI (w[Y + y][L]) & K[5])) ||
            ((L = 13) && (ERI (w[Y + y][L]) & K[5])))
          {
            if ((g[M = w[K[4]][L]] | g[w[M][6]] | g[w[M][7]]) & K[5])
            {
              k[2] = M;
              k[3] = w[M][6];
              k[4] = w[M][7];
            }
#if RJ > 2
            A[1][0] = w[Y + y][L];
#endif
          }
          if ((k[0] & k[1] & k[2] & k[3]) + 1)
            goto XYWT1Tf;
        }
        X = w[K[0]][K[8]];
        Y = w[K[2]][K[8]];
        y = 0;
        if ((ERI (X) & K[5]) || ((y = 9) && (ERI (X + y) & K[5])) ||
          ((y = 18) && (ERI (X + y) & K[5])))
        {                    // ERI 02, 10, 26, Reduced ERI 06, 14, 18, 22, 30
          if (g[Y + y] & K[5])
            k[0] = Y + y;
          if (~g[w[X + y][6]] & g[w[K[0]][7]] & K[5])
            k[1] = w[K[0]][7];
          else if (~g[w[X + y][7]] & g[w[K[0]][6]] & K[5])
            k[1] = w[K[0]][6];
#if RJ > 2
          k[50] = k[1] + 1 ? 6 : 2;
          A[0][0] = X + y;
#endif
          Z = w[X + y][K[7]];
          L = 0;
          if ((ERI (Z) & K[5]) || ((L = 1) && (ERI (Z + L) & K[5])) ||
            ((L = 2) && (ERI (Z + L) & K[5])))
          {
            if (g[w[K[0]][K[7]] + L] & K[5])
              k[2] = w[K[0]][K[7]] + L;
            if (~g[w[Z + L][12]] & g[w[Y + y][13]] & K[5])
              k[3] = w[Y + y][13];
            else if (~g[w[Z + L][13]] & g[w[Y + y][12]] & K[5])
              k[3] = w[Y + y][12];
          }
          else if (((L = 6) && (ERI (w[Y + y][L]) & K[5])) ||
            ((L = 7) && (ERI (w[Y + y][L]) & K[5])))
          {
            if ((g[M = w[K[2]][L]] | g[w[M][12]] | g[w[M][13]]) & K[5])
            {
              k[2] = M;
              k[3] = w[M][12];
              k[4] = w[M][13];
            }
#if RJ > 2
            A[1][0] = w[Y + y][L];
#endif
          }
          if ((k[0] & k[1] & k[2] & k[3]) + 1)
            goto XYWT1Tf;
        }
        X = w[K[4]][K[7]];
        Y = w[K[0]][K[7]];
        y = 0;
        if ((ERI (X) & K[5]) || ((y = 1) && (ERI (X + y) & K[5])) ||
          ((y = 2) && (ERI (X + y) & K[5])))
        {                    // ERI 03, 11, 27, Reduced ERI 07, 15, 19, 23, 31
          if (g[Y + y] & K[5])
            k[0] = Y + y;
          if (B[g[K[0]]] < 3)
          {                  // Reduced ERI 07
            if (~g[w[X + y][12]] & g[w[K[6]][13]] & K[5])
              k[1] = w[K[6]][13];
            else if (~g[w[X + y][13]] & g[w[K[6]][12]] & K[5])
              k[1] = w[K[6]][12];
          }
#if RJ > 2
          k[50] = k[1] + 1 ? 6 : 2;
          A[0][0] = X + y;
#endif
          if (B[g[K[0]]] < 3)
          {
            Z = w[Y + y][K[8]];
            L = 0;
            if ((ERI (Z) & K[5]) || ((L = 9) && (ERI (Z + L) & K[5])) ||
              ((L = 18) && (ERI (Z + L) & K[5])))
            {
              if (g[w[K[2]][K[8]] + L] & K[5])
              k[2] = w[K[2]][K[8]] + L;
              if (~g[w[Z + L][6]] & g[w[Y + y][7]] & K[5])
                k[3] = w[Y + y][7];
              else if (~g[w[Z + L][7]] & g[w[Y + y][6]] & K[5])
                k[3] = w[Y + y][6];
            }
            else if (((L = 12) && (ERI (w[Y + y][L]) & K[5])) ||
              ((L = 13) && (ERI (w[Y + y][L]) & K[5])))
            {
              if ((g[M = w[K[2]][L]] | g[w[M][6]] | g[w[M][7]]) & K[5])
              {
                k[2] = M;
                k[3] = w[M][6];
                k[4] = w[M][7];
              }
#if RJ > 2
              A[1][0] = w[Y + y][L];
#endif
            }
          }
          if ((k[0] & k[1] & k[2] & k[3]) + 1)
            goto XYWT1Tf;
        }
        X = w[K[2]][K[8]];
        Y = w[K[0]][K[8]];
        y = 0;
        if ((ERI (X) & K[5]) || ((y = 9) && (ERI (X + y) & K[5])) ||
          ((y = 18) && (ERI (X + y) & K[5])))
        {                    // ERI 04, 12, 28, Reduced ERI 08, 16, 20, 24, 32
          if (g[Y + y] & K[5])
            k[0] = Y + y;
          if (B[g[K[0]]] < 3)
          {                  // Reduced ERI 08
            if (~g[w[X + y][6]] & g[w[K[6]][7]] & K[5])
              k[1] = w[K[6]][7];
            else if (~g[w[X + y][7]] & g[w[K[6]][6]] & K[5])
              k[1] = w[K[6]][6];
          }
#if RJ > 2
          k[50] = k[1] + 1 ? 6 : 2;
          A[0][0] = X + y;
#endif
          Z = w[Y + y][K[7]];
          L = 0;
          if ((ERI (Z) & K[5]) || ((L = 1) && (ERI (Z + L) & K[5])) ||
            ((L = 2) && (ERI (Z + L) & K[5])))
          {
            if (B[g[K[0]]] < 3 && (g[w[K[4]][K[7]] + L] & K[5]))
              k[2] = w[K[4]][K[7]] + L;
            if (~g[w[Z + L][12]] & g[w[Y + y][13]] & K[5])
              k[3] = w[Y + y][13];
            else if (~g[w[Z + L][13]] & g[w[Y + y][12]] & K[5])
              k[3] = w[Y + y][12];
          }
          else if (B[g[K[0]]] < 3 && (((L = 6) && (ERI (w[Y + y][L]) & K[5])) ||
            ((L = 7) && (ERI (w[Y + y][L]) & K[5]))))
          {
            if ((g[M = w[K[4]][L]] | g[w[M][12]] | g[w[M][13]]) & K[5])
            {
              k[2] = M;
              k[3] = w[M][12];
              k[4] = w[M][13];
            }
#if RJ > 2
            A[1][0] = w[Y + y][L];
#endif
          }
          if ((k[0] & k[1] & k[2] & k[3]) + 1)
            goto XYWT1Tf;
        }
*/
        for (y = 0; y < 3; ++y)
        {
/**/
          X = w[K[0]][K[7] + y];
          Y = w[K[4]][K[7] + y];
          Z = w[X][K[8]];
          if (ERI (X) & K[5])
          {                  // ERI 01, 09, 25, Reduced ERI 05, 13, 17, 21, 29
            if (g[Y] & K[5])
              k[0] = Y;
            if (~g[w[X][12]] & g[w[K[0]][13]] & K[5])
              k[1] = w[K[0]][13];
            else if (~g[w[X][13]] & g[w[K[0]][12]] & K[5])
              k[1] = w[K[0]][12];
#if RJ > 2
            k[50] = k[1] + 1 ? 6 : 2;
            A[0][0] = X;
#endif
            L = 0;
            if ((ERI (Z) & K[5]) || ((L = 9) && (ERI (Z + L) & K[5])) ||
              ((L = 18) && (ERI (Z + L) & K[5])))
            {
              if (g[w[K[0]][K[8]] + L] & K[5])
                k[2] = w[K[0]][K[8]] + L;
              if (~g[w[Z + L][6]] & g[w[Y][7]] & K[5])
                k[3] = w[Y][7];
              else if (~g[w[Z + L][7]] & g[w[Y][6]] & K[5])
                k[3] = w[Y][6];
#if RJ > 2
            if (k[3] + 1)
              k[50] = 6;
            A[1][0] = Z + L;
#endif
            }
            else if (((L = 12) && (ERI (w[Y][L]) & K[5])) ||
              ((L = 13) && (ERI (w[Y][L]) & K[5])))
            {
              if ((g[M = w[K[4]][L]] | g[w[M][6]] | g[w[M][7]]) & K[5])
              {
                k[2] = M;
                k[3] = w[M][6];
                k[4] = w[M][7];
              }
#if RJ > 2
              A[1][0] = w[Y][L];
#endif
            }
            if ((k[0] & k[1] & k[2] & k[3]) + 1)
              goto XYWT1Tf;
          }
          X = w[K[0]][K[8] + y];
          Y = w[K[2]][K[8] + y];
          Z = w[X][K[7]];
          if (ERI (X) & K[5])
          {                  // ERI 02, 10, 26, Reduced ERI 06, 14, 18, 22, 30
            if (g[Y] & K[5])
              k[0] = Y;
            if (~g[w[X][6]] & g[w[K[0]][7]] & K[5])
              k[1] = w[K[0]][7];
            else if (~g[w[X][7]] & g[w[K[0]][6]] & K[5])
              k[1] = w[K[0]][6];
#if RJ > 2
            k[50] = k[1] + 1 ? 6 : 2;
            A[0][0] = X;
#endif
            L = 0;
            if ((ERI (Z) & K[5]) || ((L = 1) && (ERI (Z + L) & K[5])) ||
              ((L = 2) && (ERI (Z + L) & K[5])))
            {
              if (g[w[K[0]][K[7]] + L] & K[5])
                k[2] = w[K[0]][K[7]] + L;
              if (~g[w[Z + L][12]] & g[w[Y][13]] & K[5])
                k[3] = w[Y][13];
              else if (~g[w[Z + L][13]] & g[w[Y][12]] & K[5])
                k[3] = w[Y][12];
            }
            else if (((L = 6) && (ERI (w[Y][L]) & K[5])) ||
              ((L = 7) && (ERI (w[Y][L]) & K[5])))
            {
              if ((g[M = w[K[2]][L]] | g[w[M][12]] | g[w[M][13]]) & K[5])
              {
                k[2] = M;
                k[3] = w[M][12];
                k[4] = w[M][13];
              }
#if RJ > 2
              A[1][0] = w[Y][L];
#endif
            }
            if ((k[0] & k[1] & k[2] & k[3]) + 1)
              goto XYWT1Tf;
          }
          X = w[K[4]][K[7] + y];
          Y = w[K[0]][K[7] + y];
          Z = w[Y][K[8]];
          if (ERI (X) & K[5])
          {                  // ERI 03, 11, 27, Reduced ERI 07, 15, 19, 23, 31
            if (g[Y] & K[5])
              k[0] = Y;
            if (B[g[K[0]]] < 3)
            {                // Reduced ERI 07
              if (~g[w[X][12]] & g[w[K[6]][13]] & K[5])
                k[1] = w[K[6]][13];
              else if (~g[w[X][13]] & g[w[K[6]][12]] & K[5])
                k[1] = w[K[6]][12];
            }
#if RJ > 2
            k[50] = k[1] + 1 ? 6 : 2;
            A[0][0] = X;
#endif
            if (B[g[K[0]]] < 3)
            {
              L = 0;
              if ((ERI (Z) & K[5]) || ((L = 9) && (ERI (Z + L) & K[5])) ||
                ((L = 18) && (ERI (Z + L) & K[5])))
              {
                if (g[w[K[2]][K[8]] + L] & K[5])
                  k[2] = w[K[2]][K[8]] + L;
                if (~g[w[Z + L][6]] & g[w[Y][7]] & K[5])
                  k[3] = w[Y][7];
                else if (~g[w[Z + L][7]] & g[w[Y][6]] & K[5])
                  k[3] = w[Y][6];
              }
              else if (((L = 12) && (ERI (w[Y][L]) & K[5])) ||
                ((L = 13) && (ERI (w[Y][L]) & K[5])))
              {
                if ((g[M = w[K[2]][L]] | g[w[M][6]] | g[w[M][7]]) & K[5])
                {
                  k[2] = M;
                  k[3] = w[M][6];
                  k[4] = w[M][7];
                }
#if RJ > 2
                A[1][0] = w[Y][L];
#endif
              }
            }
            if ((k[0] & k[1] & k[2] & k[3]) + 1)
              goto XYWT1Tf;
          }
          X = w[K[2]][K[8] + y];
          Y = w[K[0]][K[8] + y];
          Z = w[Y][K[7]];
          if (ERI (X) & K[5])
          {                  // ERI 04, 12, 28, Reduced ERI 08, 16, 20, 24, 32
            if (g[Y] & K[5])
              k[0] = Y;
            if (B[g[K[0]]] < 3)
            {                // Reduced ERI 08
              if (~g[w[X][6]] & g[w[K[6]][7]] & K[5])
                k[1] = w[K[6]][7];
              else if (~g[w[X][7]] & g[w[K[6]][6]] & K[5])
                k[1] = w[K[6]][6];
            }
#if RJ > 2
            k[50] = k[1] + 1 ? 6 : 2;
            A[0][0] = X;
#endif
            L = 0;
            if ((ERI (Z) & K[5]) || ((L = 1) && (ERI (Z + L) & K[5])) ||
              ((L = 2) && (ERI (Z + L) & K[5])))
            {
              if (B[g[K[0]]] < 3 && (g[w[K[4]][K[7]] + L] & K[5]))
                k[2] = w[K[4]][K[7]] + L;
              if (~g[w[Z + L][12]] & g[w[Y][13]] & K[5])
                k[3] = w[Y][13];
              else if (~g[w[Z + L][13]] & g[w[Y][12]] & K[5])
                k[3] = w[Y][12];
            }
            else if (B[g[K[0]]] < 3 && (((L = 6) && (ERI (w[Y][L]) & K[5])) ||
              ((L = 7) && (ERI (w[Y][L]) & K[5]))))
            {
              if ((g[M = w[K[4]][L]] | g[w[M][12]] | g[w[M][13]]) & K[5])
              {
                k[2] = M;
                k[3] = w[M][12];
                k[4] = w[M][13];
              }
#if RJ > 2
              A[1][0] = w[Y][L];
#endif
            }
            if ((k[0] & k[1] & k[2] & k[3]) + 1)
              goto XYWT1Tf;
          }
/**/
          for (Y = 0; Y < 2; ++Y)
          {
            if (((N = LN1 (w[K[2]][K[8] + y], w[M = w[K[0]][K[8] + y]][6 | Y],
              w[M][K[7]], 0) & K[5]) || (ERI (X) & ERI (Z) & K[5])) &&
              (((N ? g[w[M][12]] | g[w[M][13]] : g[M]) | (B[g[K[0]]] > 2 ? 0 :
              g[L = w[K[4]][6 | Y]] | g[w[L][12]] | g[w[L][13]])) & K[5]))
            {                // Line 37, ERI 41
              if (N)
              {              // Line 37
                k[0] = w[M][12];
                k[1] = w[M][13];
              }
              else           // ERI 41
                k[0] = M;
              if (B[g[K[0]]] < 3)
              {
                k[2] = L;
                k[3] = w[L][12];
                k[4] = w[L][13];
              }
#if RJ > 2
              k[50] = N ? 0 : 2;
              A[0][0] = X;
              A[1][0] = Z;
#endif
              goto XYWT1Tf;
            }
            if (((N = LN1 (w[K[4]][K[7] + y], w[M = w[K[0]][K[7] + y]][12 | Y],
              w[M][K[8]], 1) & K[5]) || (ERI (X) & ERI (Z) & K[5])) &&
              (((N ? g[w[M][6]] | g[w[M][7]] : g[M]) | (B[g[K[0]]] > 2 ? 0 :
              g[L = w[K[2]][12 | Y]] | g[w[L][6]] | g[w[L][7]])) & K[5]))
            {                // Line 38, ERI 42
              if (N)
              {              // Line 38
                k[0] = w[M][6];
                k[1] = w[M][7];
              }
              else           // ERI 42
                k[0] = M;
              if (B[g[K[0]]] < 3)
              {
                k[2] = L;
                k[3] = w[L][6];
                k[4] = w[L][7];
              }
#if RJ > 2
              k[50] = N ? 0 : 2;
              A[0][0] = X;
              A[1][0] = Z;
#endif
              goto XYWT1Tf;
            }
            if (((N = LN1 (w[K[0]][K[8] + y], w[M = w[K[2]][K[8] + y]][6 | Y],
              w[X][K[7]], 0) & K[5]) || (ERI (X) & ERI (Z) & K[5])) &&
              (((N ? g[w[M][12]] | g[w[M][13]] : g[M]) |
              g[L = w[K[2]][6 | Y]] | g[w[L][12]] | g[w[L][13]]) & K[5]))
            {                // Line 39, ERI 43
              if (N)
              {              // Line 39
                k[0] = w[M][12];
                k[1] = w[M][13];
              }
              else           // ERI 43
                k[0] = M;
              k[2] = L;
              k[3] = w[L][12];
              k[4] = w[L][13];
#if RJ > 2
              k[50] = N ? 0 : 2;
              A[0][0] = X;
              A[1][0] = Z;
#endif
              goto XYWT1Tf;
            }
            if (((N = LN1 (w[K[0]][K[7] + y], w[M = w[K[4]][K[7] + y]][12 | Y],
              w[X][K[8]], 1) & K[5]) || (ERI (X) & ERI (Z) & K[5])) &&
              (((N ? g[w[M][6]] | g[w[M][7]] : g[M]) |
              g[L = w[K[4]][12 | Y]] | g[w[L][6]] | g[w[L][7]]) & K[5]))
            {                // Line 40, ERI 44
              if (N)
              {              // Line 40
                k[0] = w[M][6];
                k[1] = w[M][7];
              }
              else           // ERI 44
                k[0] = M;
              k[2] = L;
              k[3] = w[L][6];
              k[4] = w[L][7];
#if RJ > 2
              k[50] = N ? 0 : 2;
              A[0][0] = X;
              A[1][0] = Z;
#endif
              goto XYWT1Tf;
            }
          }
          for (Y = 0; Y < 3; ++Y)
            if (((g[L = w[K[0]][K[8] + Y]] & K[5]) &&
              ((N = LN1 (w[K[0]][K[7] + y], w[X][K[8] + Y],
              w[K[4]][K[7] + y], 1) & K[5]) || (ERI (X) & ERI (Z) & K[5]))) ||
              ((g[L = w[K[0]][K[7] + Y]] & K[5]) &&
              ((N = LN1 (w[K[0]][K[8] + y], w[X][K[7] + Y],
              w[K[2]][K[8] + y], 0) & K[5]) || (ERI (X) & ERI (Z) & K[5]))) ||
              (B[g[K[0]]] < 3 && (g[L = w[K[2]][K[8] + Y]] & K[5]) &&
              ((N = LN1 (w[K[4]][K[7] + y], w[w[K[0]][K[7] + y]][K[8] + Y],
              w[K[0]][K[7] + y], 1) & K[5]) || (ERI (X) & ERI (Z) & K[5]))) ||
              (B[g[K[0]]] < 3 && (g[L = w[K[4]][K[7] + Y]] & K[5]) &&
              ((N = LN1 (w[K[2]][K[8] + y], w[w[K[0]][K[8] + y]][K[7] + Y],
              w[K[0]][K[8] + y], 0) & K[5]) || (ERI (X) & ERI (Z) & K[5]))))
            {                // Line 45, 46, 47, 48, ERI 49, 50, 51, 52
              k[0] = L;
#if RJ > 2
              k[50] = N ? 0 : 2;
              A[0][0] = X;
              A[1][0] = Z;
#endif
              goto XYWT1Tf;
            }
          if (((N = LN1 (w[K[0]][K[8] + y], w[K[2]][K[8] + y], w[X][K[7]], 0) & K[5]) ||
            (ERI (X) & ERI (Z) & K[5])) &&
            (((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
            (N ? g[w[X][12]] | g[w[X][13]] | g[w[Z][12]] | g[w[Z][13]] :
            g[X] | g[Z] | g[L = w[X][K[7]]] | g[w[L][6]] | g[w[L][7]]) |
            g[w[K[2]][12]] | g[w[K[2]][13]] | g[K[6]] | g[w[K[6]][12]] | g[w[K[6]][13]]) & K[5]) ||
            ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
            g[w[K[0]][K[7]]] | g[w[w[K[0]][K[7]]][6]] | g[w[w[K[0]][K[7]]][7]]) & (g[K[2]] ^ K[5])) ||
            ((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
            g[X] | g[w[X][12]] | g[w[X][13]]) & (g[K[4]] ^ K[5]))))
          {                  // Line Ring 53, ERI Ring 55
            if (B[g[K[0]]] > 2)
              k[0] = K[6];
            k[1] = w[K[6]][12];
            k[2] = w[K[6]][13];
            k[5] = w[K[2]][12];
            k[10] = w[K[2]][13];
            k[11] = w[K[4]][12];
            k[12] = w[K[4]][13];
            k[13] = w[K[0]][12];
            k[14] = w[K[0]][13];
#if RJ > 2
            k[50] = N ? 8 : 10;
            A[0][0] = X;
            A[1][0] = Z;
#endif
            if (N)
            {                // Line Ring 53
              k[3] = w[Z][12];
              k[4] = w[Z][13];
              k[6] = w[X][12];
              k[7] = w[X][13];
            }
            else
            {                // ERI Ring 55
              k[3] = Z;
              k[4] = X;
              k[6] = L;
              k[7] = w[L][6];
              k[9] = w[L][7];
            }
            goto XYWT1Tf;
          }
          if (((N = LN1 (w[K[0]][K[7] + y], w[K[4]][K[7] + y], w[X][K[8]], 1) & K[5]) ||
            (ERI (X) & ERI (Z) & K[5])) &&
            (((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[4]][6]] | g[w[K[4]][7]] |
            (N ? g[w[X][6]] | g[w[X][7]] | g[w[Z][6]] | g[w[Z][7]] :
            g[X] | g[Z] | g[L = w[X][K[8]]] | g[w[L][12]] | g[w[L][13]]) |
            g[w[K[2]][6]] | g[w[K[2]][7]] | g[K[6]] | g[w[K[6]][6]] | g[w[K[6]][7]]) & K[5]) ||
            ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
            g[X] | g[w[X][6]] | g[w[X][7]]) & (g[K[2]] ^ K[5])) ||
            ((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
            g[w[K[0]][K[8]]] | g[w[w[K[0]][K[8]]][12]] | g[w[w[K[0]][K[8]]][13]]) & (g[K[4]] ^ K[5]))))
          {                  // Line Ring 54, ERI Ring 56
            if (B[g[K[0]]] > 2)
              k[0] = K[6];
            k[1] = w[K[6]][6];
            k[2] = w[K[6]][7];
            k[5] = w[K[4]][6];
            k[10] = w[K[4]][7];
            k[11] = w[K[2]][6];
            k[12] = w[K[2]][7];
            k[13] = w[K[0]][6];
            k[14] = w[K[0]][7];
#if RJ > 2
            k[50] = N ? 8 : 10;
            A[0][0] = X;
            A[1][0] = Z;
#endif
            if (N)
            {                // Line Ring 54
              k[3] = w[Z][6];
              k[4] = w[Z][7];
              k[6] = w[X][6];
              k[7] = w[X][7];
            }
            else
            {                // ERI Ring 56
              k[3] = Z;
              k[4] = X;
              k[6] = L;
              k[7] = w[L][12];
              k[9] = w[L][13];
            }
            goto XYWT1Tf;
          }
        }
        for (y = 0; y < 2; ++y)
        {
          if ((N = LB3 (w[K[0]][12 | y], w[K[2]][12 | y], w[X][K[7]], 0) & K[5]) ||
            LB3 (w[K[0]][K[7]], w[X][13 ^ y], w[X][12 | y], 0) & K[5])
          {                  // Box 09, Line 13, 25, Reduced Line Ring 17, 21
            if (g[w[K[0]][13 ^ y]] & K[5])
              k[0] = w[K[0]][13 ^ y];
#if RJ > 2
            k[50] = !N;
            A[0][0] = X;
            A[0][1] = w[X][6];
            A[0][2] = w[X][7];
            A[1][0] = Z;
            A[1][1] = w[Z][6];
            A[1][2] = w[Z][7];
#endif
            if (N)
            {
              if ((~(g[w[X][6]] | g[w[X][7]]) & K[5]) &&
                (((g[L = w[K[0]][K[8]]] | g[w[L][12]] | g[w[L][13]] |
                g[w[K[4]][12]] | g[w[K[4]][13]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
                g[M = w[K[2]][13 ^ y]] | g[w[M][6]] | g[w[M][7]] |
                ((g[w[Z][6]] | g[w[Z][7]]) & K[5] ? 0 :
                g[Y = w[K[2]][K[8]]] | g[w[Y][12]] | g[w[Y][13]] |
                g[K[6]] | g[w[K[6]][12]] | g[w[K[6]][13]])) & K[5]) ||
                ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
                g[Y = w[K[0]][K[7]]] | g[w[Y][6]] | g[w[Y][7]]) & (g[K[2]] ^ K[5])) ||
                ((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
                g[Y = w[K[0]][K[8]]] | g[w[Y][12]] | g[w[Y][13]]) & (g[K[4]] ^ K[5]))))
              {              // Reduced Line Ring 17, 21
                k[1] = L;
                k[2] = w[L][12];
                k[3] = w[L][13];
                k[5] = w[K[2]][6];
                k[10] = w[K[2]][7];
                k[11] = M;
                k[12] = w[M][6];
                k[13] = w[M][7];
                k[14] = w[K[4]][12];
                k[6] = w[K[4]][13];
#if RJ > 2
                k[50] = 12;
                A[0][1] = -1;
#endif
                if (~(g[w[Z][6]] | g[w[Z][7]]) & K[5])
                {            // Reduced Line Ring 21
                  k[7] = w[K[2]][K[8]];
                  k[8] = w[k[7]][12];
                  k[15] = w[k[7]][13];
                  k[16] = w[K[6]][12];
                  k[17] = w[K[6]][13];
                  if (B[g[K[0]]] > 2)
                    k[9] = K[6];
#if RJ > 2
                  A[1][1] = -1;
#endif
                }
              }
              else if (B[g[K[0]]] < 3 && (~g[X] & K[5]) &&
                (((g[Y = w[K[4]][L = 6]] | g[w[Y][12]] | g[w[Y][13]]) &
                ~g[w[X][7]] & K[5]) ||
                ((g[Y = w[K[4]][L = 7]] | g[w[Y][12]] | g[w[Y][13]]) &
                ~g[w[X][6]] & K[5])))
              {              // Line 25
                k[1] = Y;
                k[2] = w[Y][12];
                k[3] = w[Y][13];
#if RJ > 2
                A[0][0] = w[X][L];
                A[0][1] = -1;
#endif
              }
            }
          }
          else if (B[g[K[0]]] < 3 &&
            (LB3 (w[K[2]][12 | y], w[w[K[0]][12 | y]][K[7]], w[K[0]][12 | y], 0) & K[5]) &&
            ((g[w[K[4]][L = K[7]]] & ~(g[w[Z][6]] | g[w[Z][7]]) & K[5]) ||
            (g[w[K[4]][++L]] & ~(g[Z] | g[w[Z][7]]) & K[5]) ||
            (g[w[K[4]][++L]] & ~(g[Z] | g[w[Z][6]]) & K[5])))
          {                  // Line 29
            k[0] = w[K[4]][L];
#if RJ > 2
            A[0][0] = w[w[K[0]][12 | y]][L];
            A[1][0] = X;
            A[1][1] = w[X][6];
            A[1][2] = w[X][7];
#endif
          }
          else if ((g[Y = w[K[0]][K[7]]] | g[w[Y][6]] | g[w[Y][7]]) &
            LN3 (w[K[0]][12 | y], w[X][K[7]], w[K[2]][12 | y], 0) & K[5])
          {                  // Line 33
            k[0] = Y;
            k[1] = w[Y][6];
            k[2] = w[Y][7];
#if RJ > 2
            A[0][0] = Z;
            A[1][0] = X;
            A[1][1] = w[X][6];
            A[1][2] = w[X][7];
#endif
          }
          if ((k[0] & k[1]) + 1)
            goto XYWT1Tf;
          if ((N = LB3 (w[K[0]][6 | y], w[K[4]][6 | y], w[X][K[8]], 1) & K[5]) ||
            LB3 (w[K[0]][K[8]], w[X][7 ^ y], w[X][6 | y], 1) & K[5])
          {                  // Box 10, Line 14, 26, Reduced Line Ring 18, 22
            if (g[w[K[0]][7 ^ y]] & K[5])
              k[0] = w[K[0]][7 ^ y];
#if RJ > 2
            k[50] = !N;
            A[0][0] = X;
            A[0][1] = w[X][12];
            A[0][2] = w[X][13];
            A[1][0] = Z;
            A[1][1] = w[Z][12];
            A[1][2] = w[Z][13];
#endif
            if (N)
            {
              if ((~(g[w[X][12]] | g[w[X][13]]) & K[5]) &&
                (((g[L = w[K[0]][K[7]]] | g[w[L][6]] | g[w[L][7]] |
                g[w[K[2]][6]] | g[w[K[2]][7]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
                g[M = w[K[4]][7 ^ y]] | g[w[M][12]] | g[w[M][13]] |
                ((g[w[Z][12]] | g[w[Z][13]]) & K[5] ? 0 :
                g[Y = w[K[4]][K[7]]] | g[w[Y][6]] | g[w[Y][7]] |
                g[K[6]] | g[w[K[6]][6]] | g[w[K[6]][7]])) & K[5]) ||
                ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
                g[Y = w[K[0]][K[7]]] | g[w[Y][6]] | g[w[Y][7]]) & (g[K[2]] ^ K[5])) ||
                ((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
                g[Y = w[K[0]][K[8]]] | g[w[Y][12]] | g[w[Y][13]]) & (g[K[4]] ^ K[5]))))
              {              // Reduced Line Ring 18, 22
                k[1] = L;
                k[2] = w[L][6];
                k[3] = w[L][7];
                k[5] = w[K[2]][6];
                k[10] = w[K[2]][7];
                k[11] = M;
                k[12] = w[M][12];
                k[13] = w[M][13];
                k[14] = w[K[4]][12];
                k[6] = w[K[4]][13];
#if RJ > 2
                k[50] = 12;
                A[0][1] = -1;
#endif
                if (~(g[w[Z][12]] | g[w[Z][13]]) & K[5])
                {            // Reduced Line Ring 22
                  k[7] = w[K[4]][K[7]];
                  k[8] = w[k[7]][6];
                  k[15] = w[k[7]][7];
                  k[16] = w[K[6]][6];
                  k[17] = w[K[6]][7];
                  if (B[g[K[0]]] > 2)
                    k[9] = K[6];
#if RJ > 2
                  A[1][1] = -1;
#endif
                }
              }
              else if (B[g[K[0]]] < 3 && (~g[X] & K[5]) &&
                (((g[Y = w[K[2]][L = 12]] | g[w[Y][6]] | g[w[Y][7]]) &
                ~g[w[X][13]] & K[5]) ||
                ((g[Y = w[K[2]][L = 13]] | g[w[Y][6]] | g[w[Y][7]]) &
                ~g[w[X][12]] & K[5])))
              {              // Line 26
                k[1] = Y;
                k[2] = w[Y][6];
                k[3] = w[Y][7];
#if RJ > 2
                A[0][0] = w[X][L];
                A[0][1] = -1;
#endif
              }
            }
          }
          else if (B[g[K[0]]] < 3 &&
            (LB3 (w[K[4]][6 | y], w[w[K[0]][6 | y]][K[8]], w[K[0]][6 | y], 1) & K[5]) &&
            ((g[w[K[2]][L = K[8]]] & ~(g[w[Z][12]] | g[w[Z][13]]) & K[5]) ||
            (g[w[K[2]][++L]] & ~(g[Z] | g[w[Z][13]]) & K[5]) ||
            (g[w[K[2]][++L]] & ~(g[Z] | g[w[Z][12]]) & K[5])))
          {                  // Line 30
            k[0] = w[K[2]][L];
#if RJ > 2
            A[0][0] = w[w[K[0]][6 | y]][L];
            A[1][0] = X;
            A[1][1] = w[X][12];
            A[1][2] = w[X][13];
#endif
          }
          else if ((g[Y = w[K[0]][K[8]]] | g[w[Y][12]] | g[w[Y][13]]) &
            LN3 (w[K[0]][6 | y], w[X][K[8]], w[K[4]][6 | y], 1) & K[5])
          {                  // Line 34
            k[0] = Y;
            k[1] = w[Y][12];
            k[2] = w[Y][13];
#if RJ > 2
            A[0][0] = Z;
            A[1][0] = X;
            A[1][1] = w[X][12];
            A[1][2] = w[X][13];
#endif
          }
          if ((k[0] & k[1]) + 1)
            goto XYWT1Tf;
          if ((N = LB3 (w[K[6]][12 | y], w[K[4]][12 | y], w[Z][K[7]], 0) & K[5]) ||
           (B[g[K[0]]] < 3 && LB3 (w[K[4]][K[7]], w[X][13 ^ y], w[X][12 | y], 0) & K[5]))
          {                  // Box 11, Line 15, 27, Reduced Line Ring 19, 23
            if (B[g[K[0]]] < 3 && (g[w[K[6]][13 ^ y]] & K[5]))
              k[0] = w[K[6]][13 ^ y];
#if RJ > 2
            k[50] = !N;
            A[0][0] = X;
            A[0][1] = w[X][6];
            A[0][2] = w[X][7];
            A[1][0] = Z;
            A[1][1] = w[Z][6];
            A[1][2] = w[Z][7];
#endif
            if (N)
            {
              if ((~(g[w[X][6]] | g[w[X][7]]) & K[5]) &&
                (((g[L = w[K[2]][K[8]]] | g[w[L][12]] | g[w[L][13]] |
                g[w[K[2]][12]] | g[w[K[2]][13]] | g[M = w[K[4]][13 ^ y]] |
                (B[g[K[0]]] > 2 ? g[K[6]] : g[w[M][6]] | g[w[M][7]] |
                g[w[K[4]][6]] | g[w[K[4]][7]]) | g[N = w[K[6]][13 ^ y]] |
                ((g[w[Z][6]] | g[w[Z][7]]) & K[5] ? 0 :
                g[Y = w[K[0]][K[8]]] | g[w[Y][12]] | g[w[Y][13]] |
                g[w[K[0]][12]] | g[w[K[0]][13]])) & K[5]) ||
                ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
                g[Y = w[K[0]][K[7]]] | g[w[Y][6]] | g[w[Y][7]]) & (g[K[2]] ^ K[5])) ||
                ((g[w[K[4]][12]] | g[w[K[4]][13]] | g[w[K[0]][12]] | g[w[K[0]][13]] |
                g[Y = w[K[0]][K[8]]] | g[w[Y][12]] | g[w[Y][13]]) & (g[K[4]] ^ K[5]))))
              {              // Reduced Line Ring 19, 23
                if (B[g[K[0]]] < 3 || (~(g[w[Z][6]] | g[w[Z][7]]) & K[5]))
                {
                  if (B[g[K[0]]] < 3)
                  {
                    k[1] = w[M][6];
                    k[2] = w[M][7];
                    k[3] = w[K[4]][6];
                    k[4] = w[K[4]][7];
                  }
                  else
                    k[1] = K[6];
                  k[5] = M;
                  k[10] = N;
                  k[11] = L;
                  k[12] = w[L][12];
                  k[13] = w[L][13];
                  k[14] = w[K[2]][12];
                  k[6] = w[K[2]][13];
#if RJ > 2
                  k[50] = 12;
                  A[0][1] = -1;
#endif
                }
                if (~(g[w[Z][6]] | g[w[Z][7]]) & K[5])
                {            // Reduced Line Ring 23
                  k[7] = w[K[0]][K[8]];
                  k[8] = w[k[7]][12];
                  k[15] = w[k[7]][13];
                  k[16] = w[K[0]][12];
                  k[17] = w[K[0]][13];
#if RJ > 2
                  k[50] = 12;
                  A[1][1] = -1;
#endif
                }
              }
              else if (B[g[K[0]]] < 3 && (~g[X] & K[5]) &&
                (((g[Y = w[K[2]][L = 6]] | g[w[Y][12]] | g[w[Y][13]]) &
                ~g[w[X][7]] & K[5]) ||
                ((g[Y = w[K[2]][L = 7]] | g[w[Y][12]] | g[w[Y][13]]) &
                ~g[w[X][6]] & K[5])))
              {              // Line 27
                k[1] = Y;
                k[2] = w[Y][12];
                k[3] = w[Y][13];
#if RJ > 2
                A[0][0] = w[X][L];
                A[0][1] = -1;
#endif
              }
            }
          }
          else if (B[g[K[0]]] < 3 &&
            (LB3 (w[K[4]][12 | y], w[X][K[7]], w[K[6]][12 | y], 0) & K[5]) &&
            ((g[w[K[0]][L = K[7]]] & ~(g[w[Z][6]] | g[w[Z][7]]) & K[5]) ||
            (g[w[K[0]][++L]] & ~(g[Z] | g[w[Z][7]]) & K[5]) ||
            (g[w[K[0]][++L]] & ~(g[Z] | g[w[Z][6]]) & K[5])))
          {                  // Line 31
            k[0] = w[K[0]][L];
#if RJ > 2
            A[0][0] = w[X][L];
            A[1][0] = X;
            A[1][1] = w[X][6];
            A[1][2] = w[X][7];
#endif
          }
          else if (B[g[K[0]]] < 3 &&
            (g[Y = w[K[4]][K[7]]] | g[w[Y][6]] | g[w[Y][7]]) &
            LN3 (w[K[6]][12 | y], w[w[K[4]][12 | y]][K[7]], w[K[4]][12 | y], 0) & K[5])
          {                  // Line 35
            k[0] = Y;
            k[1] = w[Y][6];
            k[2] = w[Y][7];
#if RJ > 2
            A[0][0] = X;
            A[1][0] = Z;
            A[1][1] = w[Z][6];
            A[1][2] = w[Z][7];
#endif
          }
          if ((k[0] & k[1]) + 1)
            goto XYWT1Tf;
          if ((N = LB3 (w[K[6]][6 | y], w[K[2]][6 | y], w[Z][K[8]], 1) & K[5]) ||
            (B[g[K[0]]] < 3 && LB3 (w[K[2]][K[8]], w[X][7 ^ y], w[X][6 | y], 1) & K[5]))
          {                  // Box 12, Line 16, 28, Reduced Line Ring 20, 24
            if (B[g[K[0]]] < 3 && (g[w[K[6]][7 ^ y]] & K[5]))
              k[0] = w[K[6]][7 ^ y];
#if RJ > 2
            k[50] = !N;
            A[0][0] = X;
            A[0][1] = w[X][12];
            A[0][2] = w[X][13];
            A[1][0] = Z;
            A[1][1] = w[Z][12];
            A[1][2] = w[Z][13];
#endif
            if (N)
            {
              if ((~(g[w[X][12]] | g[w[X][13]]) & K[5]) &&
                (((g[L = w[K[4]][K[7]]] | g[w[L][6]] | g[w[L][7]] |
                g[w[K[4]][6]] | g[w[K[4]][7]] | g[M = w[K[2]][7 ^ y]] |
                g[N = w[K[6]][7 ^ y]] | (B[g[K[0]]] > 2 ? g[K[6]] :
                g[w[M][12]] | g[w[M][13]] | g[w[K[2]][12]] | g[w[K[2]][13]]) |
                ((g[w[Z][12]] | g[w[Z][13]]) & K[5] ? 0 :
                g[Y = w[K[0]][K[7]]] | g[w[Y][6]] | g[w[Y][7]] |
                g[w[K[0]][6]] | g[w[K[0]][7]])) & K[5]) ||
                ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
                g[Y = w[K[0]][K[7]]] | g[w[Y][6]] | g[w[Y][7]]) & (g[K[2]] ^ K[5])) ||
                ((g[w[K[4]][12]] | g[w[K[4]][13]] | g[w[K[0]][12]] | g[w[K[0]][13]] |
                g[Y = w[K[0]][K[8]]] | g[w[Y][12]] | g[w[Y][13]]) & (g[K[4]] ^ K[5]))))
              {              // Reduced Line Ring 20, 24
                if (B[g[K[0]]] < 3 || (~(g[w[Z][12]] | g[w[Z][13]]) & K[5]))
                {
                  if (B[g[K[0]]] < 3)
                  {
                    k[1] = w[M][12];
                    k[2] = w[M][13];
                    k[3] = w[K[2]][12];
                    k[4] = w[K[2]][13];
                  }
                  else
                    k[1] = K[6];
                  k[5] = M;
                  k[10] = N;
                  k[11] = L;
                  k[12] = w[L][6];
                  k[13] = w[L][7];
                  k[14] = w[K[4]][6];
                  k[6] = w[K[4]][7];
#if RJ > 2
                  k[50] = 12;
                  A[0][1] = -1;
#endif
                }
                if (~(g[w[Z][12]] | g[w[Z][13]]) & K[5])
                {            // Reduced Line Ring 24
                  k[7] = w[K[0]][K[7]];
                  k[8] = w[k[7]][6];
                  k[15] = w[k[7]][7];
                  k[16] = w[K[0]][6];
                  k[17] = w[K[0]][7];
#if RJ > 2
                  k[50] = 12;
                  A[1][1] = -1;
#endif
                }
              }
              else if (B[g[K[0]]] < 3 && (~g[X] & K[5]) &&
                (((g[Y = w[K[4]][L = 12]] | g[w[Y][6]] | g[w[Y][7]]) &
                ~g[w[X][13]] & K[5]) ||
                ((g[Y = w[K[4]][L = 13]] | g[w[Y][6]] | g[w[Y][7]]) &
                ~g[w[X][12]] & K[5])))
              {              // Line 28
                k[1] = Y;
                k[2] = w[Y][6];
                k[3] = w[Y][7];
#if RJ > 2
                A[0][0] = w[X][L];
                A[0][1] = -1;
#endif
              }
            }
          }
          else if (B[g[K[0]]] < 3 &&
            (LB3 (w[K[2]][6 | y], w[X][K[8]], w[K[6]][6 | y], 1) & K[5]) &&
            ((g[w[K[0]][L = K[8]]] & ~(g[w[Z][12]] | g[w[Z][13]]) & K[5]) ||
            (g[w[K[0]][++L]] & ~(g[Z] | g[w[Z][13]]) & K[5]) ||
            (g[w[K[0]][++L]] & ~(g[Z] | g[w[Z][12]]) & K[5])))
          {                  // Line 32
            k[0] = w[K[0]][L];
#if RJ > 2
            A[0][0] = w[X][L];
            A[1][0] = X;
            A[1][1] = w[X][12];
            A[1][2] = w[X][13];
#endif
          }
          else if (B[g[K[0]]] < 3 &&
            (g[Y = w[K[2]][K[8]]] | g[w[Y][12]] | g[w[Y][13]]) &
            LN3 (w[K[6]][6 | y], w[w[K[2]][6 | y]][K[8]], w[K[2]][6 | y], 1) & K[5])
          {                  // Line 36
            k[0] = Y;
            k[1] = w[Y][12];
            k[2] = w[Y][13];
#if RJ > 2
            A[0][0] = X;
            A[1][0] = Z;
            A[1][1] = w[Z][12];
            A[1][2] = w[Z][13];
#endif
          }
          if ((k[0] & k[1]) + 1)
            goto XYWT1Tf;
        }
        if ((ERI (K[0]) & K[5]) &&
          (((g[y = w[K[0]][K[7]]] | g[w[y][6]] | g[w[y][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
          g[Y = w[K[0]][K[8]]] | g[w[Y][12]] | g[w[Y][13]] | g[w[K[4]][12]] | g[w[K[4]][13]]) & K[5]) ||
          ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
          g[y] | g[w[y][6]] | g[w[y][7]]) & (g[K[2]] ^ K[5])) ||
          ((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
          g[Y] | g[w[Y][12]] | g[w[Y][13]]) & (g[K[4]] ^ K[5]))))
        {                    // ERI Ring 57
          k[0] = y;
          k[1] = w[y][6];
          k[2] = w[y][7];
          k[3] = w[K[2]][6];
          k[5] = w[K[2]][7];
          k[10] = Y;
          k[11] = w[Y][12];
          k[12] = w[Y][13];
          k[13] = w[K[4]][12];
          k[14] = w[K[4]][13];
#if RJ > 2
          k[50] = 10;
          A[0][0] = K[0];
#endif
          goto XYWT1Tf;
        }
        if (B[g[K[0]]] < 3 && (ERI (K[6]) & K[5]) &&
          (((g[y = w[K[4]][K[7]]] | g[w[y][6]] | g[w[y][7]] | g[w[K[4]][6]] | g[w[K[4]][7]] |
          g[Y = w[K[2]][K[8]]] | g[w[Y][12]] | g[w[Y][13]] | g[w[K[2]][12]] | g[w[K[2]][13]]) & K[5]) ||
          ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
          g[w[K[0]][K[7]]] | g[w[w[K[0]][K[7]]][6]] | g[w[w[K[0]][K[7]]][7]]) & (g[K[2]] ^ K[5])) ||
          ((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
          g[w[K[0]][K[8]]] | g[w[w[K[0]][K[8]]][12]] | g[w[w[K[0]][K[8]]][13]]) & (g[K[4]] ^ K[5]))))
        {                    // ERI Ring 58
          k[0] = w[K[4]][6];
          k[1] = w[K[4]][7];
          k[2] = y;
          k[3] = w[y][6];
          k[5] = w[y][7];
          k[10] = w[K[2]][12];
          k[11] = w[K[2]][13];
          k[12] = Y;
          k[13] = w[Y][12];
          k[14] = w[Y][13];
#if RJ > 2
          k[50] = 10;
          A[0][0] = K[6];
#endif
          goto XYWT1Tf;
        }
        if (B[g[K[0]]] > 2 && (g[K[6]] & K[5]))
        {                    // Check XYZ-Hybrid Apex Cell Values > two digits; and Wing Cells common Value in Hybrid Cell Values
          if ((g[w[K[0]][6]] | g[w[K[0]][7]] | g[w[K[2]][6]] | g[w[K[2]][7]] |
            g[w[K[0]][K[7]]] | g[w[K[0]][K[7] + 1]] |g[w[K[0]][K[7] + 2]]) &
                             // Check Wing Cells common Value in Apex and 1st Wing Cells Row exclusion Cells Values; and
              ~(g[w[K[2]][12]] | g[w[K[2]][13]] | g[w[K[6]][12]] | g[w[K[6]][13]] |
              g[w[K[2]][K[8]]] | g[w[K[2]][K[8] + 1]] | g[w[K[2]][K[8] + 2]]) & K[5])
          {                  // Wing Cells common Value not in 1st Wing and Hybrid Cells Column other Cells Values
                             // Backup and exclude Wing Cells common Value from XYZ-Hybrid Row wise exclusion Cells Values
            k[0] = g[w[K[0]][6]];
            k[2] = g[w[K[0]][7]];
            k[3] = g[w[K[2]][6]];
            k[4] = g[w[K[2]][7]];
            k[5] = g[w[K[0]][K[7]]];
            k[6] = g[w[K[0]][K[7] + 1]];
            k[7] = g[w[K[0]][K[7] + 2]];
            g[w[K[0]][6]] &= ~K[5];
            g[w[K[0]][7]] &= ~K[5];
            g[w[K[2]][6]] &= ~K[5];
            g[w[K[2]][7]] &= ~K[5];
            g[w[K[0]][K[7]]] &= ~K[5];
            g[w[K[0]][K[7] + 1]] &= ~K[5];
            g[w[K[0]][K[7] + 2]] &= ~K[5];
          }
          if ((g[w[K[0]][12]] | g[w[K[0]][13]] | g[w[K[4]][12]] | g[w[K[4]][13]] |
              g[w[K[0]][K[8]]] | g[w[K[0]][K[8] + 1]] | g[w[K[0]][K[8] + 2]]) &
                             // Check Wing Cells common Value in Apex and 2nd Wing Cells Column exclusion Cells Values; and
            ~(g[w[K[4]][6]] | g[w[K[4]][7]] | g[w[K[6]][6]] | g[w[K[6]][7]] |
            g[w[K[4]][K[7]]] | g[w[K[4]][K[7] + 1]] |g[w[K[4]][K[7] + 2]]) & K[5])
          {                  // Wing Cells common Value not in 2nd Wing and Hybrid Cells Row other Cells Values
                             // Backup and exclude Wing Cells common Value from XYZ-Hybrid Column wise exclusion Cells Values
            k[1] = g[w[K[0]][12]];
            k[8] = g[w[K[0]][13]];
            k[9] = g[w[K[4]][12]];
            k[10] = g[w[K[4]][13]];
            k[11] = g[w[K[0]][K[8]]];
            k[12] = g[w[K[0]][K[8] + 1]];
            k[13] = g[w[K[0]][K[8] + 2]];
            g[w[K[0]][12]] &= ~K[5];
            g[w[K[0]][13]] &= ~K[5];
            g[w[K[4]][12]] &= ~K[5];
            g[w[K[4]][13]] &= ~K[5];
            g[w[K[0]][K[8]]] &= ~K[5];
            g[w[K[0]][K[8] + 1]] &= ~K[5];
            g[w[K[0]][K[8] + 2]] &= ~K[5];
          }
          if ((k[0] & k[1]) + 1)
          {
#if RJ > 2
            printf ("%d)%sXYZ-Hybrid: %d @ %s %s %s %s Hybrid %d @ %s\n=> -%d @",
              p, k[0] + 1 && k[1] + 1 ? " Dual " : " ", b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]],
              k[0] + 1 && k[1] + 1 ? "Dual" : (k[0] + 1 ? "Column wise" : "Row wise"), b[K[5]], S[K[6]], b[K[5]]);
            if (k[0] + 1)
              printf (" %s %s %s %s %s %s %s",
                S[w[K[0]][6]], S[w[K[0]][7]], S[w[K[2]][6]], S[w[K[2]][7]],
                S[w[K[0]][K[7]]], S[w[K[0]][K[7] + 1]], S[w[K[0]][K[7] + 2]]);
            if (k[1] + 1)
              printf (" %s %s %s %s %s %s %s",
                S[w[K[0]][12]], S[w[K[0]][13]], S[w[K[4]][12]], S[w[K[4]][13]],
                S[w[K[0]][K[8]]], S[w[K[0]][K[8] + 1]], S[w[K[0]][K[8] + 2]]);
            printf ("\n");
#endif
            if (solve (p))
              return 1;
#if RJ > 2
            printf ("%d) Undo%sXYZ-Hybrid: %d @ %s %s %s %s Hybrid %d @ %s\n<= +%d @",
              p, k[0] + 1 && k[1] + 1 ? " Dual " : " ", b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]],
              k[0] + 1 && k[1] + 1 ? "Dual" : (k[0] + 1 ? "Column wise" : "Row wise"), b[K[5]], S[K[6]], b[K[5]]);
            if (k[0] + 1)
              printf (" %s %s %s %s %s %s %s",
                S[w[K[0]][6]], S[w[K[0]][7]], S[w[K[2]][6]], S[w[K[2]][7]],
                S[w[K[0]][K[7]]], S[w[K[0]][K[7] + 1]], S[w[K[0]][K[7] + 2]]);
            if (k[1] + 1)
              printf (" %s %s %s %s %s %s %s",
                S[w[K[0]][12]], S[w[K[0]][13]], S[w[K[4]][12]], S[w[K[4]][13]],
                S[w[K[0]][K[8]]], S[w[K[0]][K[8] + 1]], S[w[K[0]][K[8] + 2]]);
            printf ("\n");
#endif
            if (k[0] + 1)
            {                // Check XYZ-Hybrid Column wise
              g[w[K[0]][6]] = k[0];
              g[w[K[0]][7]] = k[2];
              g[w[K[2]][6]] = k[3];
              g[w[K[2]][7]] = k[4];
              g[w[K[0]][K[7]]] = k[5];
              g[w[K[0]][K[7] + 1]] = k[6];
              g[w[K[0]][K[7] + 2]] = k[7];
            }
            if (k[1] + 1)
            {                // Check XYZ-Hybrid Row wise
              g[w[K[0]][12]] = k[1];
              g[w[K[0]][13]] = k[8];
              g[w[K[4]][12]] = k[9];
              g[w[K[4]][13]] = k[10];
              g[w[K[0]][K[8]]] = k[11];
              g[w[K[0]][K[8] + 1]] = k[12];
              g[w[K[0]][K[8] + 2]] = k[13];
            }
#if RJ > 3
            prn ();
#endif
            return 0;        // Undo XYZ-Hybrid exclusion Cell Values
          }
        }
        continue;
XYWT1Tf:
        if (k[0] + 1)
        {
          k[18] = g[k[0]];
          g[k[0]] &= ~K[5];
        }
        if (k[1] + 1)
        {
          k[19] = g[k[1]];
          g[k[1]] &= ~K[5];
        }
        if (k[2] + 1)
        {
          k[20] = g[k[2]];
          g[k[2]] &= ~K[5];
        }
        if (k[3] + 1)
        {
          k[21] = g[k[3]];
          g[k[3]] &= ~K[5];
        }
        if (k[4] + 1)
        {
          k[22] = g[k[4]];
          g[k[4]] &= ~K[5];
        }
        if (k[5] + 1)
        {
          k[23] = g[k[5]];
          k[24] = g[k[10]];
          k[25] = g[k[11]];
          k[26] = g[k[12]];
          k[27] = g[k[13]];
          k[28] = g[k[14]];
          k[29] = g[w[K[0]][6]];
          k[30] = g[w[K[0]][7]];
          k[31] = g[w[K[0]][K[7]]];
          k[32] = g[w[w[K[0]][K[7]]][6]];
          k[33] = g[w[w[K[0]][K[7]]][7]];
          k[34] = g[w[K[2]][6]];
          k[35] = g[w[K[2]][7]];
          k[36] = g[w[K[0]][12]];
          k[37] = g[w[K[0]][13]];
          k[38] = g[w[K[0]][K[8]]];
          k[39] = g[w[w[K[0]][K[8]]][12]];
          k[40] = g[w[w[K[0]][K[8]]][13]];
          k[41] = g[w[K[4]][12]];
          k[42] = g[w[K[4]][13]];
          g[k[5]] &= ~K[5];
          g[k[10]] &= ~K[5];
          g[k[11]] &= ~K[5];
          g[k[12]] &= ~K[5];
          g[k[13]] &= ~K[5];
          g[k[14]] &= ~K[5];
          g[w[K[0]][6]] &= ~(y = g[K[2]] ^ K[5]);
          g[w[K[0]][7]] &= ~y;
          g[w[K[0]][K[7]]] &= ~y;
          g[w[w[K[0]][K[7]]][6]] &= ~y;
          g[w[w[K[0]][K[7]]][7]] &= ~y;
          g[w[K[2]][6]] &= ~y;
          g[w[K[2]][7]] &= ~y;
          g[w[K[0]][12]] &= ~(Y = g[K[4]] ^ K[5]);
          g[w[K[0]][13]] &= ~Y;
          g[w[K[0]][K[8]]] &= ~Y;
          g[w[w[K[0]][K[8]]][12]] &= ~Y;
          g[w[w[K[0]][K[8]]][13]] &= ~Y;
          g[w[K[4]][12]] &= ~Y;
          g[w[K[4]][13]] &= ~Y;
          if (k[6] + 1)
          {
            k[43] = g[k[6]];
            g[k[6]] &= ~K[5];
            if (k[7] + 1)
            {
              k[44] = g[k[7]];
              g[k[7]] &= ~K[5];
              if (k[8] + 1)
              {
                k[45] = g[k[8]];
                k[46] = g[k[15]];
                k[47] = g[k[16]];
                k[48] = g[k[17]];
                g[k[8]] &= ~K[5];
                g[k[15]] &= ~K[5];
                g[k[16]] &= ~K[5];
                g[k[17]] &= ~K[5];
              }
              if (k[9] + 1)
              {
                k[49] = g[k[9]];
                g[k[9]] &= ~K[5];
              }
            }
          }
        }
#if RJ > 2
        printf ("%d) XY%sTransport:%s%s%s%d @ %s %s %s SL%s",
          p, B[g[K[0]]] < 3 ? "-Wing Type 1 " : "Z-", k[50] & 4 ? " Reduced " : " ",
          k[50] & 1 ? "Box" : (k[50] & 2 ? "ERI" : "Line"), k[50] & 8 ? " Ring " : " ",
          b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], A[1][0] + 1 ? " between " : " ");
        if (k[50] & 2)
          printf ("ERI %d @ b%d", b[K[5]], BOX (A[0][0]));
        else
          printf ("Cell%s%d @ ", A[0][1] + 1 ? "s " : " ", b[K[5]]);
        printf ("%s", S[A[0][0]]);
        if (A[0][1] + 1)
        {
          printf (" %s", S[A[0][1]]);
          if (A[0][2] + 1)
            printf (" %s", S[A[0][2]]);
        }
        if (A[1][0] + 1)
        {
          if (k[50] & 2)
            printf (" and ERI %d @ b%d", b[K[5]], BOX (A[1][0]));
          else
            printf (" and Cell%s%d @ ", A[1][1] + 1 ? "s " : " ", b[K[5]]);
          printf ("%s", S[A[1][0]]);
         if (A[1][1] + 1)
          {
            printf (" %s", S[A[1][1]]);
            if (A[1][2] + 1)
              printf (" %s", S[A[1][2]]);
          }
        }
        printf ("\n=> -%d @", b[K[5]]);
        if (k[0] + 1)
          printf (" %s", S[k[0]]);
        if (k[1] + 1)
          printf (" %s", S[k[1]]);
        if (k[2] + 1)
          printf (" %s", S[k[2]]);
        if (k[3] + 1)
          printf (" %s", S[k[3]]);
        if (k[4] + 1)
          printf (" %s", S[k[4]]);
        if (k[5] + 1)
        {
          printf (" %s %s %s %s %s %s", S[k[5]], S[k[10]], S[k[11]], S[k[12]], S[k[13]], S[k[14]]);
          if (k[6] + 1)
          {
            printf (" %s", S[k[6]]);
            if (k[7] + 1)
            {
              printf (" %s", S[k[7]]);
              if (k[8] + 1)
                printf (" %s %s %s %s", S[k[8]], S[k[15]], S[k[16]], S[k[17]]);
              if (k[9] + 1)
                printf (" %s", S[k[9]]);
            }
          }
          printf ("\n=> -%d @ %s %s %s %s %s %s %s => -%d @ %s %s %s %s %s %s %s",
            b[y], S[w[K[0]][6]], S[w[K[0]][7]], S[w[K[0]][K[7]]], S[w[w[K[0]][K[7]]][6]], S[w[w[K[0]][K[7]]][7]],
            S[w[K[2]][6]], S[w[K[2]][7]], b[Y], S[w[K[0]][12]], S[w[K[0]][13]], S[w[K[0]][K[8]]],
            S[w[w[K[0]][K[8]]][12]], S[w[w[K[0]][K[8]]][13]], S[w[K[4]][12]], S[w[K[4]][13]]);
        }
        printf ("\n");
#endif
        if (solve (p))
          return 1;
#if RJ > 2
        printf ("%d) Undo XY%sTransport:%s%s%s%d @ %s %s %s SL%s",
          p, B[g[K[0]]] < 3 ? "-Wing Type 1 " : "Z-", k[50] & 4 ? " Reduced " : " ",
          k[50] & 1 ? "Box" : (k[50] & 2 ? "ERI" : "Line"), k[50] & 8 ? " Ring " : " ",
          b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], A[1][0] + 1 ? " between " : " ");
        if (k[50] & 2)
          printf ("ERI %d @ b%d", b[K[5]], BOX (A[0][0]));
        else
          printf ("Cell%s%d @ ", A[0][1] + 1 ? "s " : " ", b[K[5]]);
        printf ("%s", S[A[0][0]]);
        if (A[0][1] + 1)
        {
          printf (" %s", S[A[0][1]]);
          if (A[0][2] + 1)
            printf (" %s", S[A[0][2]]);
        }
        if (A[1][0] + 1)
        {
          if (k[50] & 2)
            printf (" and ERI %d @ b%d", b[K[5]], BOX (A[1][0]));
          else
            printf (" and Cell%s%d @ ", A[1][1] + 1 ? "s " : " ", b[K[5]]);
          printf ("%s", S[A[1][0]]);
         if (A[1][1] + 1)
          {
            printf (" %s", S[A[1][1]]);
            if (A[1][2] + 1)
              printf (" %s", S[A[1][2]]);
          }
        }
        printf (" <= +%d @", b[K[5]]);
        if (k[0] + 1)
          printf (" %s", S[k[0]]);
        if (k[1] + 1)
          printf (" %s", S[k[1]]);
        if (k[2] + 1)
          printf (" %s", S[k[2]]);
        if (k[3] + 1)
          printf (" %s", S[k[3]]);
        if (k[4] + 1)
          printf (" %s", S[k[3]]);
        if (k[5] + 1)
        {
          printf (" %s %s %s %s %s %s", S[k[5]], S[k[10]], S[k[11]], S[k[12]], S[k[13]], S[k[14]]);
          if (k[6] + 1)
          {
            printf (" %s", S[k[6]]);
            if (k[7] + 1)
            {
              printf (" %s", S[k[7]]);
              if (k[8] + 1)
                printf (" %s %s %s %s", S[k[8]], S[k[15]], S[k[16]], S[k[17]]);
              if (k[9] + 1)
                printf (" %s", S[k[9]]);
            }
          }
          printf ("\n<= +%d @ %s %s %s %s %s %s %s <= +%d @ %s %s %s %s %s %s %s",
            b[y], S[w[K[0]][6]], S[w[K[0]][7]], S[w[K[0]][K[7]]], S[w[w[K[0]][K[7]]][6]], S[w[w[K[0]][K[7]]][7]],
            S[w[K[2]][6]], S[w[K[2]][7]], b[Y], S[w[K[0]][12]], S[w[K[0]][13]], S[w[K[0]][K[8]]],
            S[w[w[K[0]][K[8]]][12]], S[w[w[K[0]][K[8]]][13]], S[w[K[4]][12]], S[w[K[4]][13]]);
        }
        printf ("\n");
#endif
        if (k[5] + 1)
        {
          if (k[6] + 1)
          {
            if (k[7] + 1)
            {
              if (k[8] + 1)
              {
                g[k[8]] = k[45];
                g[k[15]] = k[46];
                g[k[16]] = k[47];
                g[k[17]] = k[48];
              }
              if (k[9] + 1)
                g[k[9]] = k[49];
              g[k[7]] = k[44];
            }
            g[k[6]] = k[43];
          }
          g[w[K[0]][6]] = k[29];
          g[w[K[0]][7]] = k[30];
          g[w[K[0]][K[7]]] = k[31];
          g[w[w[K[0]][K[7]]][6]] = k[32];
          g[w[w[K[0]][K[7]]][7]] = k[33];
          g[w[K[2]][6]] = k[34];
          g[w[K[2]][7]] = k[35];
          g[w[K[0]][12]] = k[36];
          g[w[K[0]][13]] = k[37];
          g[w[K[0]][K[8]]] = k[38];
          g[w[w[K[0]][K[8]]][12]] = k[39];
          g[w[w[K[0]][K[8]]][13]] = k[40];
          g[w[K[4]][12]] = k[41];
          g[w[K[4]][13]] = k[42];
          g[k[5]] = k[23];
          g[k[10]] = k[24];
          g[k[11]] = k[25];
          g[k[12]] = k[26];
          g[k[13]] = k[27];
          g[k[14]] = k[28];
        }
        if (k[4] + 1)
          g[k[4]] = k[22];
        if (k[3] + 1)
          g[k[3]] = k[21];
        if (k[2] + 1)
          g[k[2]] = k[20];
        if (k[1] + 1)
          g[k[1]] = k[19];
        if (k[0] + 1)
          g[k[0]] = k[18];
#if RJ > 3
        prn ();
#endif
        return 0;            // Undo XY-Wing Type 1 Transport and XYZ-Transport exclusion Cell Values
      }
    }
  }
  for (a = p; a < q; ++a)    // Search XY-Ring Type 2, XY-Wing Type 2, XY-Wing Type 2 Transport, XYZ-Wing, XYZ-Wing Transport and XYZ-Wing Hybrid Apex unsolved Cell positions wise
  {
    if (B[g[r[a]]] > 3)
      continue;              // Skip for unsolved Cell Values > three digits
    int K[9] = {r[a]};       // Assign Apex Cell position

    for (y = 0; y < 2; ++y)  // Search Wing Cells position Chute wise
    {
      if (!(g[w[K[0]][W[1][y]]] | g[w[K[0]][W[1][y] + 1]] | g[w[K[0]][W[1][y] + 2]] |
        g[w[K[0]][W[1][y] + 3]] | g[w[K[0]][W[1][y] + 4]] | g[w[K[0]][W[1][y] + 5]]) ||
        !(g[w[K[0]][W[6][y]]] | g[w[K[0]][W[7][y]]] | g[w[K[0]][W[8][y]]] |
        g[w[K[0]][W[9][y]]] | g[w[K[0]][W[10][y]]] | g[w[K[0]][W[11][y]]]))
        continue;            // Skip for no unsolved Cell position in Apex either Line or Box
      for (K[1] = W[1][y]; K[1] < W[2][y]; ++K[1])
      {                      // Search 1st Wing Cell position Line wise
        if (B[g[K[2] = w[K[0]][K[1]]]] != 2 || B[g[K[0]] | g[K[2]]] != 3)
          continue;          // Skip for either 1st Wing Cell position not two digits; or Apex and 1st Wing Cells Values not three digits
        for (K[3] = W[6][y]; K[3] < W[0][y]; ++K[3])
        {                    // Search 2nd Wing Cell position Box wise but not 1st Wing Line
          if (B[g[K[4] = w[K[0]][K[3]]]] != 2 || B[g[K[0]] | g[K[4]]] != 3)
            continue;        // Skip for either 2nd Wing Cell Values not two digits; or Apex and 2nd Wing Cells Values not three digits
          K[6] = W[K[1] < W[5][y] ? 1 : 5][y];
          K[7] = W[K[1] < W[5][y] ? 5 : 1][y];
          K[8] = W[K[3] == W[6][y] || K[3] == W[7][y] || K[3] == W[8][y] ? 4 : 3][!y];
          if (K[2] > K[0] && K[4] > K[0] &&
                             // Check XY-Ring Type 2 1st Wing Cell position > Apex Cell position; and 2nd Wing Cell position > Apex Cell position; and
            B[g[K[0]]] < 3 && !(g[K[2]] & g[K[4]]))
                             // Apex Cell Values two digits; and 1st and 2nd Wing Cells Values four digits
            for (Y = K[6]; Y < K[6] + 3; ++Y)
            {                // Search XY-Ring Type 2 3rd Wing Cell position 1st and 2nd Wing Cells common Cell positions wise
              if (B[g[K[5] = w[K[4]][Y]]] != 2 || B[g[K[2]] | g[K[5]]] != 3 ||
                             // Skip for either 3rd Wing Cell Values not two digits; or 1st and 3rd Wing Cells Values not three digits; or
                B[g[K[4]] | g[K[5]]] != 3 || (g[K[0]] & g[K[5]]) ||
                             // 2nd and 3rd Wing Cells Values three not digits; or Apex and 3rd Wing Cells Values no common digits; or
                !(((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
                g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]] |
                g[w[K[0]][K[7]]] | g[w[K[0]][K[7] + 1]] |
                g[w[K[0]][K[7] + 2]]) & g[K[0]] & g[K[2]]) ||
                ((g[w[K[4]][W[3][y]]] | g[w[K[4]][W[4][y]]] |
                g[w[K[5]][W[3][y]]] | g[w[K[5]][W[4][y]]] |
                g[w[K[4]][K[7]]] | g[w[K[4]][K[7] + 1]] |
                g[w[K[4]][K[7] + 2]]) & g[K[4]] & g[K[5]]) ||
                ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
                g[w[K[4]][W[3][y]]] | g[w[K[4]][W[4][y]]] |
                g[Z = w[K[0]][K[8]]] | g[w[Z][W[3][y]]] |
                g[w[Z][W[4][y]]] | (w[K[0]][20] & w[K[4]][20] & W[15][y] ?
                g[w[K[0]][Z = W[1][!y]]] | g[w[K[0]][++Z]] |
                g[w[K[0]][++Z]] | g[w[K[0]][++Z]] | g[w[K[0]][++Z]] |
                g[w[K[0]][++Z]] : 0)) & g[K[0]] & g[K[4]]) ||
                ((g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]] |
                g[w[K[5]][W[3][y]]] | g[w[K[5]][W[4][y]]] |
                g[Z = w[K[2]][K[8]]] | g[w[Z][W[3][y]]] |
                g[w[Z][W[4][y]]] | (w[K[2]][20] & w[K[5]][20] & W[15][y] ?
                g[w[K[2]][Z = W[1][!y]]] | g[w[K[2]][++Z]] |
                g[w[K[2]][++Z]] | g[w[K[2]][++Z]] | g[w[K[2]][++Z]] |
                g[w[K[2]][++Z]] : 0)) & g[K[2]] & g[K[5]])))
                continue;    // no XY-Ring Type 2 exclusion Cell Values
              int k[32] = {g[w[K[0]][W[3][y]]], g[w[K[0]][W[4][y]]],
                           g[w[K[2]][W[3][y]]], g[w[K[2]][W[4][y]]],
                           g[w[K[0]][K[7]]], g[w[K[0]][K[7] + 1]],
                           g[w[K[0]][K[7] + 2]], g[w[K[4]][W[3][y]]],
                           g[w[K[4]][W[4][y]]], g[w[K[5]][W[3][y]]],
                           g[w[K[5]][W[4][y]]], g[w[K[4]][K[7]]],
                           g[w[K[4]][K[7] + 1]], g[w[K[4]][K[7] + 2]],
                           g[Z = w[K[0]][K[8]]], g[w[Z][W[3][y]]],
                           g[w[Z][W[4][y]]], g[Z = w[K[2]][K[8]]],
                           g[w[Z][W[3][y]]], g[w[Z][W[4][y]]],-1,-1};
                             // Backup XY-Ring Type 2 exclusion Cell Values and drop Wing Cells common exclusion Values
              g[w[K[0]][W[3][y]]] &= ~g[K[0]];
              g[w[K[0]][W[4][y]]] &= ~g[K[0]];
              g[w[K[2]][W[3][y]]] &= ~g[K[2]];
              g[w[K[2]][W[4][y]]] &= ~g[K[2]];
              g[w[K[0]][K[7]]] &= ~(g[K[0]] & g[K[2]]);
              g[w[K[0]][K[7] + 1]] &= ~(g[K[0]] & g[K[2]]);
              g[w[K[0]][K[7] + 2]] &= ~(g[K[0]] & g[K[2]]);
              g[w[K[4]][W[3][y]]] &= ~g[K[4]];
              g[w[K[4]][W[4][y]]] &= ~g[K[4]];
              g[w[K[5]][W[3][y]]] &= ~g[K[5]];
              g[w[K[5]][W[4][y]]] &= ~g[K[5]];
              g[w[K[4]][K[7]]] &= ~(g[K[4]] & g[K[5]]);
              g[w[K[4]][K[7] + 1]] &= ~(g[K[4]] & g[K[5]]);
              g[w[K[4]][K[7] + 2]] &= ~(g[K[4]] & g[K[5]]);
              g[Z = w[K[0]][K[8]]] &= ~(g[K[0]] & g[K[4]]);
              g[w[Z][W[3][y]]] &= ~(g[K[0]] & g[K[4]]);
              g[w[Z][W[4][y]]] &= ~(g[K[0]] & g[K[4]]);
              g[Z = w[K[2]][K[8]]] &= ~(g[K[2]] & g[K[5]]);
              g[w[Z][W[3][y]]] &= ~(g[K[2]] & g[K[5]]);
              g[w[Z][W[4][y]]] &= ~(g[K[2]] & g[K[5]]);
              if (w[K[0]][20] & w[K[4]][20] & W[15][y])
              {              // Check Apex Cell position and 2nd Wing Cell position same Line
                k[20] = g[w[K[0]][Z = W[1][!y]]];
                g[w[K[0]][Z]] &= ~(g[K[0]] & g[K[4]]);
                k[22] = g[w[K[0]][++Z]];
                g[w[K[0]][Z]] &= ~(g[K[0]] & g[K[4]]);
                k[23] = g[w[K[0]][++Z]];
                g[w[K[0]][Z]] &= ~(g[K[0]] & g[K[4]]);
                k[24] = g[w[K[0]][++Z]];
                g[w[K[0]][Z]] &= ~(g[K[0]] & g[K[4]]);
                k[25] = g[w[K[0]][++Z]];
                g[w[K[0]][Z]] &= ~(g[K[0]] & g[K[4]]);
                k[26] = g[w[K[0]][++Z]];
                g[w[K[0]][Z]] &= ~(g[K[0]] & g[K[4]]);
              }
              if (w[K[2]][20] & w[K[5]][20] & W[15][y])
              {              // Check 1st Wing Cell position and 3rd Wing Cell position same Line
                k[21] = g[w[K[2]][Z = W[1][!y]]];
                g[w[K[2]][Z]] &= ~(g[K[2]] & g[K[5]]);
                k[27] = g[w[K[2]][++Z]];
                g[w[K[2]][Z]] &= ~(g[K[2]] & g[K[5]]);
                k[28] = g[w[K[2]][++Z]];
                g[w[K[2]][Z]] &= ~(g[K[2]] & g[K[5]]);
                k[29] = g[w[K[2]][++Z]];
                g[w[K[2]][Z]] &= ~(g[K[2]] & g[K[5]]);
                k[30] = g[w[K[2]][++Z]];
                g[w[K[2]][Z]] &= ~(g[K[2]] & g[K[5]]);
                k[31] = g[w[K[2]][++Z]];
                g[w[K[2]][Z]] &= ~(g[K[2]] & g[K[5]]);
              }
#if RJ > 2
              printf ("%d) XY-Ring Type 2: %d @ %s %s %s %s\n=> -%d @ %s %s %s %s %s %s %s => -%d @ %s %s %s %s %s %s %s\n=> -%d @ %s %s %s %s %s %s %s",
                p, b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], S[K[5]],
                b[g[K[0]] & g[K[2]]], S[w[K[0]][W[3][y]]],
                S[w[K[0]][W[4][y]]], S[w[K[2]][W[3][y]]], S[w[K[2]][W[4][y]]],
                S[w[K[0]][K[7]]], S[w[K[0]][K[7] + 1]], S[w[K[0]][K[7] + 2]],
                b[g[K[4]] & g[K[5]]], S[w[K[4]][W[3][y]]], S[w[K[4]][W[4][y]]],
                S[w[K[5]][W[3][y]]], S[w[K[5]][W[4][y]]], S[w[K[4]][K[7]]],
                S[w[K[4]][K[7] + 1]], S[w[K[4]][K[7] + 2]],
                b[g[K[0]] & g[K[4]]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]],
                S[w[K[4]][W[3][y]]], S[w[K[4]][W[4][y]]], S[w[K[0]][K[8]]],
                S[w[w[K[0]][K[8]]][W[3][y]]], S[w[w[K[0]][K[8]]][W[4][y]]]);
              if (k[20] + 1)
                printf (" %s %s %s %s %s %s",
                  S[w[K[0]][W[1][!y]]], S[w[K[0]][W[1][!y] + 1]],
                  S[w[K[0]][W[1][!y] + 2]], S[w[K[0]][W[1][!y] + 3]],
                  S[w[K[0]][W[1][!y] + 4]], S[w[K[0]][W[1][!y] + 5]]);
              printf ("\n=> -%d @ %s %s %s %s %s %s %s",
                b[g[K[2]] & g[K[5]]], S[w[K[2]][W[3][y]]], S[w[K[2]][W[4][y]]],
                S[w[K[5]][W[3][y]]], S[w[K[5]][W[4][y]]], S[w[K[2]][K[8]]],
                S[w[w[K[2]][K[8]]][W[3][y]]], S[w[w[K[2]][K[8]]][W[4][y]]]);
              if (k[21] + 1)
                printf (" %s %s %s %s %s %s",
                  S[w[K[2]][W[1][!y]]], S[w[K[2]][W[1][!y] + 1]],
                  S[w[K[2]][W[1][!y] + 2]], S[w[K[2]][W[1][!y] + 3]],
                  S[w[K[2]][W[1][!y] + 4]], S[w[K[2]][W[1][!y] + 5]]);
              printf ("\n");
#endif
              if (solve (p))
                return 1;
#if RJ > 2
              printf ("%d) Undo XY-Ring Type 2: %d @ %s %s %s %s\n<= +%d @ %s %s %s %s %s %s %s <= +%d @ %s %s %s %s %s %s %s\n<= +%d @ %s %s %s %s %s %s %s",
                p, b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], S[K[5]],
                b[g[K[0]] & g[K[2]]], S[w[K[0]][W[3][y]]],
                S[w[K[0]][W[4][y]]], S[w[K[2]][W[3][y]]], S[w[K[2]][W[4][y]]],
                S[w[K[0]][K[7]]], S[w[K[0]][K[7] + 1]], S[w[K[0]][K[7] + 2]],
                b[g[K[4]] & g[K[5]]], S[w[K[4]][W[3][y]]], S[w[K[4]][W[4][y]]],
                S[w[K[5]][W[3][y]]], S[w[K[5]][W[4][y]]], S[w[K[4]][K[7]]],
                S[w[K[4]][K[7] + 1]], S[w[K[4]][K[7] + 2]],
                b[g[K[0]] & g[K[4]]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]],
                S[w[K[4]][W[3][y]]], S[w[K[4]][W[4][y]]], S[w[K[0]][K[8]]],
                S[w[w[K[0]][K[8]]][W[3][y]]], S[w[w[K[0]][K[8]]][W[4][y]]]);
              if (k[20] + 1)
                printf (" %s %s %s %s %s %s",
                  S[w[K[0]][W[1][!y]]], S[w[K[0]][W[1][!y] + 1]],
                  S[w[K[0]][W[1][!y] + 2]], S[w[K[0]][W[1][!y] + 3]],
                  S[w[K[0]][W[1][!y] + 4]], S[w[K[0]][W[1][!y] + 5]]);
              printf ("\n=> -%d @ %s %s %s %s %s %s %s",
                b[g[K[2]] & g[K[5]]], S[w[K[2]][W[3][y]]], S[w[K[2]][W[4][y]]],
                S[w[K[5]][W[3][y]]], S[w[K[5]][W[4][y]]], S[w[K[2]][K[8]]],
                S[w[w[K[2]][K[8]]][W[3][y]]], S[w[w[K[2]][K[8]]][W[4][y]]]);
              if (k[21] + 1)
                printf (" %s %s %s %s %s %s",
                  S[w[K[2]][W[1][!y]]], S[w[K[2]][W[1][!y] + 1]],
                  S[w[K[2]][W[1][!y] + 2]], S[w[K[2]][W[1][!y] + 3]],
                  S[w[K[2]][W[1][!y] + 4]], S[w[K[2]][W[1][!y] + 5]]);
              printf ("\n");
#endif
              g[w[K[0]][W[3][y]]] = k[0];
              g[w[K[0]][W[4][y]]] = k[1];
              g[w[K[2]][W[3][y]]] = k[2];
              g[w[K[2]][W[4][y]]] = k[3];
              g[w[K[0]][K[7]]] = k[4];
              g[w[K[0]][K[7] + 1]] = k[5];
              g[w[K[0]][K[7] + 2]] = k[6];
              g[w[K[4]][W[3][y]]] = k[7];
              g[w[K[4]][W[4][y]]] = k[8];
              g[w[K[5]][W[3][y]]] = k[9];
              g[w[K[5]][W[4][y]]] = k[10];
              g[w[K[4]][K[7]]] = k[11];
              g[w[K[4]][K[7] + 1]] = k[12];
              g[w[K[4]][K[7] + 2]] = k[13];
              g[Z = w[K[0]][K[8]]] = k[14];
              g[w[Z][W[3][y]]] = k[15];
              g[w[Z][W[4][y]]] = k[16];
              g[Z = w[K[2]][K[8]]] = k[17];
              g[w[Z][W[3][y]]] = k[18];
              g[w[Z][W[4][y]]] = k[19];
              if (k[20] + 1)
              {
                g[w[K[0]][Z = W[1][!y]]] = k[20];
                g[w[K[0]][++Z]] = k[22];
                g[w[K[0]][++Z]] = k[23];
                g[w[K[0]][++Z]] = k[24];
                g[w[K[0]][++Z]] = k[25];
                g[w[K[0]][++Z]] = k[26];
              }
              if (k[21] + 1)
              {
                g[w[K[2]][Z = W[1][!y]]] = k[21];
                g[w[K[2]][++Z]] = k[27];
                g[w[K[2]][++Z]] = k[28];
                g[w[K[2]][++Z]] = k[29];
                g[w[K[2]][++Z]] = k[30];
                g[w[K[2]][++Z]] = k[31];
              }
#if RJ > 3
              prn ();
#endif
              return 0;      // Undo Wing Cells common Value to XY-Ring Type 2 exclusion Cell Values
            }
          if (B[g[K[0]] | g[K[2]] | g[K[4]]] > 3 ||
                             // Skip for either Apex Cell and Wing Cells Values > three digits; or
            B[K[5] = g[K[2]] & g[K[4]]] != 1 ||
                             // Wing Cells common Value not one digit; or
            ((g[K[0]] & K[5]) && B[g[K[0]]] != 3))
            continue;        // Wing Cells common Value in Apex Cell Values; and Apex Cell Values not three digits
          int k[5] = {g[w[K[0]][W[3][y]]], g[w[K[0]][W[4][y]]]};
                             // Backup XY-Wing Type 2 and XYZ-Wing exclusion Cells Values
          if (B[g[K[0]]] < 3)
          {                  // Check no Wing Cells common Value in Apex Cell Values for backup more XY-Wing Type 2 exclusion Cells Values
            k[2] = g[w[K[4]][K[6]]];
            k[3] = g[w[K[4]][K[6] + 1]];
            k[4] = g[w[K[4]][K[6] + 2]];
          }
          if ((k[0] | k[1] | k[2] | k[3] | k[4]) & K[5])
          {                  // Check Wing Cells common Value in XY-Wing Type 2 and XYZ-Wing exclusion Cells Values
                             // Drop Wing Cells common Value from XYZ-Wing exclusion Cell positions
            g[w[K[0]][W[3][y]]] &= ~K[5];
            g[w[K[0]][W[4][y]]] &= ~K[5];
            if (B[g[K[0]]] < 3)
            {                // Drop Wing Cells common Value from XY-Wing Type 2 more exclusion Cell positions
              g[w[K[4]][K[6]]] &= ~K[5];
              g[w[K[4]][K[6] + 1]] &= ~K[5];
              g[w[K[4]][K[6] + 2]] &= ~K[5];
            }
#if RJ > 2
            printf ("%d) XY%s: %d @ %s %s %s => -%d @ %s %s",
              p, g[K[0]] & K[5] ? "Z-Wing" : "-Wing Type 2", b[g[K[2]] | g[K[4]]],
              S[K[0]], S[K[2]], S[K[4]], b[K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]]);
            if (B[g[K[0]]] < 3)
              printf (" %s %s %s", S[w[K[4]][K[6]]], S[w[K[4]][K[6] + 1]], S[w[K[4]][K[6] + 2]]);
            printf ("\n");
#endif
              if (solve (p))
                return 1;
#if RJ > 2
            printf ("%d) Undo XY%s: %d @ %s %s %s <= +%d @ %s %s",
              p, g[K[0]] & K[5] ? "Z-Wing" : "-Wing Type 2", b[g[K[2]] | g[K[4]]],
              S[K[0]], S[K[2]], S[K[4]], b[K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]]);
            if (B[g[K[0]]] < 3)
              printf (" %s %s %s", S[w[K[4]][K[6]]], S[w[K[4]][K[6] + 1]], S[w[K[4]][K[6] + 2]]);
            printf ("\n");
#endif
            g[w[K[0]][W[3][y]]] = k[0];
            g[w[K[0]][W[4][y]]] = k[1];
            if (B[g[K[0]]] < 3)
            {                // Undo Wing Cells common Value to XY-Wing Type 2 more exclusion Cell positions
              g[w[K[4]][K[6]]] = k[2];
              g[w[K[4]][K[6] + 1]] = k[3];
              g[w[K[4]][K[6] + 2]] = k[4];
            }
#if RJ > 3
            prn ();
#endif
            return 0;        // Undo XY-Wing Type 2 and XYZ-Wing exclusion Cells Values
          }
          int A,             // Search XY-Wing Type 2 Transport and XYZ-Wing Transport
              L,
              M,
              X,
              N = W[K[0] == w[K[4]][W[6][y]] || K[0] == w[K[4]][W[7][y]] ||
                  K[0] == w[K[4]][W[8][y]] ? 4 : 3][!y];

          if (B[g[K[0]]] < 3)// Search XY-Wing Type 2 Transport
          {
            int k[76] = {-1,-1,-1,-1,-1,-1};

            if (((k[75] = LB3 (M = w[K[4]][N], w[M][K[1]], w[M][K[7]], y) & K[5]) ||
              (LB3 (w[K[0]][K[7]], w[K[4]][K[7]], w[X][K[8]], y) & K[5])) &&
              (((g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]] | g[w[K[4]][W[3][y]]] |
              g[w[K[4]][W[4][y]]] | (k[75] && (~(g[w[X][W[3][y]]] | g[w[X][W[4][y]]]) & K[5]) ?
              g[w[X][Y = W[1][!y]]] | g[w[X][++Y]] | g[w[X][++Y]] | g[w[X][++Y]] | g[w[X][++Y]] |
              g[w[X][++Y]] : 0) | (k[75] && (~(g[w[Z][W[3][y]]] | g[w[Z][W[4][y]]]) & K[5]) ?
              g[w[Z][Y = W[1][!y]]] | g[w[Z][++Y]] | g[w[Z][++Y]] |
              g[w[Z][++Y]] | g[w[Z][++Y]] | g[w[Z][++Y]] : 0)) & K[5]) ||
              ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
              g[L = w[K[0]][K[7]]] | g[w[L][W[3][y]]] | g[w[L][W[4][y]]] |
              g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]]) & (g[K[2]] ^ K[5])) ||
              ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
              g[M] | g[w[M][W[3][y]]] | g[w[M][W[4][y]]] |
              g[w[K[4]][W[3][y]]] | g[w[K[4]][W[4][y]]]) & (g[K[4]] ^ K[5]))))
            {                // Line Ring 09, Box Ring 10, Reduced Line Ring 11, 12, 13
              k[0] = w[K[2]][W[3][y]];
              k[1] = w[K[2]][W[4][y]];
              k[2] = w[K[4]][W[3][y]];
              k[3] = w[K[4]][W[4][y]];
              k[6] = 1;
              if (k[75])
              {              // Reduced Line Ring 11, 12, 13
                if (~(g[w[Z][W[3][y]]] | g[w[Z][W[4][y]]]) & K[5])
                {            // Reduced Line Ring 11, 13
                  k[4] = w[Z][Y = W[1][!y]];
                  k[7] = w[Z][++Y];
                  k[8] = w[Z][++Y];
                  k[9] = w[Z][++Y];
                  k[10] = w[Z][++Y];
                  k[11] = w[Z][++Y];
                }
                if (~(g[w[X][W[3][y]]] | g[w[X][W[4][y]]]) & K[5])
                {            // Reduced Line Ring 12, 13
                  k[5] = w[X][Y = W[1][!y]];
                  k[12] = w[X][++Y];
                  k[13] = w[X][++Y];
                  k[14] = w[X][++Y];
                  k[15] = w[X][++Y];
                  k[16] = w[X][++Y];
                }
              }
#if RJ > 2
              k[75] = k[75] ? y : 2;
#endif
              goto XYWT2Tf;
            }
            for (Y = W[1][!y]; Y < W[2][!y]; ++Y)
            {                // Line Ring 14, ERI Ring 15, Line 16, 18, 20, 22, ERI 17, 19, 21, 23, 24, 25
              A = W[Y < W[5][!y] ? 5 : 1][!y];
              if (((k[75] = LN1 (w[K[2]][Y], w[K[4]][Y], w[Z][K[7]], y) & K[5]) ||
                (ERI (X) & ERI (Z) & K[5])) &&
                ((((k[75] ? g[w[X][W[3][!y]]] | g[w[X][W[4][!y]]] |
                g[w[Z][W[3][!y]]] | g[w[Z][W[4][!y]]] : g[X] | g[Z] |
                g[L = w[Z][K[7]]] | g[w[L][W[3][y]]] | g[w[L][W[4][y]]]) |
                g[w[K[2]][K[8]]] | g[L = w[K[2]][A]] | g[w[L][W[3][!y]]] |
                g[w[L][W[4][!y]]] | g[M = w[K[4]][N]] | g[L = w[K[4]][A]] |
                g[w[L][W[3][!y]]] | g[w[L][W[4][!y]]]) & K[5]) ||
                ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
                g[L = w[K[0]][K[7]]] | g[w[L][W[3][y]]] | g[w[L][W[4][y]]] |
                g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]]) & (g[K[2]] ^ K[5])) ||
                ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
                g[M] | g[w[M][W[3][y]]] | g[w[M][W[4][y]]] |
                g[w[K[4]][W[3][y]]] | g[w[K[4]][W[4][y]]]) & (g[K[4]] ^ K[5]))))
              {              // Line Ring 14, ERI Ring 15
                k[4] = w[K[2]][A];
                k[6] = 2;
                k[7] = w[k[4]][W[3][!y]];
                k[8] = w[k[4]][W[4][!y]];
                k[9] = w[K[4]][A];
                k[10] = w[k[9]][W[3][!y]];
                k[11] = w[k[9]][W[4][!y]];
                k[5] = w[K[2]][K[8]];
                k[12] = M;
                if (k[75])
                {            // Line Ring 14
                  k[13] = w[X][W[3][!y]];
                  k[14] = w[X][W[4][!y]];
                  k[15] = w[Z][W[3][!y]];
                  k[16] = w[Z][W[4][!y]];
                }
                else
                {            // ERI Ring 15
                  k[0] = X;
                  k[13] = Z;
                  k[14] = w[Z][K[7]];
                  k[15] = w[k[14]][W[3][y]];
                  k[16] = w[k[14]][W[4][y]];
                }
#if RJ > 2
                k[75] = k[75] ? y : 3;
#endif
                goto XYWT2Tf;
              }
              for (M = 0; M < 2; ++M)
              {
                for (A = K[7]; A < K[7] + 3; ++A)
                  if (((k[75] = LN1 (w[L = w[K[W[16][M]]][A]][Y],
                    w[K[4 >> M]][Y], w[K[2 << M]][Y], y) & K[5]) ||
                    (ERI (X) & ERI (Z) & K[5])) &&
                    ((g[L] | (k[75] ? 0 : g[w[K[2 << M]][Y]])) & K[5]))
                  {          // Line 16, 18, ERI 17, 19
                    k[0] = L;
                    if (!k[75])
                      k[1] = w[K[2 << M]][Y];
#if RJ > 2
                    k[75] = k[75] ? y : 3;
#endif
                    goto XYWT2Tf;
                  }
                for (A = 3; A < 5; ++A)
                  if (((k[75] = LN1 (w[L = w[K[2 << M]][W[A][y]]][Y],
                    w[K[4 >> M]][Y], w[M ? X : Z][K[7]], y) & K[5]) ||
                    (ERI (X) & ERI (Z) & K[5])) &&
                    ((g[L] | g[w[L][M ? N : K[8]]] |
                    (k[75] ? g[w[w[K[2 << M]][Y]][W[3][!y]]] |
                    g[w[w[K[2 << M]][Y]][W[4][!y]]] : g[w[K[2 << M]][Y]])) & K[5]))
                  {          // Line 20, 22, ERI 21, 23
                    k[0] = L;
                    k[1] = w[L][M ? N : K[8]];
                    if (k[75])
                    {        // Line 20, 22
                      k[2] = w[w[K[2 << M]][Y]][W[3][!y]];
                      k[3] = w[w[K[2 << M]][Y]][W[4][!y]];
                    }
                    else     // ERI 21, 23
                      k[2] = w[K[2 << M]][Y];
#if RJ > 2
                    k[75] = k[75] ? y : 3;
#endif
                    goto XYWT2Tf;
                  }
                if (g[w[K[4 >> M]][Y]] & ERI (w[K[2 << M]][Y]) & K[5])
                {            // ERI 24, 25
                  k[0] = w[K[4 >> M]][Y];
#if RJ > 2
                    k[75] = 3;
#endif
                    goto XYWT2Tf;
                }
              }
            }
            continue;        // Skip for no Wing Cells common Value in Apex Cell Values
XYWT2Tf:
            if (k[0] + 1)
            {
              k[31] = g[k[0]];
              g[k[0]] &= ~K[5];
              if (k[1] + 1)
              {
                k[32] = g[k[1]];
                g[k[1]] &= ~K[5];
                if (k[2] + 1)
                {
                  k[33] = g[k[2]];
                  g[k[2]] &= ~K[5];
                  if (k[3] + 1)
                  {
                    k[34] = g[k[3]];
                    g[k[3]] &= ~K[5];
                  }
                }
              }
            }
            if (k[4] + 1)
            {
              k[35] = g[k[4]];
              k[36] = g[k[7]];
              k[37] = g[k[8]];
              k[38] = g[k[9]];
              k[39] = g[k[10]];
              k[40] = g[k[11]];
              g[k[4]] &= ~K[5];
              g[k[7]] &= ~K[5];
              g[k[8]] &= ~K[5];
              g[k[9]] &= ~K[5];
              g[k[10]] &= ~K[5];
              g[k[11]] &= ~K[5];
            }
            if (k[5] + 1)
            {
              k[41] = g[k[5]];
              k[42] = g[k[12]];
              k[43] = g[k[13]];
              k[44] = g[k[14]];
              k[45] = g[k[15]];
              k[46] = g[k[16]];
              g[k[5]] &= ~K[5];
              g[k[12]] &= ~K[5];
              g[k[13]] &= ~K[5];
              g[k[14]] &= ~K[5];
              g[k[15]] &= ~K[5];
              g[k[16]] &= ~K[5];
            }
            if (k[6])
            {
              k[61] = g[k[47] = w[K[0]][W[3][y]]];
              k[62] = g[k[48] = w[K[0]][W[4][y]]];
              k[63] = g[k[49] = w[K[0]][K[7]]];
              k[64] = g[k[50] = w[k[49]][W[3][y]]];
              k[65] = g[k[51] = w[k[49]][W[4][y]]];
              k[66] = g[k[52] = w[K[2]][W[3][y]]];
              k[67] = g[k[53] = w[K[2]][W[4][y]]];
              k[68] = g[k[54] = w[K[0]][W[3][y]]];
              k[69] = g[k[55] = w[K[0]][W[4][y]]];
              k[70] = g[k[56] = w[K[0]][K[8]]];
              k[71] = g[k[57] = w[k[56]][W[3][y]]];
              k[72] = g[k[58] = w[k[56]][W[4][y]]];
              k[73] = g[k[59] = w[K[4]][W[3][y]]];
              k[74] = g[k[60] = w[K[4]][W[4][y]]];
              g[k[47]] &= (L = ~(g[K[2]] ^ K[5]));
              g[k[48]] &= L;
              g[k[49]] &= L;
              g[k[50]] &= L;
              g[k[51]] &= L;
              g[k[52]] &= L;
              g[k[53]] &= L;
              g[k[54]] &= (L = ~(g[K[4]] ^ K[5]));
              g[k[55]] &= L;
              g[k[56]] &= L;
              g[k[57]] &= L;
              g[k[58]] &= L;
              g[k[59]] &= L;
              g[k[60]] &= L;
            }
#if RJ > 2
            printf ("%d) XY-Wing Type 2 Transport: %s%s%d @ %s %s %s\nSL Value %d %s %d between Cell %s and",
              p, k[75] > 2 ? "ERI" : k[75] > 1 ? "Box" : R_C, k[6] ? " Ring " : " ", b[g[K[2]] | g[K[4]]],
              S[K[0]], S[K[2]], S[K[4]], b[K[5]], k[75] > 2 ? "ERI Box" : R_C, k[75] > 2 ? BOX (X) : RCN (X), S[X]);
            if (k[75] > 2)
              printf (" ERI Box %d", BOX (Z));
            printf (" Cell %s => -%d @", S[Z], b[K[5]]);
            if (k[0] + 1)
            {
              printf (" %s", S[k[0]]);
              if (k[1] + 1)
              {
                printf (" %s", S[k[1]]);
                if (k[2] + 1)
                {
                  printf (" %s", S[k[2]]);
                  if (k[3] + 1)
                    printf (" %s", S[k[3]]);
                }
              }
            }
            if (k[4] + 1)
              printf (" %s %s %s %s %s %s", S[k[4]], S[k[7]], S[k[8]], S[k[9]], S[k[10]], S[k[11]]);
            if (k[5] + 1)
              printf (" %s %s %s %s %s %s", S[k[5]], S[k[12]], S[k[13]], S[k[14]], S[k[15]], S[k[16]]);
            printf ("\n");
            if (k[6])
              printf ("=> -%d @ %s %s %s %s %s %s %s => -%d @ %s %s %s %s %s %s %s\n",
                b[g[K[2]] ^ K[5]], S[k[47]], S[k[48]], S[k[49]], S[k[50]], S[k[51]], S[k[52]], S[k[53]],
                b[g[K[4]] ^ K[5]], S[k[54]], S[k[55]], S[k[56]], S[k[57]], S[k[58]], S[k[59]], S[k[60]]);
#endif
            if (solve (p))
              return 1;
#if RJ > 2
            printf ("%d) Undo XY-Wing Type 2 Transport: %s%s%d @ %s %s %s\nSL Value %d %s %d between Cell %s and",
              p, k[75] > 2 ? "ERI" : k[75] > 1 ? "Box" : R_C, k[6] ? " Ring " : " ", b[g[K[2]] | g[K[4]]],
              S[K[0]], S[K[2]], S[K[4]], b[K[5]], k[75] > 2 ? "ERI Box" : R_C, k[75] > 2 ? BOX (X) : RCN (X), S[X]);
            if (k[75] > 2)
              printf (" ERI Box %d", BOX (Z));
            printf (" Cell %s <= +%d @", S[Z], b[K[5]]);
            if (k[0] + 1)
            {
              printf (" %s", S[k[0]]);
              if (k[1] + 1)
              {
                printf (" %s", S[k[1]]);
                if (k[2] + 1)
                {
                  printf (" %s", S[k[2]]);
                  if (k[3] + 1)
                    printf (" %s", S[k[3]]);
                }
              }
            }
            if (k[4] + 1)
              printf (" %s %s %s %s %s %s", S[k[4]], S[k[7]], S[k[8]], S[k[9]], S[k[10]], S[k[11]]);
            if (k[5] + 1)
              printf (" %s %s %s %s %s %s", S[k[5]], S[k[12]], S[k[13]], S[k[14]], S[k[15]], S[k[16]]);
            printf ("\n");
            if (k[6])
              printf ("<= +%d @ %s %s %s %s %s %s %s <= + %d @ %s %s %s %s %s %s %s\n",
                b[g[K[2]] ^ K[5]], S[k[47]], S[k[48]], S[k[49]], S[k[50]], S[k[51]], S[k[52]], S[k[53]],
                b[g[K[4]] ^ K[5]], S[k[54]], S[k[55]], S[k[56]], S[k[57]], S[k[58]], S[k[59]], S[k[60]]);
#endif
            if (k[6])
            {
              g[k[54]] = k[68];
              g[k[55]] = k[69];
              g[k[56]] = k[70];
              g[k[57]] = k[71];
              g[k[58]] = k[72];
              g[k[59]] = k[73];
              g[k[60]] = k[74];
              g[k[47]] = k[61];
              g[k[48]] = k[62];
              g[k[49]] = k[63];
              g[k[50]] = k[64];
              g[k[51]] = k[65];
              g[k[52]] = k[66];
              g[k[53]] = k[67];
            }
            if (k[5] + 1)
            {
              g[k[5]] = k[41];
              g[k[12]] = k[42];
              g[k[13]] = k[43];
              g[k[14]] = k[44];
              g[k[15]] = k[45];
              g[k[16]] = k[46];
            }
            if (k[4] + 1)
            {
              g[k[4]] = k[35];
              g[k[7]] = k[36];
              g[k[8]] = k[37];
              g[k[9]] = k[38];
              g[k[10]] = k[39];
              g[k[11]] = k[40];
            }
            if (k[0] + 1)
            {
              if (k[1] + 1)
              {
                if (k[2] + 1)
                {
                  if (k[3] + 1)
                    g[k[3]] = k[34];
                  g[k[2]] = k[33];
                }
                g[k[1]] = k[32];
              }
              g[k[0]] = k[31];
            }
#if RJ > 3
            prn ();
#endif
            return 0;        // Undo XY-Wing Type 2 Transport exclusion Cell Values
          }
          {                  // XYZ-Wing Transport
            int k[76] = {-1,-1,-1,-1,-1,-1};

            if (((g[M = w[K[4]][N]] | g[w[M][W[3][y]]] | g[w[M][W[4][y]]]) & K[5]) &&
              ((k[75] = LB3 (K[4], w[K[4]][K[1]], w[K[4]][K[7]], y) & K[5]) ||
              (LB3 (w[K[0]][K[7]], w[M][K[7]], w[K[4]][K[7]], y) & K[5])))
            {                // Line 01, Box 02
              k[0] = g[M];   // Backup and drop Wing Cells common Value from XYZ-Wing Transport exclusion Cell positions
              k[1] = g[w[M][W[3][y]]];
              k[2] = g[w[M][W[4][y]]];
              g[M] &= ~K[5];
              g[w[M][W[3][y]]] &= ~K[5];
              g[w[M][W[4][y]]] &= ~K[5];
#if RJ > 2
              printf ("%d) XYZ-Wing Transport: %s %d @ %s %s %s SL Value %d %s %d => -%d @ %s %s %s\n",
                p, k[75] ? R_C : "Box", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                k[75] ? R_C : "Box", k[75] ? RCN (w[K[4]][K[7]]) : BOX (w[K[4]][K[7]]),
                b[K[5]], S[M], S[w[M][W[3][y]]], S[w[M][W[4][y]]]);
#endif
              if (solve (p))
                return 1;
#if RJ > 2
              printf ("%d) Undo XYZ-Wing Transport: %s %d @ %s %s %s SL Value %d %s %d <= +%d @ %s %s %s\n",
                p, k[75] ? R_C : "Box", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                k[75] ? R_C : "Box", k[75] ? RCN (w[K[4]][K[7]]) : BOX (w[K[4]][K[7]]),
                b[K[5]], S[M], S[w[M][W[3][y]]], S[w[M][W[4][y]]]);
#endif
              g[M] = k[0];
              g[w[M][W[3][y]]] = k[1];
              g[w[M][W[4][y]]] = k[2];
#if RJ > 3
              prn ();
#endif
              return 0;      // Undo XYZ-Wing Transport exclusion Cell Values
            }
            if (((g[M = w[K[0]][K[7]]] | g[w[M][W[3][y]]] | g[w[M][W[4][y]]]) & K[5]) &&
              ((k[75] = LB3 (w[K[4]][N], w[X][K[7]], w[X][K[1]], y) & K[5]) ||
              (LB3 (K[2], w[K[4]][K[1]], w[w[K[0]][N]][K[1]], y) & K[5])))
            {                // Line 03, Box 04
              k[0] = g[M];   // Backup and drop Wing Cells common Value from XYZ-Wing Transport exclusion Cell positions
              k[1] = g[w[M][W[3][y]]];
              k[2] = g[w[M][W[4][y]]];
              g[M] &= ~K[5];
              g[w[M][W[3][y]]] &= ~K[5];
              g[w[M][W[4][y]]] &= ~K[5];
#if RJ > 2
              printf ("%d) XYZ-Wing Transport: %s %d @ %s %s %s SL Value %d %s %d => -%d @ %s %s %s\n",
                p, k[75] ? R_C : "Box", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                k[75] ? R_C : "Box", k[75] ? RCN (w[K[4]][K[7]]) : BOX (w[K[4]][K[7]]),
                b[K[5]], S[M], S[w[M][W[3][y]]], S[w[M][W[4][y]]]);
#endif
              if (solve (p))
                return 1;
#if RJ > 2
              printf ("%d) Undo XYZ-Wing Transport: %s %d @ %s %s %s SL Value %d %s %d <= +%d @ %s %s %s\n",
                p, k[75] ? R_C : "Box", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                k[75] ? R_C : "Box", k[75] ? RCN (w[K[4]][K[7]]) : BOX (w[K[4]][K[7]]),
                b[K[5]], S[M], S[w[M][W[3][y]]], S[w[M][W[4][y]]]);
#endif
              g[M] = k[0];
              g[w[M][W[3][y]]] = k[1];
              g[w[M][W[4][y]]] = k[2];
#if RJ > 3
              prn ();
#endif
              return 0;      // Undo XYZ-Wing Transport exclusion Cell Values
            }
            if (((k[75] = LB3 (M = w[K[4]][N], w[M][K[1]], w[M][K[7]], y) & K[5]) ||
              (LB3 (w[K[0]][K[7]], w[K[4]][K[7]], w[X][K[8]], y) & K[5])) &&
              (((g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]] | g[w[K[4]][W[3][y]]] |
              g[w[K[4]][W[4][y]]] | g[L = w[K[4]][K[1]]] | g[w[L][W[3][y]]] | g[w[L][W[4][y]]] |
              (k[75] && w[K[0]][K[8]] == M && (~(g[w[X][W[3][y]]] | g[w[X][W[4][y]]]) & K[5]) ?
              g[w[X][Y = W[1][!y]]] | g[w[X][++Y]] | g[w[X][++Y]] |
              g[w[X][++Y]] | g[w[X][++Y]] | g[w[X][++Y]] : 0) |
              (k[75] && (~(g[w[Z][W[3][y]]] | g[w[Z][W[4][y]]]) & K[5]) ?
              g[w[Z][Y = W[1][!y]]] | g[w[Z][++Y]] | g[w[Z][++Y]] |
              g[w[Z][++Y]] | g[w[Z][++Y]] | g[w[Z][++Y]] : 0)) & K[5]) ||
              ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
              g[A = w[K[0]][K[7]]] | g[w[A][W[3][y]]] | g[w[A][W[4][y]]] |
              g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]]) & (g[K[2]] ^ K[5])) ||
              ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
              g[M] | g[w[M][W[3][y]]] | g[w[M][W[4][y]]] |
              g[w[K[4]][W[3][y]]] | g[w[K[4]][W[4][y]]]) & (g[K[4]] ^ K[5]))))
            {                // Line Ring 03, Box Ring 04, Reduced Line Ring 05, 06, 07
              k[0] = g[w[K[0]][W[3][y]]];
              k[1] = g[w[K[0]][W[4][y]]];
              k[2] = g[w[K[2]][W[3][y]]];
              k[3] = g[w[K[2]][W[4][y]]];
              k[4] = g[w[K[4]][W[3][y]]];
              k[5] = g[w[K[4]][W[4][y]]];
              k[6] = g[L];
              k[7] = g[w[L][W[3][y]]];
              k[8] = g[w[L][W[4][y]]];
              k[9] = g[A = w[K[0]][K[7]]];
              k[10] = g[w[A][W[3][y]]];
              k[11] = g[w[A][W[4][y]]];
              k[12] = g[M];
              k[13] = g[w[M][W[3][y]]];
              k[14] = g[w[M][W[4][y]]];
              k[15] = k[75] && w[K[0]][K[8]] == M && ~(g[w[M][W[3][y]]] | g[w[M][W[4][y]]]) & K[5];
              k[16] = k[75] && ~(g[w[Y = w[K[2]][K[8]]][W[3][y]]] | g[w[Y][W[4][y]]]) & K[5];
              if (k[15])     // Backup and drop Wing Cells common Value from XYZ-Wing Transport exclusion Cell positions
              {              // Reduced Line Ring 05, 07
                k[17] = g[w[K[4]][Y = W[1][!y]]];
                g[w[K[4]][Y]] &= ~K[5];
                k[18] = g[w[K[4]][++Y]];
                g[w[K[4]][Y]] &= ~K[5];
                k[19] = g[w[K[4]][++Y]];
                g[w[K[4]][Y]] &= ~K[5];
                k[20] = g[w[K[4]][++Y]];
                g[w[K[4]][Y]] &= ~K[5];
                k[21] = g[w[K[4]][++Y]];
                g[w[K[4]][Y]] &= ~K[5];
                k[22] = g[w[K[4]][++Y]];
                g[w[K[4]][Y]] &= ~K[5];
              }
              if (k[16])
              {              // Reduced Line Ring 06, 07
                k[23] = g[w[K[2]][Y = W[1][!y]]];
                g[w[K[2]][Y]] &= ~K[5];
                k[24] = g[w[K[2]][++Y]];
                g[w[K[2]][Y]] &= ~K[5];
                k[25] = g[w[K[2]][++Y]];
                g[w[K[2]][Y]] &= ~K[5];
                k[26] = g[w[K[2]][++Y]];
                g[w[K[2]][Y]] &= ~K[5];
                k[27] = g[w[K[2]][++Y]];
                g[w[K[2]][Y]] &= ~K[5];
                k[28] = g[w[K[2]][++Y]];
                g[w[K[2]][Y]] &= ~K[5];
              }
              g[w[K[2]][W[3][y]]] &= ~K[5];
              g[w[K[2]][W[4][y]]] &= ~K[5];
              g[w[K[4]][W[3][y]]] &= ~K[5];
              g[w[K[4]][W[4][y]]] &= ~K[5];
              g[L] &= ~K[5];
              g[w[L][W[3][y]]] &= ~K[5];
              g[w[L][W[4][y]]] &= ~K[5];
              g[w[K[0]][W[3][y]]] &= (Y = ~(g[K[2]] ^ K[5]));
              g[w[K[0]][W[4][y]]] &= Y;
              g[w[K[2]][W[3][y]]] &= Y;
              g[w[K[2]][W[4][y]]] &= Y;
              g[A] &= Y;
              g[w[A][W[3][y]]] &= Y;
              g[w[A][W[4][y]]] &= Y;
              g[w[K[0]][W[3][y]]] &= (Y = ~(g[K[4]] ^ K[5]));
              g[w[K[0]][W[4][y]]] &= Y;
              g[w[K[4]][W[3][y]]] &= Y;
              g[w[K[4]][W[4][y]]] &= Y;
              g[M] &= Y;
              g[w[M][W[3][y]]] &= Y;
              g[w[M][W[4][y]]] &= Y;
#if RJ > 2
              printf ("%d) XYZ-Wing Transport: %s%sRing %d @ %s %s %s\nSL Value %d %s %d => -%d @ %s %s %s %s %s %s %s",
                p, k[75] ? R_C : "Box", k[15] ? " Reduced " : " ", b[g[K[0]]],
                S[K[0]], S[K[2]], S[K[4]], b[K[5]], k[75] ? R_C : "Box", k[75] ? RCN (M) : BOX (M),
                b[K[5]], S[w[K[2]][W[3][y]]], S[w[K[2]][W[4][y]]], S[w[K[4]][W[3][y]]],
                S[w[K[4]][W[4][y]]], S[L], S[w[L][W[3][y]]], S[w[L][W[4][y]]]);
              if (k[15])
              {
                Y = W[1][!y];
                printf (" %s %s %s %s %s %s", S[w[K[4]][Y]], S[w[K[4]][++Y]],
                  S[w[K[4]][++Y]], S[w[K[4]][++Y]], S[w[K[4]][++Y]], S[w[K[4]][++Y]]);
              }
              if (k[16])
              {
                Y = W[1][!y];
                printf (" %s %s %s %s %s %s", S[w[K[2]][Y]], S[w[K[2]][++Y]],
                  S[w[K[2]][++Y]], S[w[K[2]][++Y]], S[w[K[2]][++Y]], S[w[K[2]][++Y]]);
              }
              printf ("\n=> -%d @ %s %s %s %s %s %s %s => -%d @ %s %s %s %s %s %s %s\n",
                b[g[K[2]] ^ K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]],
                S[w[K[2]][W[3][y]]], S[w[K[2]][W[4][y]]], S[A], S[w[A][W[3][y]]], S[w[A][W[4][y]]],
                b[g[K[4]] ^ K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]],
                S[w[K[4]][W[3][y]]], S[w[K[4]][W[4][y]]], S[M], S[w[M][W[3][y]]], S[w[M][W[4][y]]]);
#endif
              if (solve (p))
                return 1;
#if RJ > 2
              printf ("%d) Undo XYZ-Wing Transport: %s%sRing %d @ %s %s %s\nSL Value %d %s %d <= +%d @ %s %s %s %s %s %s %s",
                p, k[75] ? R_C : "Box", k[15] ? " Reduced " : " ", b[g[K[0]]],
                S[K[0]], S[K[2]], S[K[4]], b[K[5]], k[75] ? R_C : "Box", k[75] ? RCN (M) : BOX (M),
                b[K[5]], S[w[K[2]][W[3][y]]], S[w[K[2]][W[4][y]]], S[w[K[4]][W[3][y]]],
                S[w[K[4]][W[4][y]]], S[L], S[w[L][W[3][y]]], S[w[L][W[4][y]]]);
              if (k[15])
              {
                Y = W[1][!y];
                printf (" %s %s %s %s %s %s", S[w[K[4]][Y]], S[w[K[4]][++Y]],
                  S[w[K[4]][++Y]], S[w[K[4]][++Y]], S[w[K[4]][++Y]], S[w[K[4]][++Y]]);
              }
              if (k[16])
              {
                Y = W[1][!y];
                printf (" %s %s %s %s %s %s", S[w[K[2]][Y]], S[w[K[2]][++Y]],
                  S[w[K[2]][++Y]], S[w[K[2]][++Y]], S[w[K[2]][++Y]], S[w[K[2]][++Y]]);
              }
              printf ("\n<= +%d @ %s %s %s %s %s %s %s <= +%d @ %s %s %s %s %s %s %s\n",
                b[g[K[2]] ^ K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]],
                S[w[K[2]][W[3][y]]], S[w[K[2]][W[4][y]]], S[A], S[w[A][W[3][y]]], S[w[A][W[4][y]]],
                b[g[K[4]] ^ K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]],
                S[w[K[4]][W[3][y]]], S[w[K[4]][W[4][y]]], S[M], S[w[M][W[3][y]]], S[w[M][W[4][y]]]);
#endif
              g[w[K[0]][W[3][y]]] = k[0];
              g[w[K[0]][W[4][y]]] = k[1];
              g[w[K[2]][W[3][y]]] = k[2];
              g[w[K[2]][W[4][y]]] = k[3];
              g[w[K[4]][W[3][y]]] = k[4];
              g[w[K[4]][W[4][y]]] = k[5];
              g[L] = k[6];
              g[w[L][W[3][y]]] = k[7];
              g[w[L][W[4][y]]] = k[8];
              g[A] = k[9];
              g[w[A][W[3][y]]] = k[10];
              g[w[A][W[4][y]]] = k[11];
              g[M] = k[12];
              g[w[M][W[3][y]]] = k[13];
              g[w[M][W[4][y]]] = k[14];
              if (k[15])
              {              // Reduced Line Ring 05, 07
                g[w[K[4]][Y = W[1][!y]]] = k[17];
                g[w[K[4]][++Y]] = k[18];
                g[w[K[4]][++Y]] = k[19];
                g[w[K[4]][++Y]] = k[20];
                g[w[K[4]][++Y]] = k[21];
                g[w[K[4]][++Y]] = k[22];
              }
              if (k[16])
              {              // Reduced Line Ring 06, 07
                g[w[K[2]][Y = W[1][!y]]] = k[23];
                g[w[K[2]][++Y]] = k[24];
                g[w[K[2]][++Y]] = k[25];
                g[w[K[2]][++Y]] = k[26];
                g[w[K[2]][++Y]] = k[27];
                g[w[K[2]][++Y]] = k[28];
              }
#if RJ > 3
              prn ();
#endif
              return 0;      // Undo XYZ-Wing Transport exclusion Cell Values
            }
            for (Y = W[1][!y]; Y < W[2][!y]; ++Y)
            {
              A = W[Y < W[5][!y] ? 5 : 1][!y];
              if (((k[75] = LN1 (w[K[2]][Y], w[K[4]][Y], w[Z][K[7]], y) & K[5]) ||
                (ERI (X) & ERI (Z) & K[5])) &&
                (((g[M = w[K[4]][N]] | (w[K[0]][K[8]] == M ?
                (k[75] ? g[w[X][W[3][!y]]] | g[w[X][W[4][!y]]] |
                g[w[Z][W[3][!y]]] | g[w[Z][W[4][!y]]] : g[X] | g[Z] |
                g[L = w[Z][K[7]]] | g[w[L][W[3][y]]] | g[w[L][W[4][y]]]) |
                g[w[K[4]][K[1]]] | g[w[K[2]][K[8]]] | g[L = w[K[2]][A]] |
                g[w[L][W[3][!y]]] | g[w[L][W[4][!y]]] | g[L = w[K[4]][A]] |
                g[w[L][W[3][!y]]] | g[w[L][W[4][!y]]] : 0)) & K[5]) ||
                ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
                g[L = w[K[0]][K[7]]] | g[w[L][W[3][y]]] | g[w[L][W[4][y]]] |
                g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]]) & (g[K[2]] ^ K[5])) ||
                ((g[w[K[0]][W[3][y]]] | g[w[K[0]][W[4][y]]] |
                g[M] | g[w[M][W[3][y]]] | g[w[M][W[4][y]]] |
                g[w[K[4]][W[3][y]]] | g[w[K[4]][W[4][y]]]) & (g[K[4]] ^ K[5]))))
              {              // Line Ring 08, 10, ERI Ring 09, 11
                k[0] = g[w[K[0]][W[3][y]]];
                k[1] = g[w[K[0]][W[4][y]]];
                k[2] = g[w[K[2]][W[3][y]]];
                k[3] = g[w[K[2]][W[4][y]]];
                k[4] = g[w[K[4]][W[3][y]]];
                k[5] = g[w[K[4]][W[4][y]]];
                k[6] = g[L = w[K[0]][K[7]]];
                k[7] = g[w[L][W[3][y]]];
                k[8] = g[w[L][W[4][y]]];
                k[9] = g[M];
                k[10] = g[w[M][W[3][y]]];
                k[11] = g[w[M][W[4][y]]];
                g[M] &= ~K[5];
                g[w[K[0]][W[3][y]]] &= ~(g[K[2]] ^ K[5]);
                g[w[K[0]][W[4][y]]] &= ~(g[K[2]] ^ K[5]);
                g[w[K[2]][W[3][y]]] &= ~(g[K[2]] ^ K[5]);
                g[w[K[2]][W[4][y]]] &= ~(g[K[2]] ^ K[5]);
                g[L] &= ~(g[K[2]] ^ K[5]);
                g[w[L][W[3][y]]] &= ~(g[K[2]] ^ K[5]);
                g[w[L][W[4][y]]] &= ~(g[K[2]] ^ K[5]);
                g[w[K[0]][W[3][y]]] &= ~(g[K[4]] ^ K[5]);
                g[w[K[0]][W[4][y]]] &= ~(g[K[4]] ^ K[5]);
                g[w[K[4]][W[3][y]]] &= ~(g[K[4]] ^ K[5]);
                g[w[K[4]][W[4][y]]] &= ~(g[K[4]] ^ K[5]);
                g[M] &= ~(g[K[4]] ^ K[5]);
                g[w[M][W[3][y]]] &= ~(g[K[4]] ^ K[5]);
                g[w[M][W[4][y]]] &= ~(g[K[4]] ^ K[5]);
                if (w[K[0]][K[8]] == M)
                {            // Line Ring 10, ERI Ring 11
                  if (k[75])
                  {          // Line Ring 10
                    k[12] = g[w[X][W[3][!y]]];
                    k[13] = g[w[X][W[4][!y]]];
                    k[14] = g[w[Z][W[3][!y]]];
                    k[15] = g[w[Z][W[4][!y]]];
                    g[w[X][W[3][!y]]] &= ~K[5];
                    g[w[X][W[4][!y]]] &= ~K[5];
                    g[w[Z][W[3][!y]]] &= ~K[5];
                    g[w[Z][W[4][!y]]] &= ~K[5];
                  }
                  else
                  {          // ERI Ring 11
                    k[12] = g[X];
                    k[13] = g[Z];
                    k[14] = g[L = w[Z][K[7]]];
                    k[15] = g[w[L][W[3][y]]];
                    k[24] = g[w[L][W[4][y]]];
                    g[X] &= ~K[5];
                    g[Z] &= ~K[5];
                    g[L] &= ~K[5];
                    g[w[L][W[3][y]]] &= ~K[5];
                    g[w[L][W[4][y]]] &= ~K[5];
                  }
                  k[16] = g[w[K[4]][K[1]]];
                  k[17] = g[w[K[2]][K[8]]];
                  k[18] = g[L = w[K[2]][A]];
                  k[19] = g[w[L][W[3][!y]]];
                  k[20] = g[w[L][W[4][!y]]];
                  k[21] = g[L = w[K[4]][A]];
                  k[22] = g[w[L][W[3][!y]]];
                  k[23] = g[w[L][W[4][!y]]];
                  g[w[K[4]][K[1]]] &= ~K[5];
                  g[w[K[2]][K[8]]] &= ~K[5];
                  g[L = w[K[2]][A]] &= ~K[5];
                  g[w[L][W[3][!y]]] &= ~K[5];
                  g[w[L][W[4][!y]]] &= ~K[5];
                  g[L = w[K[4]][A]] &= ~K[5];
                  g[w[L][W[3][!y]]] &= ~K[5];
                  g[w[L][W[4][!y]]] &= ~K[5];
                }
#if RJ > 2
                printf ("%d) XYZ-Wing Transport: %s Ring %d @ %s %s %s SL Value %d %s %d between Cell %s and Cell %s\n=> -%d @ %s",
                  p, k[75] ? R_C : "ERI", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                  k[75] ? R_C : "ERI", k[75] ? RCN (X) : BOX (X), S[X], S[Z], b[K[5]], S[M]);
                if (w[K[0]][K[8]] == M)
                {
                  if (k[75])
                    printf (" %s %s %s %s", S[w[X][W[3][!y]]], S[w[X][W[4][!y]]],
                      S[w[Z][W[3][!y]]], S[w[Z][W[4][!y]]]);
                  else
                    printf (" %s %s %s %s %s", S[X], S[Z], S[w[Z][K[7]]], S[w[w[Z][K[7]]][W[3][y]]], S[w[w[Z][K[7]]][W[4][y]]]);
                  printf (" %s %s %s %s %s %s %s %s", S[w[K[4]][K[1]]], S[w[K[2]][K[8]]],
                    S[w[K[2]][A]], S[w[w[K[2]][A]][W[3][!y]]], S[w[w[K[2]][A]][W[4][!y]]],
                    S[w[K[4]][A]], S[w[w[K[4]][A]][W[3][!y]]], S[w[w[K[4]][A]][W[4][!y]]]);
                }
                printf ("\n=> -%d @ %s %s %s %s %s %s %s => -%d @ %s %s %s %s %s %s %s\n",
                  b[g[K[2]] ^ K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]], S[w[K[2]][W[3][y]]],
                  S[w[K[2]][W[4][y]]], S[w[K[0]][K[7]]], S[w[w[K[0]][K[7]]][W[3][y]]], S[w[w[K[0]][K[7]]][W[4][y]]],
                  b[g[K[4]] ^ K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]],
                  S[w[K[4]][W[3][y]]], S[w[K[4]][W[4][y]]], S[M], S[w[M][W[3][y]]], S[w[M][W[4][y]]]);
#endif
                  if (solve (p))
                    return 1;
#if RJ > 2
                printf ("%d) Undo XYZ-Wing Transport: %s Ring %d @ %s %s %s SL Value %d %s %d between Cell %s and Cell %s\n<= +%d @ %s",
                  p, k[75] ? R_C : "ERI", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                  k[75] ? R_C : "ERI", k[75] ? RCN (X) : BOX (X), S[X], S[Z], b[K[5]], S[M]);
                if (w[K[0]][K[8]] == M)
                {
                  if (k[75])
                    printf (" %s %s %s %s", S[w[X][W[3][!y]]], S[w[X][W[4][!y]]],
                      S[w[Z][W[3][!y]]], S[w[Z][W[4][!y]]]);
                  else
                    printf (" %s %s %s %s %s", S[X], S[Z], S[w[Z][K[7]]], S[w[w[Z][K[7]]][W[3][y]]], S[w[w[Z][K[7]]][W[4][y]]]);
                  printf (" %s %s %s %s %s %s %s %s", S[w[K[4]][K[1]]], S[w[K[2]][K[8]]],
                    S[w[K[2]][A]], S[w[w[K[2]][A]][W[3][!y]]], S[w[w[K[2]][A]][W[4][!y]]],
                    S[w[K[4]][A]], S[w[w[K[4]][A]][W[3][!y]]], S[w[w[K[4]][A]][W[4][!y]]]);
                }
                printf ("\n<= +%d @ %s %s %s %s %s %s %s <= +%d @ %s %s %s %s %s %s %s\n",
                  b[g[K[2]] ^ K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]], S[w[K[2]][W[3][y]]],
                  S[w[K[2]][W[4][y]]], S[w[K[0]][K[7]]], S[w[w[K[0]][K[7]]][W[3][y]]], S[w[w[K[0]][K[7]]][W[4][y]]],
                  b[g[K[4]] ^ K[5]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]],
                  S[w[K[4]][W[3][y]]], S[w[K[4]][W[4][y]]], S[M], S[w[M][W[3][y]]], S[w[M][W[4][y]]]);
#endif
                g[w[K[0]][W[3][y]]] = k[0];
                g[w[K[0]][W[4][y]]] = k[1];
                g[w[K[2]][W[3][y]]] = k[2];
                g[w[K[2]][W[4][y]]] = k[3];
                g[w[K[4]][W[3][y]]] = k[4];
                g[w[K[4]][W[4][y]]] = k[5];
                g[L = w[K[0]][K[7]]] = k[6];
                g[w[L][W[3][y]]] = k[7];
                g[w[L][W[4][y]]] = k[8];
                g[M] = k[9];
                g[w[M][W[3][y]]] = k[10];
                g[w[M][W[4][y]]] = k[11];
                if (w[K[0]][K[8]] == M)
                {            // Line Ring 10, ERI Ring 11
                  if (k[75])
                  {          // Line Ring 10
                    g[w[X][W[3][!y]]] = k[12];
                    g[w[X][W[4][!y]]] = k[13];
                    g[w[Z][W[3][!y]]] = k[14];
                    g[w[Z][W[4][!y]]] = k[15];
                  }
                  else
                  {          // ERI Ring 11
                    g[X] = k[12];
                    g[Z] = k[13];
                    g[w[Z][K[7]]] = k[14];
                    g[w[w[Z][K[7]]][W[3][y]]] = k[15];
                    g[w[w[Z][K[7]]][W[4][y]]] = k[24];
                  }
                  g[w[K[4]][K[1]]] = k[16];
                  g[w[K[2]][K[8]]] = k[17];
                  g[L = w[K[2]][A]] = k[18];
                  g[w[L][W[3][!y]]] = k[19];
                  g[w[L][W[4][!y]]] = k[20];
                  g[L = w[K[4]][A]] = k[21];
                  g[w[L][W[3][!y]]] = k[22];
                  g[w[L][W[4][!y]]] = k[23];
                }
#if RJ > 3
                prn ();
#endif
                return 0;    // Undo XYZ-Wing Transport exclusion Cell Values
              }
              for (A = K[7]; A < K[7] + 3; ++A)
                if (((k[75] = LN1 (w[L = w[K[0]][A]][Y], w[K[4]][Y], w[K[2]][Y], y) & K[5]) ||
                  (ERI (X) & ERI (Z) & K[5])) &&
                  ((g[L] | (!k[75] && w[K[0]][K[8]] == w[K[4]][N] ? g[w[K[2]][Y]] : 0)) & K[5]))
                {            // Line 12, ERI 13, 14
                  k[0] = g[L];
                  g[L] &= ~K[5];
                  if (!k[75] && w[K[0]][K[8]] == w[K[4]][N])
                  {          // ERI 14
                    k[1] = g[w[K[2]][Y]];
                    g[w[K[2]][Y]] &= ~K[5];
                  }
#if RJ > 2
                  printf ("%d) XYZ-Wing Transport: %s %d @ %s %s %s SL Value %d %s %d => -%d @ %s",
                    p, k[75] ? R_C : "ERI", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                    k[75] ? R_C : "ERI Box", k[75] ? RCN (X) : BOX (X), b[K[5]], S[L]);
                  if (k[1] + 1)
                    printf (" %s", S[w[K[2]][Y]]);
                  printf ("\n");
#endif
                  if (solve (p))
                    return 1;
#if RJ > 2
                  printf ("%d) Undo XYZ-Wing Transport: %s %d @ %s %s %s SL Value %d %s %d <= +%d @ %s",
                    p, k[75] ? R_C : "ERI", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                    k[75] ? R_C : "ERI Box", k[75] ? RCN (X) : BOX (X), b[K[5]], S[L]);
                  if (k[1] + 1)
                    printf (" %s", S[w[K[2]][Y]]);
                  printf ("\n");
#endif
                  g[L] = k[0];
                  if (k[1] + 1)
                    g[w[K[2]][Y]] = k[1];
#if RJ > 3
                  prn ();
#endif
                  return 0;  // Undo XYZ-Wing Transport exclusion Cell Values
                }
              for (M = 0; M < 2; ++M)
              {
                for (A = 3; A < 5; ++A)
                  if (((k[75] = LN1 (w[L = w[K[2 << M]][W[A][y]]][Y],
                    w[K[4 >> M]][Y], w[M ? X : Z][K[7]], y) & K[5]) ||
                    (ERI (X) & ERI (Z) & K[5])) &&
                    ((g[L] | (w[K[0]][K[8]] == w[K[4]][N] ?
                    (M ? g[w[L][N]] : g[w[L][W[3][!y]]] | g[w[L][W[4][!y]]]) |
                    (k[75] ? g[w[w[K[2 << M]][Y]][W[3][!y]]] |
                    g[w[w[K[2 << M]][Y]][W[4][!y]]] : g[w[K[2 << M]][Y]]) : 0)) & K[5]))
                  {          // Line 15, 17, 19, 21 ERI 16, 18, 20, 22
                    k[0] = g[L];
                    g[L] &= ~K[5];
                    if (w[K[0]][K[8]] == w[K[4]][N])
                    {        // Line 17, 21 ERI 18, 22
                      if (M)
                      {      // Line 21, ERI 22
                        k[1] = g[w[L][N]];
                        g[w[L][N]] &= ~K[5];
                      }
                      else
                      {      // Line 17, ERI 18
                        k[1] = g[w[L][W[3][!y]]];
                        k[2] = g[w[L][W[4][!y]]];
                        g[w[L][W[3][!y]]] &= ~K[5];
                        g[w[L][W[4][!y]]] &= ~K[5];
                      }
                      if (k[75])
                      {      // Line 17, 19
                        k[3] = g[w[w[K[2 << M]][Y]][W[3][!y]]];
                        k[4] = g[w[w[K[2 << M]][Y]][W[4][!y]]];
                        g[w[w[K[2 << M]][Y]][W[3][!y]]] &= ~K[5];
                        g[w[w[K[2 << M]][Y]][W[4][!y]]] &= ~K[5];
                      }
                      else
                      {      // ERI 18, 20
                        k[3] = g[w[K[2 << M]][Y]];
                        g[w[K[2 << M]][Y]] &= ~K[5];
                      }
                    }
#if RJ > 2
                    printf ("%d) XYZ-Wing Transport: %s %d @ %s %s %s SL Value %d %s %d between Cell %s and Cell %s\n=> -%d @ %s",
                      p, k[75] ? R_C : "ERI", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                      k[75] ? R_C : "ERI", k[75] ? RCN (X) : BOX (X), S[X], S[Z], b[K[5]], S[L]);
                    if (k[1] + 1)
                    {
                      printf (" %s", S[w[L][M ? N : W[3][!y]]]);
                      if (k[2] + 1)
                        printf (" %s", S[w[L][W[4][!y]]]);
                    }
                    if (k[3] + 1)
                    {
                      printf (" %s", S[k[75] ? w[w[K[2 << M]][Y]][W[3][!y]] : w[K[2 << M]][Y]]);
                      if (k[4] + 1)
                        printf (" %s", S[w[w[K[2 << M]][Y]][W[4][!y]]]);
                    }
                    printf ("\n");
#endif
                    if (solve (p))
                      return 1;
#if RJ > 2
                    printf ("%d) Undo XYZ-Wing Transport: %s %d @ %s %s %s SL Value %d %s %d between Cell %s and Cell %s\n<= +%d @ %s",
                      p, k[75] ? R_C : "ERI", b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                      k[75] ? R_C : "ERI", k[75] ? RCN (X) : BOX (X), S[X], S[Z], b[K[5]], S[L]);
                    if (k[1] + 1)
                    {
                      printf (" %s", S[w[L][M ? N : W[3][!y]]]);
                      if (k[2] + 1)
                        printf (" %s", S[w[L][W[4][!y]]]);
                    }
                    if (k[3] + 1)
                    {
                      printf (" %s", S[k[75] ? w[w[K[2 << M]][Y]][W[3][!y]] : w[K[2 << M]][Y]]);
                      if (k[4] + 1)
                        printf (" %s", S[w[w[K[2 << M]][Y]][W[4][!y]]]);
                    }
                    printf ("\n");
#endif
                    g[L] = k[0];
                    if (w[K[0]][K[8]] == w[K[4]][N])
                    {        // Line 17, 21 ERI 18, 22
                      if (M) // Line 21, ERI 22
                        g[w[L][N]] = k[1];
                      else
                      {      // Line 17, ERI 18
                        g[w[L][W[3][!y]]] = k[1];
                        g[w[L][W[4][!y]]] = k[2];
                      }
                      if (k[75])
                      {      // Line 17, 19
                        g[w[w[K[2 << M]][Y]][W[3][!y]]] = k[3];
                        g[w[w[K[2 << M]][Y]][W[4][!y]]] = k[4];
                      }
                      else   // ERI 18, 20
                        g[w[K[2 << M]][Y]] = k[3];
                    }
#if RJ > 3
                    prn ();
#endif
                    return 0;// Undo XYZ-Wing Transport exclusion Cell Values
                  }
                if (w[K[0]][K[8]] == w[K[4]][N] && (g[w[K[4 >> M]][Y]] & ERI (w[K[2 << M]][Y]) & K[5]))
                {            // ERI 24, 25
                  g[w[K[4 >> M]][Y]] -= K[5];
#if RJ > 2
                  printf ("%d) XYZ-Wing Transport: ERI %d @ %s %s %s SL Value %d ERI b%d%s => -%d @ %s\n",
                    p, b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                    BOX (w[K[2 << M]][Y]), S[w[K[2 << M]][Y]], b[K[5]], S[w[K[4 >> M]][Y]]);
#endif
                  if (solve (p))
                    return 1;
#if RJ > 2
                  printf ("%d) Undo XYZ-Wing Transport: ERI %d @ %s %s %s SL Value %d ERI Box %d Cell %s <= +%d @ %s\n",
                    p, b[g[K[0]]], S[K[0]], S[K[2]], S[K[4]], b[K[5]],
                    BOX (w[K[2 << M]][Y]), S[w[K[2 << M]][Y]], b[K[5]], S[w[K[4 >> M]][Y]]);
#endif
                  g[w[K[4 >> M]][Y]] |= K[5];
#if RJ > 3
                  prn ();
#endif
                  return 0;
                }
              }
            }
          }
          if ((g[w[K[4]][K[6]]] | g[w[K[4]][K[6] + 1]] | g[w[K[4]][K[6] + 2]]) & K[5])
          {                  // Check Wing Cells common Value in XYZ-Wing Hybrid Cells Values
            int k[6] = {-1,-1};

            if (((g[w[K[0]][K[7]]] | g[w[K[0]][K[7] + 1]] | g[w[K[0]][K[7] + 2]]) &
              ~(g[Z = w[K[2]][K[8]]] | g[w[Z][W[3][y]]] | g[w[Z][W[4][y]]] |
              g[w[K[2]][W[3][y]]] | g[w[K[2]][W[4][y]]]) & K[5]) ||
              (g[w[K[0]][K[7]]] & ~(g[w[K[2]][K[8]]] | g[w[K[2]][Z = W[1][y]]] |
              g[w[K[2]][Z + 1]] | g[w[K[2]][Z + 2]] | g[w[K[2]][Z + 3]] |
              g[w[K[2]][Z + 4]] | g[w[K[2]][Z + 5]])) & K[5])
            {                // Backup XYZ-Wing Hybrid 1st Wing either Box or Line wise and exclude Wing Cells common Value from exclusion Cells Values
              k[0] = g[w[K[0]][K[7]]];
              k[2] = g[w[K[0]][K[7] + 1]];
              k[3] = g[w[K[0]][K[7] + 2]];
              g[w[K[0]][K[7]]] &= ~K[5];
              g[w[K[0]][K[7] + 1]] &= ~K[5];
              g[w[K[0]][K[7] + 2]] &= ~K[5];
            }
            if ((g[Z = w[K[0]][K[8]]] | g[w[Z][W[3][y]]] | g[w[Z][W[4][y]]]) &
              ~(g[w[K[4]][W[3][y]]] | g[w[K[4]][W[4][y]]] | g[w[K[4]][K[7]]] |
              g[w[K[4]][K[7] + 1]] | g[w[K[4]][K[7] + 2]]) & K[5])
            {                // Backup XYZ-Wing Hybrid 2nd Wing Line wise and exclude Wing Cells common Value from exclusion Cells Values
              k[1] = g[Z];
              k[4] = g[w[Z][W[3][y]]];
              k[5] = g[w[Z][W[4][y]]];
              g[Z] &= ~K[5];
              g[w[Z][W[3][y]]] &= ~K[5];
              g[w[Z][W[4][y]]] &= ~K[5];
            }
            if ((k[0] & k[1]) + 1)
            {
#if RJ > 2
              printf ("%d)%sXYZ-Wing Hybrid: %d @ %s %s %s %s Hybrid %d @ %s %s %s => -%d @",
                p, k[0] + 1 && k[1] + 1 ? " Dual " : " ", b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]],
                k[0] + 1 && k[1] + 1 ? "Dual" : (k[0] + 1 ? "Box wise" : (y ? "Column wise" : "Row wise")),
                b[K[5]], S[w[K[4]][K[6]]], S[w[K[4]][K[6] + 1]], S[w[K[4]][K[6] + 2]], b[K[5]]);
              if (k[0] + 1)
                printf (" %s %s %s", S[w[K[0]][K[7]]], S[w[K[0]][K[7] + 1]], S[w[K[0]][K[7] + 2]]);
              if (k[1] + 1)
                printf (" %s %s %s", S[Z], S[w[Z][W[3][y]]], S[w[Z][W[4][y]]]);
              printf ("\n");
#endif
              if (solve (p))
                return 1;
#if RJ > 2
              printf ("%d) Undo%sXYZ-Wing Hybrid: %d @ %s %s %s %s Hybrid %d @ %s %s %s <= +%d @",
                p, k[0] + 1 && k[1] + 1 ? " Dual " : " ", b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]],
                k[0] + 1 && k[1] + 1 ? "Dual" : (k[0] + 1 ? "Box wise" : (y ? "Column wise" : "Row wise")),
                b[K[5]], S[w[K[4]][K[6]]], S[w[K[4]][K[6] + 1]], S[w[K[4]][K[6] + 2]], b[K[5]]);
              if (k[0] + 1)
                printf (" %s %s %s", S[w[K[0]][K[7]]], S[w[K[0]][K[7] + 1]], S[w[K[0]][K[7] + 2]]);
              if (k[1] + 1)
                printf (" %s %s %s", S[Z], S[w[Z][W[3][y]]], S[w[Z][W[4][y]]]);
              printf ("\n");
#endif
              if (k[0] + 1)
              {
                g[w[K[0]][K[7]]] = k[0];
                g[w[K[0]][K[7] + 1]] = k[2];
                g[w[K[0]][K[7] + 2]] = k[3];
              }
              if (k[1] + 1)
              {
                g[Z] = k[1];
                g[w[Z][W[3][y]]] = k[4];
                g[w[Z][W[4][y]]] = k[5];
              }
#if RJ > 3
              prn ();
#endif
              return 0;        // Undo XYZ-Wing Hybrid exclusion Cells Values
            }
          }
        }
      }
    }
  }
  for (a = p; a < q; ++a)    // Search WXYZ-Wing Type 1 and Almost Locked Set move Type 1a Apex unsolved Cell positions wise
  {
    if (B[g[r[a]]] > 4 ||    // Skip for either Apex Cell Values > four digits; or
      !(g[w[r[a]][0]] | g[w[r[a]][1]] | g[w[r[a]][2]] |
      g[w[r[a]][3]] | g[w[r[a]][4]] | g[w[r[a]][5]]) ||
      !(g[w[r[a]][14]] | g[w[r[a]][15]] | g[w[r[a]][16]] |
      g[w[r[a]][17]] | g[w[r[a]][18]] | g[w[r[a]][19]]))
      continue;              // No unsolved Cell position in Apex either Row or Column Cell Values
    int K[9] = {r[a], 0};

    for (; K[1] < 8; ++K[1]) // Search 1st Wing Cell position Row wise
    {
      if (!g[K[2] = w[K[0]][K[1]]] || B[g[K[0]] | g[K[2]]] > 4)
        continue;            // Skip for either 1st Wing Cell position not unsolved; or Apex and 1st Wing Cells Values > four digits
      for (K[3] = K[1] > 5 ? 14 : 12; K[3] < 20; ++K[3])
      {                      // Search 2nd Wing Cell position Column wise but not both Wings in Apex Box
        if (!g[K[4] = w[K[0]][K[3]]] || B[g[K[0]] | g[K[2]] | g[K[4]]] > 4)
          continue;          // Skip for either 2nd Wing Cell position not unsolved; or Apex and Wings Cells Values > four digits
        for (Y = 0; Y < 2; ++Y)
        {                    // Search 3rd Wing Cell position Line wise
          if ((!Y && K[3] < 14) || (Y && K[1] > 5) || B[g[K[4 >> Y]]] > 2)
            continue;        // Skip for either 2nd (or 1st) Wing Cell position within chute; or 2nd (or 1st) Wing Cell Values > two digits
          for (K[5] = !Y && K[1] > 5 ? 0 : K[W[14][Y]] + (Y && K[3] == 12) + 1; K[5] < W[2][Y]; ++K[5])
          {                  // Search 3rd Wing Cell position
            if (!g[K[6] = w[K[0]][K[5]]] || B[g[K[0]] | g[K[2]] | g[K[4]] | g[K[6]]] > 4 ||
                             // Skip for either 3rd Wing Cell position not unsolved; or Apex and Wings Cells Values > four digits; or
              B[K[7] = g[K[4 >> Y]] & (g[K[2 << Y]] | g[K[6]])] != 1 ||
                             // Wing Cells common Value not one digit; or
              ((g[K[0]] & K[7]) &&
                             // Wing Cells common Value in Apex Cell Values; and
              !((g[K[2]] & K[7]) && K[1] > 5) && !((g[K[4]] & K[7]) && K[3] < 14)) ||
                             // either 2nd or 3rd Wing Cell position within Apex Box; or
              (g[K[2 << Y]] & g[K[6]] & K[7]))
              continue;      // Wing Cells common Value in Both 1st (or 2nd) and 3rd Wing Cells Values
            int k[6] = {g[K[8] = K[g[K[2]] & K[7] ? 2 : 6] - K[0] +
                       K[g[K[4]] & K[7] ? 4 : 6]], 0, 0, 0, 0,-1};

            if (((g[K[2]] & K[7]) && K[1] > 5) || ((g[K[4]] & K[7]) && K[3] < 14))
            {                // Wings Cells common Value in Wing Cell position within Apex Box
              k[5] = (g[K[2]] & K[7]) && K[1] > 5 ? 1 : 0;
              if (g[K[0]] & K[7])
                k[0] = 0;
              else
              {
                k[1] = g[w[K[8]][W[3][k[5]]]];
                k[2] = g[w[K[8]][W[4][k[5]]]];
              }
              k[3] = g[w[K[0]][W[3][k[5]]]];
              k[4] = g[w[K[0]][W[4][k[5]]]];
            }
            if ((k[0] | k[1] | k[2] | k[3] | k[4]) & K[7])
            {                // Check no Wing Cells common Value in WXYZ-Wing Type 1 exclusion Cell Values
              if (k[5] + 1)
              {              // Drop Wing Cells common Value from WXYZ-Wing Type 1 exclusion Cell positions
                g[w[K[0]][W[3][k[5]]]] &= ~K[7];
                g[w[K[0]][W[4][k[5]]]] &= ~K[7];
                if (~g[K[0]] & K[7])
                {
                  g[K[8]] &= ~K[7];
                  g[w[K[8]][W[3][k[5]]]] &= ~K[7];
                  g[w[K[8]][W[4][k[5]]]] &= ~K[7];
                }
              }
              else
                g[K[8]] &= ~K[7];
#if RJ > 2
              printf ("%d) WXYZ-Wing Type 1: %d @ %s %s %s %s => -%d @ ",
                p, b[g[K[2]] | g[K[4]] | g[K[6]]], S[K[0]], S[K[2]], S[K[4]], S[K[6]], b[K[7]]);
              if (k[5] + 1)
              {
                printf ("%s %s", S[w[K[0]][W[3][k[5]]]], S[w[K[0]][W[4][k[5]]]]);
                if (~g[K[0]] & K[7])
                  printf (" %s %s %s", S[K[8]], S[w[K[8]][W[3][k[5]]]], S[w[K[8]][W[4][k[5]]]]);
                printf ("\n");
              }
              else
                printf ("%s\n", S[K[8]]);
#endif
              if (solve (p))
                return 1;
#if RJ > 2
              printf ("%d) Undo WXYZ-Wing Type 1: %d @ %s %s %s %s <= +%d @ ",
                p, b[g[K[2]] | g[K[4]] | g[K[6]]], S[K[0]], S[K[2]], S[K[4]], S[K[6]], b[K[7]]);
              if (k[5] + 1)
              {
                printf ("%s %s", S[w[K[0]][W[3][k[5]]]], S[w[K[0]][W[4][k[5]]]]);
                if (~g[K[0]] & K[7])
                  printf (" %s %s %s", S[K[8]], S[w[K[8]][W[3][k[5]]]], S[w[K[8]][W[4][k[5]]]]);
                printf ("\n");
              }
              else
                printf ("%s\n", S[K[8]]);
#endif
              if (k[5] + 1)  // Undo Wing Cells common Value to WXYZ-Wing Type 1 exclusion Cell positions
              {
                g[w[K[0]][W[3][k[5]]]] = k[3];
                g[w[K[0]][W[4][k[5]]]] = k[4];
                if (~g[K[0]] & K[7])
                {
                  g[K[8]] = k[0];
                  g[w[K[8]][W[3][k[5]]]] = k[1];
                  g[w[K[8]][W[4][k[5]]]] = k[2];
                }
              }
              else
                g[K[8]] = k[0];
#if RJ > 3
              prn ();
#endif
              return 0;      // Undo Wing Cells common Value to WXYZ-Wing Type 1 exclusion Cell Values
            }
// WXYZ-Wing Type 1 Transport
          }
        }
        if (K[1] < 6 && K[3] > 13 &&
                             // Check Almost Locked Set move Type 1a 1st Wing Cell position not Apex Box; and 2nd Wing Cell position not Apex Box; and
          B[g[K[0]]] == 3 && B[g[K[2]]] == 2 && B[g[K[4]]] == 2 &&
                             // Apex Cell Values three digits; and 1st Wing Cell Values two digits; and 2nd Wing Cell Values two digits; and
          !(g[K[2]] & g[K[4]]) && B[g[K[5] = K[2] - K[0] + K[4]]] == 2 &&
                             // 1st and 2nd Wing Cells Values three digits; and 3rd Wing Cell Values two digits; and
          B[g[K[2]] | g[K[5]]] == 3 && B[g[K[4]] | g[K[5]]] == 3 &&
                             // 1st and 3rd Wing Cells Values three digits; and 2nd and 3rd Wing Cells Values three digits; and
          B[g[K[0]] | g[K[5]]] == 4 &&
                             // Apex and 3rd Wing Cells Values four digits; and
          ((g[w[K[0]][W[3][Y = B[g[K[0]] | g[K[2]]] > 3]]] |
          g[w[K[0]][W[4][Y]]] | g[w[y = K[2 << Y]][W[3][Y]]] | g[w[y][W[4][Y]]] |
          g[w[K[0]][Z = W[K[W[14][Y]] < W[5][Y] ? 5 : 1][Y]]] |
          g[w[K[0]][Z + 1]] | g[w[K[0]][Z + 2]]) & (K[6] = ~g[K[5]] & g[y])))
        {                    // Almost Locked Set move Type 1a exclusion Cell Values
          int k[7] = {g[w[K[0]][W[3][Y]]], g[w[K[0]][W[4][Y]]],
                      g[w[y][W[3][Y]]], g[w[y][W[4][Y]]],
                      g[w[K[0]][Z]], g[w[K[0]][Z + 1]], g[w[K[0]][Z + 2]]};
                             // Backup Almost Locked Set move Type 1a exclusion Cell Values and drop Wing Cells common exclusion Values
          g[w[K[0]][W[3][Y]]] &= ~K[6];
          g[w[K[0]][W[4][Y]]] &= ~K[6];
          g[w[y][W[3][Y]]] &= ~K[6];
          g[w[y][W[4][Y]]] &= ~K[6];
          g[w[K[0]][Z]] &= ~K[6];
          g[w[K[0]][Z + 1]] &= ~K[6];
          g[w[K[0]][Z + 2]] &= ~K[6];
#if RJ > 2
          printf ("%d) Almost Locked Set move Type 1a: %d @ %s %s %s %s => -%d @ %s %s %s %s %s %s %s\n",
            p, b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], S[K[5]],
            b[K[6]], S[w[K[0]][W[3][Y]]], S[w[K[0]][W[4][Y]]],
            S[w[y][W[3][Y]]], S[w[y][W[4][Y]]],
            S[w[K[0]][Z]], S[w[K[0]][Z + 1]], S[w[K[0]][Z + 2]]);
#endif
          if (solve (p))
            return 1;
#if RJ > 2
          printf ("%d) Undo Almost Locked Set move Type 1a: %d @ %s %s %s %s <= +%d @ %s %s %s %s %s %s %s\n",
            p, b[g[K[2]] | g[K[4]]], S[K[0]], S[K[2]], S[K[4]], S[K[5]],
            b[K[6]], S[w[K[0]][W[3][Y]]], S[w[K[0]][W[4][Y]]],
            S[w[y][W[3][Y]]], S[w[y][W[4][Y]]],
            S[w[K[0]][Z]], S[w[K[0]][Z + 1]], S[w[K[0]][Z + 2]]);
#endif
          g[w[K[0]][W[3][Y]]] = k[0];
          g[w[K[0]][W[4][Y]]] = k[1];
          g[w[y][W[3][Y]]] = k[2];
          g[w[y][W[4][Y]]] = k[3];
          g[w[K[0]][Z]] = k[4];
          g[w[K[0]][Z + 1]] = k[5];
          g[w[K[0]][Z + 2]] = k[6];
#if RJ > 3
          prn ();
#endif
          return 0;          // Undo Wing Cells common Value to Almost Locked Set move Type 1a exclusion Cell Values
        }
      }
    }
  }
  for (a = p; a < q; ++a)    // Search WXYZ-Wing Type 2a, Type 2b, Type 3, Type 4a, Type 4b and Almost Locked Set move Type 2a Apex unsolved Cell positions wise
  {
    if (B[g[r[a]]] > 4)      // Skip for unsolved Cell Values > four digits
      continue;
    int K[8] = {r[a]};       // Assign Apex Cell position

    for (y = 0; y < 2; ++y)  // Search Wing Cells position Chute wise
    {
      if (!(g[w[K[0]][W[6][y]]] | g[w[K[0]][W[7][y]]] | g[w[K[0]][W[8][y]]] |
        g[w[K[0]][W[9][y]]] | g[w[K[0]][W[10][y]]] | g[w[K[0]][W[10][y]]]) ||
        !(g[w[K[0]][W[1][y]]] | g[w[K[0]][W[1][y] + 1]] | g[w[K[0]][W[1][y] + 2]] |
        g[w[K[0]][W[1][y] + 3]] | g[w[K[0]][W[1][y] + 4]] | g[w[K[0]][W[1][y] + 5]]))
        continue;            // Skip for no unsolved Cell position in either Apex Box or Line
      for (K[1] = W[6][y]; K[1] < W[0][y]; ++K[1])
      {                      // Search 1st Wing Cell position Box wise
        if (!g[K[2] = w[K[0]][K[1]]] || B[g[K[0]] | g[K[2]]] > 4)
          continue;          // Skip for either 1st Wing Cell position not unsolved; or Apex and 1st Wing Cell Values > four digits
        for (K[3] = W[1][y]; K[3] < W[2][y]; ++K[3])
        {                    // Search 2nd Wing Cell position Line wise
          if (!g[K[4] = w[K[0]][K[3]]] || B[g[K[0]] | g[K[2]] | g[K[4]]] > 4)
            continue;        // Skip for either 2nd Wing Cell position not unsolved; or Apex and Wings Cells Values > four digits
          for (Y = 0; Y < 2; ++Y)
                             // Search 3rd Wing Cell position Box and Line wise
            for (K[5] = K[W[14][Y]] + 1; K[5] < W[Y << 1][y]; ++K[5])
            {                // Search 3rd Wing Cell position
              if (!g[K[6] = w[K[0]][K[5]]] ||
                             // Skip for either 3rd Wing Cell position not unsolved; or
                B[g[K[0]] | g[K[2]] | g[K[4]] | g[K[6]]] != 4 ||
                             // Apex and Wings Cells Values not four digits; or
                !(g[K[0]] & g[K[4 >> Y]]) ||
                             // No common Value in Apex and 1st (or 2nd) Wing Cells Values; or
                !(g[K[0]] & (g[K[2 << Y]] | g[K[6]])) ||
                             // No common Value in Apex and 2nd (or 1st) or 3rd Wings Cells Values; or
                B[K[7] = g[K[4 >> Y]] & (g[K[2 << Y]] | g[K[6]])] != 1)
                continue;    // Wing Cells common Value not one digit
              int A[2] = {-1},
                  k[5] = {g[w[K[0]][W[3][y]]], g[w[K[0]][W[4][y]]]};
                             // Backup WXYZ-Wing Type 2b and Type 3 exclusion Cell positions
              if ((~g[K[0]] & K[7]) &&
                             // Check no Wing Cells common Value in Apex Cell Values; and
                (K[6] == w[K[2 << Y]][W[3][y]] || K[6] == w[K[2 << Y]][W[4][y]] ||
                             // 3rd Wing Cell position within 1st (or 2nd) Wing Cell position mini-Line; or
                (g[K[2 << Y]] & K[7]) != (g[K[6]] & K[7])))
              {              // Wing Cells common Value not in both 1st (or 2nd) Wing Cell Values and 3rd Wing Cell Values
                A[0] = K[g[K[2]] & g[K[4 >> Y]] & (g[K[2 << Y]] | g[K[6]]) ? 2 : 6];
                A[1] = W[K[g[K[4]] & g[K[4 >> Y]] & (g[K[2 << Y]] | g[K[6]]) ? 3 : 5] < W[5][y] ? 1 : 5][y];
                k[2] = g[w[A[0]][A[1]]];
                k[3] = g[w[A[0]][A[1] + 1]];
                k[4] = g[w[A[0]][A[1] + 2]];
              }              // Backup WXYZ-Wing Type 2a more exclusion Cell positions
              if ((k[0] | k[1] | k[2] | k[3] | k[4]) & K[7])
              {              // Check WXYZ-Wing Type 2a, Type 2b and Type 3 exclusion Cells Values
                             // Drop Wing Cells common Value from WXYZ-Wing Type 2b and Type 3 exclusion Cell positions
                g[w[K[0]][W[3][y]]] &= ~K[7];
                g[w[K[0]][W[4][y]]] &= ~K[7];
                if (A[0] + 1)
                {            // Drop Wing Cells common Value from WXYZ-Wing Type 2a more exclusion Cell positions
                  g[w[A[0]][A[1]]] &= ~K[7];
                  g[w[A[0]][A[1] + 1]] &= ~K[7];
                  g[w[A[0]][A[1] + 2]] &= ~K[7];
                }
#if RJ > 2
                printf ("%d) WXYZ-Wing Type %s: %d @ %s %s %s %s => -%d @ %s %s",
                  p, A[0] + 1 ? "2a" : g[K[0]] & K[7] ? "3" : "2b", b[g[K[0]] | g[K[2]] | g[K[4]] | g[K[6]]],
                  S[K[0]], S[K[2]], S[K[4]], S[K[6]], b[K[7]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]]);
                if (A[0] + 1)
                  printf (" %s %s %s", S[w[A[0]][A[1]]], S[w[A[0]][A[1] + 1]], S[w[A[0]][A[1] + 2]]);
                printf ("\n");
#endif
                if (solve (p))
                  return 1;
#if RJ > 2
                printf ("%d) Undo WXYZ-Wing Type %s: %d @ %s %s %s %s <= +%d @ %s %s",
                  p, A[0] + 1 ? "2a" : g[K[0]] & K[7] ? "3" : "2b", b[g[K[0]] | g[K[2]] | g[K[4]] | g[K[6]]],
                  S[K[0]], S[K[2]], S[K[4]], S[K[6]], b[K[7]], S[w[K[0]][W[3][y]]], S[w[K[0]][W[4][y]]]);
                if (A[0] + 1)
                  printf (" %s %s %s", S[w[A[0]][A[1]]], S[w[A[0]][A[1] + 1]], S[w[A[0]][A[1] + 2]]);
                printf ("\n");
#endif
                g[w[K[0]][W[3][y]]] = k[0];
                g[w[K[0]][W[4][y]]] = k[1];
                if (A[0] + 1)
                {
                  g[w[A[0]][A[1]]] = k[2];
                  g[w[A[0]][A[1] + 1]] = k[3];
                  g[w[A[0]][A[1] + 2]] = k[4];
                }
#if RJ > 3
                prn ();
#endif
                return 0;    // Undo WXYZ-Wing Type 2a, Type 2b and Type 3 exclusion Cells Values
              }
// WXYZ-Wing Hybrid Type 1 and Type 2
// WXYZ-Wing Type 2a, Type 2b and Type 3 Transport
            }
          for (K[5] = 3; K[5] < 5; ++K[5])
          {                  // Search 2nd Apex Cell position mini-Line wise
            if (!g[K[6] = w[K[0]][W[K[5]][y]]] ||
                             // Skip for either 2nd Apex Cell position not unsolved; or
              B[g[K[0]] | g[K[2]] | g[K[4]] | g[K[6]]] != 4 ||
                             // Apex Cells Values and Wing Cells Values not four digits; or
              !((g[K[0]] | g[K[6]]) & g[K[2]]) ||
                             // No common Value in Apex Cells and 1st Wing Cell Values; or
              !((g[K[0]] | g[K[6]]) & g[K[4]]) ||
                             // No common Value in Apex Cells and 2nd Wing Cell Values; or
              B[K[7] = g[K[2]] & g[K[4]]] != 1)
              continue;      // Wing Cells common Value not one digit
            int k[4] = {g[w[K[0]][W[7 - K[5]][y]]]};
                             // Backup WXYZ-Wing Type 4b exclusion Cell position
            Z = -1;
            if (~(g[K[0]] | g[K[6]]) & K[7])
            {                // Check no Wing Cells common Value in Apex Cells Values
              Z = W[K[3] < W[5][y] ? 1 : 5][y];
                             // Assign Wing Cells common 1st exclusion Cell position
              k[1] = g[w[K[2]][Z]];
              k[2] = g[w[K[2]][Z + 1]];
              k[3] = g[w[K[2]][Z + 2]];
            }                // Backup WXYZ-Wing Type 4a more exclusion Cell positions
            if ((k[0] | k[1] | k[2] | k[3]) & K[7])
            {                // Check WXYZ-Wing Type 4a and Type 4b exclusion Cells Values
                             // Drop Wing Cells common Value from WXYZ-Wing Type 4b exclusion Cell position
              g[w[K[0]][W[7 - K[5]][y]]] &= ~K[7];
              if (Z + 1)
              {              // Drop Wing Cells common Value from WXYZ-Wing Type 4a more exclusion Cell positions
                g[w[K[2]][Z]] &= ~K[7];
                g[w[K[2]][Z + 1]] &= ~K[7];
                g[w[K[2]][Z + 2]] &= ~K[7];
              }
#if RJ > 2
              printf ("%d) WXYZ-Wing Type 4%c: %d @ %s %s %s %s => -%d @ %s",
                p, Z + 1 ? 'a' : 'b', b[g[K[0]] | g[K[2]] | g[K[4]] | g[K[6]]],
                S[K[0]], S[K[6]], S[K[2]], S[K[4]], b[K[7]], S[w[K[0]][W[7 - K[5]][y]]]);
              if (Z + 1)
                printf (" %s %s %s", S[w[K[2]][Z]], S[w[K[2]][Z + 1]], S[w[K[2]][Z + 2]]);
              printf ("\n");
#endif
              if (solve (p))
                return 1;
#if RJ > 2
              printf ("%d) Undo WXYZ-Wing Type 4%c: %d @ %s %s %s %s <= +%d @ %s",
                p, Z + 1 ? 'a' : 'b', b[g[K[0]] | g[K[2]] | g[K[4]] | g[K[6]]],
                S[K[0]], S[K[6]], S[K[2]], S[K[4]], b[K[7]], S[w[K[0]][W[7 - K[5]][y]]]);
              if (Z + 1)
                printf (" %s %s %s", S[w[K[2]][Z]], S[w[K[2]][Z + 1]], S[w[K[2]][Z + 2]]);
              printf ("\n");
#endif
              g[w[K[0]][W[7 - K[5]][y]]] = k[0];
              if (Z + 1)
              {
                g[w[K[2]][Z]] = k[1];
                g[w[K[2]][Z + 1]] = k[2];
                g[w[K[2]][Z + 2]] = k[3];
              }
#if RJ > 3
              prn ();
#endif
              return 0;      // Undo WXYZ-Wing Type 4a and Type 4b exclusion Cells Values
            }
          }
/*
          for (Y = W[K[3] < W[5][y] ? 1 : 5][y]; Y < W[K[3] < W[5][y] ? 5 : 2][y]; ++Y)
          {                  // Search Almost Locked Set move Type 2a 3rd Wing Cell position 1st Wing Box and 2nd Wing Line wise
            if (B[g[K[0]]] != 3 || B[g[K[2]]] != 2 || B[g[K[4]]] != 2 ||
                             // Check Apex Cell Values not three; or 1st Wing Cell Values not two; or 2nd Wing Cell Values not two; or
              !B[g[K[2]] & g[K[4]]] || B[g[K[5] = w[K[4]][Y]]] != 2 ||
              B[g[K[0]] & g[K[5]]] != 1 || B[g[K[2]] & g[K[5]]] != 1 || B[g[K[4]] & g[K[5]]] != 1)
              continue;
            K[6] = W[K[3] < W[5][y] ? 5 : 1][y];
            K[7] = 0;
            if (Y = (B[g[K[0]] & g[K[2]]] == 2 && B[g[K[0]] & g[K[4]]] == 1 &&
              (g[w[K[0]][w[3][y]]] | g[w[K[0]][w[4][y]]] |
              g[w[K[2]][w[3][y]]] | g[w[K[2]][w[4][y]]] |
              ) & ))
          }
/**/
        }
      }
    }
  }
  for (Z = -1, a = p; a < q; ++a)
    if (B[g[r[a]]] < 3)      // Bivalue Universal Grave
      continue;              // Skip for unsolved Cell Values < three digits
    else if (B[g[r[a]]] == 3 && Z < 0)
      Z = r[a];              // Backup first unsolved Cell position having Trivalues
    else
      break;
  if (a == q)                // All unsolved Cell positions checked
  {
    if (Z + 1)               // One Trivalue Cell position found
    {
      for (Y = g[Z]; y = Y & -Y; Y -= y)
                             // For each digit in Trivalue Cell position
        if ((g[w[Z][0]] & y ? 1 : 0) + (g[w[Z][1]] & y ? 1 : 0) +
          (g[w[Z][2]] & y ? 1 : 0) + (g[w[Z][3]] & y ? 1 : 0) +
          (g[w[Z][4]] & y ? 1 : 0) + (g[w[Z][5]] & y ? 1 : 0) +
          (g[w[Z][6]] & y ? 1 : 0) + (g[w[Z][7]] & y ? 1 : 0) == 2 ||
          (g[w[Z][6]] & y ? 1 : 0) + (g[w[Z][7]] & y ? 1 : 0) +
          (g[w[Z][8]] & y ? 1 : 0) + (g[w[Z][9]] & y ? 1 : 0) +
          (g[w[Z][10]] & y ? 1 : 0) + (g[w[Z][11]] & y ? 1 : 0) +
          (g[w[Z][12]] & y ? 1 : 0) + (g[w[Z][13]] & y ? 1 : 0) == 2 ||
          (g[w[Z][12]] & y ? 1 : 0) + (g[w[Z][13]] & y ? 1 : 0) +
          (g[w[Z][14]] & y ? 1 : 0) + (g[w[Z][15]] & y ? 1 : 0) +
          (g[w[Z][16]] & y ? 1 : 0) + (g[w[Z][17]] & y ? 1 : 0) +
          (g[w[Z][18]] & y ? 1 : 0) + (g[w[Z][19]] & y ? 1 : 0) == 2)
        {                    // Digit found Row, Box or Column wise in two Cell positions
          int k = g[Z];      // Backup BUG+1 Trivalue exclusion Cell Values

          g[Z] = y;          // Remove other digits from Trivalue exclusion Cell Values
#if RJ > 2
          printf ("%d) BUG+1: %d @ %s => -%d @ %s\n", p, b[k], S[Z], b[k - y], S[Z]);
#endif
          if (solve (p))
            return 1;
#if RJ > 2
          printf ("%d) Undo BUG+1: %d @ %s <= +%d @ %s\n", p, b[k], S[Z], b[k - y], S[Z]);
#endif
          g[Z] = k;
#if RJ > 3
          prn ();
#endif
          return 0;          // Undo BUG+1 exclusion Cells Values
        }
    }
#if RJ > 2
    else
      printf ("%d) There might be a BUG in the current state of the Puzzle's pencilmark!\n", p);
#endif
  }
  y = 2;                     // 2 Represent Guess
  if (++n[3] > n[4])
    ++n[4];
NHSCF:
  if (x > p)                 // Check current Cell position for sorting and excluding
  {
    a = r[p];
    r[p] = r[x];
    r[x] = a;
  }
  for (Y = g[r[p]], g[r[p]] = 0; s[r[p]] = z & -z; z -= y > 1 ? s[r[p]] : z)
  {                          // Backup and clear current Cell Values and assign current Cell position to each current Cell Value
    for (++n[y], Z = a = 0; a < 20; ++a)
                             // Search 20 peer Cell positions
      if (g[w[r[p]][a]] & s[r[p]])
      {
        Z |= 1 << a;         // Backup and drop current Cell Value from 20 peer Cell positions
        g[w[r[p]][a]] -= s[r[p]];
      }
#if RJ > 2
    printf ("%d) %s: %d @ %s",
      p + 1, y ? (y > 1 ? "Trial & Error" : "Hidden single") : "Naked single",
      b[s[r[p]]], S[r[p]]);
    if (y)
    {
      printf (" from Values %d", b[Y]);
      if (y < 2)
        printf (" in %s %d", Z & 255 ? (Z >> 12 ? "Box" : "Column") : "Row",
          Z & 255 ? (Z >> 12 ? BOX (r[p]) : b[w[r[p]][20] & 511]) : b[(w[r[p]][20] >> 18) & 511]);
    }
    printf ("\n");
#endif
    if (p + 1 == q || solve (p + 1))
      return 1;              // Check either all Cell positions solved; or recursive solve for next unsolved Cell position
#if RJ > 2
    printf ("%d) Undo %s: %d @ %s",
      p + 1, y ? (y > 1 ? "Trial & Error" : "Hidden single") : "Naked single",
      b[s[r[p]]], S[r[p]]);
    if (y)
    {
      printf (" from Values %d", b[Y]);
      if (y < 2)
        printf (" in %s %d", Z & 255 ? (Z >> 12 ? "Box" : "Column") : "Row",
          Z & 255 ? (Z >> 12 ? BOX (r[p]) : b[w[r[p]][20] & 511]) : b[(w[r[p]][20] >> 18) & 511]);
    }
    printf ("\n");
#endif
    while (a)                // Undo current Cell Value to 20 peer Cell positions
      if (Z & (1 << --a))
        g[w[r[p]][a]] |= s[r[p]];
#if RJ > 3
    g[r[p]] = Y;             // Undo current Cell Values to current Cell position
    prn ();
    g[r[p]] = 0;             // Drop current Cell Values from current Cell position
#endif
  }
  if (y == 2)
    --n[3];
  g[r[p]] = Y;
  return 0;                  // Undo current Cell Values to current Cell position
}

int check (int p, int q)
{
  if ((s[w[p][0]] | s[w[p][1]] | s[w[p][2]] | s[w[p][3]] | s[w[p][4]] |
    s[w[p][5]] | s[w[p][6]] | s[w[p][7]] | s[w[p][8]] | s[w[p][9]] |
    s[w[p][10]] | s[w[p][11]] | s[w[p][12]] | s[w[p][13]] | s[w[p][14]] |
    s[w[p][15]] | s[w[p][16]] | s[w[p][17]] | s[w[p][18]] | s[w[p][19]]) & q)
    return 0;                // Check duplicate Cell Value in 20 peer Value Cell positions
  return q;
}

int invalid (void)
{
  int a,
      p = 0;

  for (; p < 81; ++p)
  {
    g[p] = 0;                // Clear Cell Values
    if (!s[p])               // Check unsolved Cell position
    {
      for (a = 1; a < 257; a <<= 1)
        g[p] |= check (p, a);// Check constraint and assign Cell Value for unsolved Cell position digit wise
      if (!g[p])             // Check no Cell Value assigned
        return 1;
#if RJ
      n[8] += B[g[p]];       // Number of possibilities
#endif
      r[q++] = p;            // Assign unsolved Cell position for sorting and excluding
    }
    else if (!check (p, s[p]))
      return 1;              // Check constraint for clue Cell position
  }
  return 0;                  // Return invalid puzzle
}

int main (void)
{
  int a = -1,
      m,
      i = 0,
      t = 0,
      u = 0,
      v = 0,
      y = 0;

  float c,
        d = 0,
        e = 0,
        f = 0,
        k = 0;

  FILE *o = fopen ("sudoku.txt", "r");

  n[5] = n[6] = n[7] = 0;
  if (o == NULL)
    printf ("Error: Unable to open sudoku.txt file for read !!\n");
  else
    do
    {
      if ((m = fgetc (o)) != 10 && m != EOF && a < 80)
        s[++a] = (m > 48 && m < 58) << (m - 49);
                             // Assign given Cell positions
      else if (m == 10 || m == EOF)
      {
#if RJ > 1
        printf ("\n");
#endif
        q = n[0] = n[1] = n[2] = n[3] = n[4] = n[8] = 0;
        c = clock ();
        while (a < 80)       // Clear remaining unsolved Cell positions
          s[++a] = 0;
        if (invalid ())
        {
          c = (clock () - c) / CLOCKS_PER_SEC;
          d += c;
          ++t;
          ++i;
#if RJ
          printf ("%ld) Error: Invalid Sudoku! # I%ld", t, i);
#endif
        }
        else if (!q)
        {
          c = (clock () - c) / CLOCKS_PER_SEC;
          k += c;
          ++t;
          ++y;
#if RJ
          printf ("%ld) Valid Sudoku # V%ld", t, y);
#endif
        }
        else if (solve (0))
        {
          c = (clock () - c) / CLOCKS_PER_SEC;
          e += c;
          ++t;
          ++v;
          if (!n[2])
            ++n[5];
          if (n[2] > n[6])
            n[6] = n[2];
          if (n[4] > n[7])
            n[7] = n[4];
#if RJ
          printf ("%ld) ", t);
          for (a = 0; a < 81; ++a)
            printf ("%d", b[s[a]]);
          printf (" # S%ld", v);
#endif
        }
        else
        {
          c = (clock () - c) / CLOCKS_PER_SEC;
          f += c;
          ++t;
          ++u;
#if RJ
          printf ("%ld) Error: Unsolvable Sudoku! # U%ld", t, u);
#endif
        }
#if RJ
        printf (" # C%d # P%d # N%ld # H%ld # G%ld # D%ld # %f\n", 81 - q, n[8], n[0], n[1], n[2], n[4], 0 /*c*/);
#endif
        a = -1;
      }
#if RJ > 1
      if (m != 10 && m != 13 && m != EOF)
        printf ("%c", m);
#endif
    }
    while (m != EOF);
  printf ("=======================================\n");
  printf ("Total Sudoku puzzles read  : %ld\n", t);
  printf ("Total time for all puzzles : %f\n", d + k + e + f);
  printf ("Average time per puzzle    : %f\n", t ? (d + k + e + f) / t : 0);
  printf ("Number of valid puzzles    : %ld\n", y);
  printf ("Time for valid puzzles     : %f\n", k);
  printf ("Average time per valid     : %f\n", y ? k / y : 0);
  printf ("Number of invalid puzzles  : %ld\n", i);
  printf ("Time for invalid puzzles   : %f\n", d);
  printf ("Average time per invalid   : %f\n", i ? d / i : 0);
  printf ("Number of solved puzzles   : %ld\n", v);
  printf ("Time for solved puzzles    : %f\n", e);
  printf ("Average time per solved    : %f\n", v ? e / v : 0);
  printf ("Number of unsolved puzzles : %ld\n", u);
  printf ("Time for unsolved puzzles  : %f\n", f);
  printf ("Average time per unsolved  : %f\n", u ? f / u : 0);
  printf ("Total solved without guess : %d\n", n[5]);
  printf ("Total solved with guess    : %d\n", v - n[5]);
  printf ("Maximum number of guess    : %d\n", n[6]);
  printf ("Maximum number of depth    : %d\n", n[7]);
  if (fclose (o) == EOF)
    printf ("Error: Unable to close sudoku.txt file !!");
}
